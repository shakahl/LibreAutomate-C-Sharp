#pragma warning disable 1591 //missing XML documentation

namespace Au {
	/// <summary>
	/// Gets known/special folder paths (Desktop, Temp, etc).
	/// </summary>
	/// <remarks>
	/// Most functions return <see cref="FolderPath"/>, not string. It is implicitly convertible to string. Its operator + appends a filename or relative path string, with \ separator if need. Example: <c>string s = folders.Desktop + "file.txt"; //C:\Users\Name\Desktop\file.txt</c>
	/// If a function cannot get folder path, the return value contains null string. Then the + operator would throw <b>ArgumentException</b>.
	///
	/// Some folders are known only on newer Windows versions or only on some computers. Some functions have a suffix like <b>_Win8</b> which means that the folder is unavailable on older Windows.
	/// Some known folders, although supported and registerd, may be still not created.
	/// 
	/// Some folders are virtual, for example Control Panel. They don't have a file system path, but can be identified by a data structure called "ITEMIDLIST" or "PIDL". Functions of the nested class <see cref="shell"/> return it as <see cref="Pidl"/> or string <c>":: ITEMIDLIST"</c> that can be used with some functions of this library (<see cref="run.it"/>, <see cref="icon.of"/>, <see cref="icon.ofPidl(Pidl, int)"/>) but not with .NET functions.
	///
	/// Most functions use Windows "Known Folders" API, such as <msdn>SHGetKnownFolderPath</msdn>.
	/// The list of Windows predefined known folders: <msdn>KNOWNFOLDERID</msdn>.
	/// Names of folders specific to current process have prefix <b>This</b>, like <b>ThisApp</b>.
	/// 
	/// Some paths depend on the bitness (32 or 64 bit) of the OS and this process.
	/// <table>
	/// <tr>
	/// <td>32-bit Windows</td>
	/// <td>
	/// System, SystemX86, SystemX64: <c>@"C:\WINDOWS\system32"</c>
	/// <br/>ProgramFiles, ProgramFilesX86, ProgramFilesX64: <c>@"C:\Program Files"</c>
	/// <br/>ProgramFilesCommon, ProgramFilesCommonX86, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
	/// </td>
	/// </tr>
	/// <tr>
	/// <td>64-bit Windows, 64-bit process</td>
	/// <td>
	/// System, SystemX64: <c>@"C:\WINDOWS\system32"</c>
	/// <br/>SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
	/// <br/>ProgramFiles, ProgramFilesX64: <c>@"C:\Program Files"</c>
	/// <br/>ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
	/// <br/>ProgramFilesCommon, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
	/// <br/>ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
	/// </td>
	/// </tr>
	/// <tr>
	/// <td>64-bit Windows, 32-bit process</td>
	/// <td>
	/// System: <c>@"C:\WINDOWS\system32"</c>. However the OS in most cases redirects this path to <c>@"C:\WINDOWS\SysWOW64"</c>.
	/// <br/>SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
	/// <br/>SystemX64: <c>@"C:\WINDOWS\Sysnative"</c>. The OS redirects it to the true <c>@"C:\WINDOWS\system32"</c>. It is a special path, not in Explorer.
	/// <br/>ProgramFiles, ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
	/// <br/>ProgramFilesX64: <c>@"C:\Program Files"</c>
	/// <br/>ProgramFilesCommon, ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
	/// <br/>ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
	/// </td>
	/// </tr>
	/// </table>
	/// </remarks>
	public static class folders {
		#region generated by macro "Auto create special folders class from KNOWNFOLDERID"

		public static FolderPath AccountPictures_Win8 => _Get(0x008ca0b1, 0x55b44c56, 0xb8a84de4, 0xb299d3be);
		public static FolderPath AdminTools => _Get(0x724EF170, 0xA42D4FEF, 0x9F26B60E, 0x846FBA4F);
		public static FolderPath ApplicationShortcuts_Win8 => _Get(0xA3918781, 0xE5F24890, 0xB3D9A7E5, 0x4332328C);
		public static FolderPath CameraRoll_Win81 => _Get(0xAB5FB87B, 0x7CE24F83, 0x915D5508, 0x46C9537B);
		public static FolderPath CDBurning => _Get(0x9E52AB10, 0xF80D49DF, 0xACB84330, 0xF5687855);
		public static FolderPath CommonAdminTools => _Get(0xD0384E7D, 0xBAC34797, 0x8F14CBA2, 0x29B392B5);
		public static FolderPath CommonOEMLinks => _Get(0xC1BAE2D0, 0x10DF4334, 0xBEDD7AA2, 0x0B227A9D);
		public static FolderPath CommonPrograms => _Get(0x0139D44E, 0x6AFE49F2, 0x86903DAF, 0xCAE6FFB8);
		public static FolderPath CommonStartMenu => _Get(0xA4115719, 0xD62E491D, 0xAA7CE74B, 0x8BE3B067);
		public static FolderPath CommonStartup => _Get(0x82A5EA35, 0xD9CD47C5, 0x9629E15D, 0x2F714E6E);
		public static FolderPath CommonTemplates => _Get(0xB94237E7, 0x57AC4347, 0x9151B08C, 0x6C32D1F7);
		public static FolderPath Contacts => _Get(0x56784854, 0xC6CB462b, 0x816988E3, 0x50ACB882);
		public static FolderPath Cookies => _Get(0x2B0F765D, 0xC0E94171, 0x908E08A6, 0x11B84FF6);
		public static FolderPath Desktop => _Get(0xB4BFCC3A, 0xDB2C424C, 0xB0297FE9, 0x9A87C641);
		public static FolderPath DeviceMetadataStore => _Get(0x5CE4A5E9, 0xE4EB479D, 0xB89F130C, 0x02886155);
		public static FolderPath Documents => _Get(0xFDD39AD0, 0x238F46AF, 0xADB46C85, 0x480369C7);
		public static FolderPath DocumentsLibrary => _Get(0x7B0DB17D, 0x9CD24A93, 0x973346CC, 0x89022E7C);
		public static FolderPath Downloads => _Get(0x374DE290, 0x123F4565, 0x916439C4, 0x925E467B);
		public static FolderPath Favorites => _Get(0x1777F761, 0x68AD4D8A, 0x87BD30B7, 0x59FA33DD);
		public static FolderPath Fonts => _Get(0xFD228CB7, 0xAE114AE3, 0x864C16F3, 0x910AB8FE);
		public static FolderPath GameTasks => _Get(0x054FAE61, 0x4DD84787, 0x80B60902, 0x20C4B700);
		public static FolderPath History => _Get(0xD9DC8A3B, 0xB784432E, 0xA7815A11, 0x30A75963);
		public static FolderPath ImplicitAppShortcuts => _Get(0xBCB5256F, 0x79F64CEE, 0xB725DC34, 0xE402FD46);
		public static FolderPath InternetCache => _Get(0x352481E8, 0x33BE4251, 0xBA856007, 0xCAEDCF9D);
		public static FolderPath Libraries => _Get(0x1B3EA5DC, 0xB5874786, 0xB4EFBD1D, 0xC332AEAE);
		public static FolderPath Links => _Get(0xbfb9d5e0, 0xc6a9404c, 0xb2b2ae6d, 0xb6af4968);
		public static FolderPath LocalAppData => _Get(0xF1B32785, 0x6FBA4FCF, 0x9D557B8E, 0x7F157091);
		public static FolderPath LocalAppDataLow => _Get(0xA520A1A4, 0x17804FF6, 0xBD181673, 0x43C5AF16);
		public static FolderPath LocalizedResourcesDir => _Get(0x2A00375E, 0x224C49DE, 0xB8D1440D, 0xF7EF3DDC);
		public static FolderPath Music => _Get(0x4BD8D571, 0x6D1948D3, 0xBE974222, 0x20080E43);
		public static FolderPath MusicLibrary => _Get(0x2112AB0A, 0xC86A4FFE, 0xA3680DE9, 0x6E47012E);
		public static FolderPath NetHood => _Get(0xC5ABBF53, 0xE17F4121, 0x89008662, 0x6FC2C973);
		public static FolderPath OriginalImages => _Get(0x2C36C0AA, 0x58124b87, 0xBFD04CD0, 0xDFB19B39);
		public static FolderPath PhotoAlbums => _Get(0x69D2CF90, 0xFC334FB7, 0x9A0CEBB0, 0xF0FCB43C);
		public static FolderPath PicturesLibrary => _Get(0xA990AE9F, 0xA03B4E80, 0x94BC9912, 0xD7504104);
		public static FolderPath Pictures => _Get(0x33E28130, 0x4E1E4676, 0x835A9839, 0x5C3BC3BB);
		public static FolderPath Playlists => _Get(0xDE92C1C7, 0x837F4F69, 0xA3BB86E6, 0x31204A23);
		public static FolderPath PrintHood => _Get(0x9274BD8D, 0xCFD141C3, 0xB35EB13F, 0x55A758F4);
		public static FolderPath Profile => _Get(0x5E6C858F, 0x0E224760, 0x9AFEEA33, 0x17B67173);
		public static FolderPath ProgramData => _Get(0x62AB5D82, 0xFDC14DC3, 0xA9DD070D, 0x1D495D97);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFiles => new(__ProgramFiles ??= _ProgramFiles);
		static string __ProgramFiles;
		static FolderPath _ProgramFiles => _Get(0x905e63b6, 0xc1bf494e, 0xb29c65b7, 0x32d3d21a);
		//broken static FolderPath ProgramFilesX64 => _Get(0x6D809377, 0x6AF0444b, 0x8957A377, 0x3F02200E);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesX86 => new(__ProgramFilesX86 ??= _ProgramFilesX86);
		static string __ProgramFilesX86;
		static FolderPath _ProgramFilesX86 => _Get(0x7C5A40EF, 0xA0FB4BFC, 0x874AC0F2, 0xE0B9FA8E);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommon => _Get(0xF7F1ED05, 0x9F6D47A2, 0xAAAE29D3, 0x17C6F066);
		//broken static FolderPath ProgramFilesCommonX64 => _Get(0x6365D5A7, 0x0F0D45E5, 0x87F60DA5, 0x6B6A4F7D);
		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommonX86 => _Get(0xDE974D24, 0xD9C64D3E, 0xBF91F445, 0x5120B917);
		public static FolderPath Programs => _Get(0xA77F5D77, 0x2E2B44C3, 0xA6A2ABA6, 0x01054A51);
		public static FolderPath Public => _Get(0xDFDF76A2, 0xC82A4D63, 0x906A5644, 0xAC457385);
		public static FolderPath PublicDesktop => _Get(0xC4AA340D, 0xF20F4863, 0xAFEFF87E, 0xF2E6BA25);
		public static FolderPath PublicDocuments => _Get(0xED4824AF, 0xDCE445A8, 0x81E2FC79, 0x65083634);
		public static FolderPath PublicDownloads => _Get(0x3D644C9B, 0x1FB84f30, 0x9B45F670, 0x235F79C0);
		public static FolderPath PublicGameTasks => _Get(0xDEBF2536, 0xE1A84c59, 0xB6A24145, 0x86476AEA);
		public static FolderPath PublicLibraries => _Get(0x48DAF80B, 0xE6CF4F4E, 0xB8000E69, 0xD84EE384);
		public static FolderPath PublicMusic => _Get(0x3214FAB5, 0x97574298, 0xBB6192A9, 0xDEAA44FF);
		public static FolderPath PublicPictures => _Get(0xB6EBFB86, 0x6907413C, 0x9AF74FC2, 0xABF07CC5);
		public static FolderPath PublicRingtones => _Get(0xE555AB60, 0x153B4D17, 0x9F04A5FE, 0x99FC15EC);
		public static FolderPath PublicUserTiles_Win8 => _Get(0x0482af6c, 0x08f14c34, 0x8c90e17e, 0xc98b1e17);
		public static FolderPath PublicVideos => _Get(0x2400183A, 0x618549FB, 0xA2D84A39, 0x2A602BA3);
		public static FolderPath QuickLaunch => _Get(0x52a4f021, 0x7b7548a9, 0x9f6b4b87, 0xa210bc8f);
		public static FolderPath Recent => _Get(0xAE50C081, 0xEBD2438A, 0x86558A09, 0x2E34987A);
		public static FolderPath RecordedTV => _Get(0x1A6FDBA2, 0xF42D4358, 0xA798B74D, 0x745926C5);
		public static FolderPath ResourceDir => _Get(0x8AD10C31, 0x2ADB4296, 0xA8F7E470, 0x1232C972);
		public static FolderPath Ringtones => _Get(0xC870044B, 0xF49E4126, 0xA9C3B52A, 0x1FF411E8);
		public static FolderPath RoamingAppData => _Get(0x3EB685DB, 0x65F94CF6, 0xA03AE3EF, 0x65729F3D);
		public static FolderPath RoamedTileImages_Win8 => _Get(0xAAA8D5A5, 0xF1D64259, 0xBAA878E7, 0xEF60835E);
		public static FolderPath RoamingTiles_Win8 => _Get(0x00BCFC5A, 0xED944e48, 0x96A13F62, 0x17F21990);
		public static FolderPath SampleMusic => _Get(0xB250C668, 0xF57D4EE1, 0xA63C290E, 0xE7D1AA1F);
		public static FolderPath SamplePictures => _Get(0xC4900540, 0x23794C75, 0x844B64E6, 0xFAF8716B);
		public static FolderPath SamplePlaylists => _Get(0x15CA69B3, 0x30EE49C1, 0xACE16B5E, 0xC372AFB5);
		public static FolderPath SampleVideos => _Get(0x859EAD94, 0x2E8548AD, 0xA71A0969, 0xCB56A6CD);
		public static FolderPath SavedGames => _Get(0x4C5C32FF, 0xBB9D43b0, 0xB5B42D72, 0xE54EAAA4);
		public static FolderPath SavedPictures => _Get(0x3B193882, 0xD3AD4eab, 0x965A6982, 0x9D1FB59F);
		public static FolderPath SavedPicturesLibrary => _Get(0xE25B5812, 0xBE884bd9, 0x94B02923, 0x3477B6C3);
		public static FolderPath SavedSearches => _Get(0x7d1d3a04, 0xdebb4115, 0x95cf2f29, 0xda2920da);
		public static FolderPath Screenshots_Win8 => _Get(0xb7bede81, 0xdf944682, 0xa7d857a5, 0x2620b86f);
		public static FolderPath SearchHistory_Win81 => _Get(0x0D4C3DB6, 0x03A3462F, 0xA0E60892, 0x4C41B5D4);
		public static FolderPath SearchTemplates_Win81 => _Get(0x7E636BFE, 0xDFA94D5E, 0xB456D7B3, 0x9851D8A9);
		public static FolderPath SendTo => _Get(0x8983036C, 0x27C0404B, 0x8F08102D, 0x10DCFD74);
		public static FolderPath SidebarDefaultParts => _Get(0x7B396E54, 0x9EC54300, 0xBE0A2482, 0xEBAE1A26);
		public static FolderPath SidebarParts => _Get(0xA75D362E, 0x50FC4fb7, 0xAC2CA8BE, 0xAA314493);
		public static FolderPath SkyDrive_Win81 => _Get(0xA52BBA46, 0xE9E1435f, 0xB3D928DA, 0xA648C0F6);
		public static FolderPath SkyDriveCameraRoll_Win81 => _Get(0x767E6811, 0x49CB4273, 0x87C220F3, 0x55E1085B);
		public static FolderPath SkyDriveDocuments_Win81 => _Get(0x24D89E24, 0x2F194534, 0x9DDE6A66, 0x71FBB8FE);
		public static FolderPath SkyDrivePictures_Win81 => _Get(0x339719B5, 0x8C474894, 0x94C2D8F7, 0x7ADD44A6);
		public static FolderPath StartMenu => _Get(0x625B53C3, 0xAB484EC1, 0xBA1FA1EF, 0x4146FC19);
		public static FolderPath Startup => _Get(0xB97D20BB, 0xF46A4C97, 0xBA105E36, 0x08430854);
		/// <summary>More info in class help.</summary>
		public static FolderPath System => new(__System ??= _System);
		static string __System;
		static FolderPath _System => _Get(0x1AC14E77, 0x02E74E5D, 0xB7442EB1, 0xAE5198B7);
		/// <summary>More info in class help.</summary>
		public static FolderPath SystemX86 => _Get(0xD65231B0, 0xB2F14857, 0xA4CEA8E7, 0xC6EA7D27);
		public static FolderPath Templates => _Get(0xA63293E8, 0x664E48DB, 0xA079DF75, 0x9E0509F7);
		public static FolderPath TreeProperties => _Get(0x9E3995AB, 0x1F9C4F13, 0xB82748B2, 0x4B6C7174);
		public static FolderPath UserProfiles => _Get(0x0762D272, 0xC50A4BB0, 0xA382697D, 0xCD729B80);
		public static FolderPath UserProgramFiles => _Get(0x5CD7AEE2, 0x22194A67, 0xB85D6C9C, 0xE15660CB);
		public static FolderPath UserProgramFilesCommon => _Get(0xBCBD3057, 0xCA5C4622, 0xB42DBC56, 0xDB0AE516);
		public static FolderPath Videos => _Get(0x18989B1D, 0x99B5455B, 0x841CAB7C, 0x74E4DDFC);
		public static FolderPath VideosLibrary => _Get(0x491E922F, 0x56434AF4, 0xA7EB4E7A, 0x138D8174);
		public static FolderPath Windows => new(__Windows ??= _Windows);
		static string __Windows;
		static FolderPath _Windows => _Get(0xF38BF404, 0x1D4342F2, 0x930567DE, 0x0B28FC23);

		/// <summary>
		/// Gets ITEMIDLIST of known/special virtual folders (eg Control Panel), as string like ":: 12345678..." or as <see cref="Pidl"/>.
		/// Functions with suffix "Pidl" gets
		/// </summary>
		public static class shell {
			public static FolderPath AddNewPrograms => _GetV(0xde61d971, 0x5ebc4f02, 0xa3a96c82, 0x895e5c04);
			public static FolderPath Apps_Win8 => _GetV(0x1e87508d, 0x89c242f0, 0x8a7e645a, 0x0f50ca58);
			public static FolderPath AppUpdates => _GetV(0xa305ce99, 0xf527492b, 0x8b1a7e76, 0xfa98d6e4);
			public static FolderPath ChangeRemovePrograms => _GetV(0xdf7266ac, 0x92744867, 0x8d553bd6, 0x61de872d);
			public static FolderPath Computer => _GetV(0x0AC0837C, 0xBBF8452A, 0x850D79D0, 0x8E667CA7);
			public static FolderPath Conflict => _GetV(0x4bfefb45, 0x347d4006, 0xa5beac0c, 0xb0567192);
			public static FolderPath Connections => _GetV(0x6F0CD92B, 0x2E9745D1, 0x88FFB0D1, 0x86B8DEDD);
			public static FolderPath ControlPanel => _GetV(0x82A74AEB, 0xAEB4465C, 0xA014D097, 0xEE346D63);
			public static FolderPath Games => _GetV(0xCAC52C1A, 0xB53D4edc, 0x92D76B2E, 0x8AC19434);
			public static FolderPath HomeGroup => _GetV(0x52528A6B, 0xB9E34ADD, 0xB60D588C, 0x2DBA842D);
			public static FolderPath HomeGroupCurrentUser_Win8 => _GetV(0x9B74B6A3, 0x0DFD4f11, 0x9E785F78, 0x00F2E772);
			public static FolderPath Internet => _GetV(0x4D9F7874, 0x4E0C4904, 0x967B40B0, 0xD20C3E4B);
			public static FolderPath Network => _GetV(0xD20BEEC4, 0x5CA84905, 0xAE3BBF25, 0x1EA09B53);
			public static FolderPath Printers => _GetV(0x76FC4E2D, 0xD6AD4519, 0xA66337BD, 0x56068185);
			public static FolderPath RecycleBin => _GetV(0xB7534046, 0x3ECB4C18, 0xBE4E64CD, 0x4CB7D6AC);
			public static FolderPath SEARCH_CSC => _GetV(0xee32e446, 0x31ca4aba, 0x814fa5eb, 0xd2fd6d5e);
			public static FolderPath SearchHome => _GetV(0x190337d1, 0xb8ca4121, 0xa6396d47, 0x2d16972a);
			public static FolderPath SEARCH_MAPI => _GetV(0x98ec0e18, 0x20984d44, 0x86446697, 0x9315a281);
			public static FolderPath SyncManager => _GetV(0x43668BF8, 0xC14E49B2, 0x97C97477, 0x84D784B7);
			public static FolderPath SyncResults => _GetV(0x289a9a43, 0xbe444057, 0xa41b587a, 0x76d7e7f9);
			public static FolderPath SyncSetup => _GetV(0x0F214138, 0xB1D34a90, 0xBBA927CB, 0xC0C5389A);
			public static FolderPath UsersFiles => _GetV(0xf3ce0f7c, 0x49014acc, 0x8648d5d4, 0x4b04ef8f);
			public static FolderPath UsersLibraries => _GetV(0xA302545D, 0xDEFF464b, 0xABE861C8, 0x648D939B);

			public static Pidl pidlAddNewPrograms => _GetVI(0xde61d971, 0x5ebc4f02, 0xa3a96c82, 0x895e5c04);
			public static Pidl pidlApps_Win8 => _GetVI(0x1e87508d, 0x89c242f0, 0x8a7e645a, 0x0f50ca58);
			public static Pidl pidlAppUpdates => _GetVI(0xa305ce99, 0xf527492b, 0x8b1a7e76, 0xfa98d6e4);
			public static Pidl pidlChangeRemovePrograms => _GetVI(0xdf7266ac, 0x92744867, 0x8d553bd6, 0x61de872d);
			public static Pidl pidlComputer => _GetVI(0x0AC0837C, 0xBBF8452A, 0x850D79D0, 0x8E667CA7);
			public static Pidl pidlConflict => _GetVI(0x4bfefb45, 0x347d4006, 0xa5beac0c, 0xb0567192);
			public static Pidl pidlConnections => _GetVI(0x6F0CD92B, 0x2E9745D1, 0x88FFB0D1, 0x86B8DEDD);
			public static Pidl pidlControlPanel => _GetVI(0x82A74AEB, 0xAEB4465C, 0xA014D097, 0xEE346D63);
			public static Pidl pidlGames => _GetVI(0xCAC52C1A, 0xB53D4edc, 0x92D76B2E, 0x8AC19434);
			public static Pidl pidlHomeGroup => _GetVI(0x52528A6B, 0xB9E34ADD, 0xB60D588C, 0x2DBA842D);
			public static Pidl pidlHomeGroupCurrentUser_Win8 => _GetVI(0x9B74B6A3, 0x0DFD4f11, 0x9E785F78, 0x00F2E772);
			public static Pidl pidlInternet => _GetVI(0x4D9F7874, 0x4E0C4904, 0x967B40B0, 0xD20C3E4B);
			public static Pidl pidlNetwork => _GetVI(0xD20BEEC4, 0x5CA84905, 0xAE3BBF25, 0x1EA09B53);
			public static Pidl pidlPrinters => _GetVI(0x76FC4E2D, 0xD6AD4519, 0xA66337BD, 0x56068185);
			public static Pidl pidlRecycleBin => _GetVI(0xB7534046, 0x3ECB4C18, 0xBE4E64CD, 0x4CB7D6AC);
			public static Pidl pidlSEARCH_CSC => _GetVI(0xee32e446, 0x31ca4aba, 0x814fa5eb, 0xd2fd6d5e);
			public static Pidl pidlSearchHome => _GetVI(0x190337d1, 0xb8ca4121, 0xa6396d47, 0x2d16972a);
			public static Pidl pidlSEARCH_MAPI => _GetVI(0x98ec0e18, 0x20984d44, 0x86446697, 0x9315a281);
			public static Pidl pidlSyncManager => _GetVI(0x43668BF8, 0xC14E49B2, 0x97C97477, 0x84D784B7);
			public static Pidl pidlSyncResults => _GetVI(0x289a9a43, 0xbe444057, 0xa41b587a, 0x76d7e7f9);
			public static Pidl pidlSyncSetup => _GetVI(0x0F214138, 0xB1D34a90, 0xBBA927CB, 0xC0C5389A);
			public static Pidl pidlUsersFiles => _GetVI(0xf3ce0f7c, 0x49014acc, 0x8648d5d4, 0x4b04ef8f);
			public static Pidl pidlUsersLibraries => _GetVI(0xA302545D, 0xDEFF464b, 0xABE861C8, 0x648D939B);
		}

		#endregion

		#region other paths

		/// <summary>
		/// Temp folder (temporary files) of this user account.
		/// </summary>
		public static FolderPath Temp => new(__temp ??= Path.GetTempPath().TrimEnd('\\'));
		static string __temp;

		/// <summary>
		/// Folder containing assemblies of this app.
		/// </summary>
		/// <remarks>
		/// Uses <see cref="AppContext.BaseDirectory"/>.
		/// </remarks>
		/// <seealso cref="process.thisExePath"/>
		public static FolderPath ThisApp => new(__thisApp ??= ThisAppBS.TrimEnd('\\'));
		static string __thisApp;

		/// <summary>
		/// <see cref="ThisApp"/> with appended backslash character.
		/// Returns string, not <see cref="FolderPath"/> like other functions.
		/// </summary>
		/// <remarks>
		/// Uses <see cref="AppContext.BaseDirectory"/>.
		/// </remarks>
		public static string ThisAppBS => __thisAppBS ??= AppContext.BaseDirectory; //info: AppDomain.CurrentDomain.BaseDirectory calls it
		static string __thisAppBS;
		//Can change: AppDomain.CurrentDomain.SetData("APP_CONTEXT_BASE_DIRECTORY", "C:\\");

		//FUTURE: support portable apps.
		//	Eg if ThisAppBS is like "*\PortableApps\*\App\*", let ThisAppX properties by default return "*\PortableApps\*\Data\...".
		//	But maybe it does not make much sense, because many (most?) users also would have to install .NET5+.
		//	The app can use dotnet dlls in app's folder without dotnet installed. Our AppHost supports it.
		//	Or could install dotnet in the removable drive to be shared by portable .NET apps. And let our AppHost support it. Maybe it already supports the environment variable, don't remember.

		const string c_defaultAppSubDir = "Au";
		//static string c_defaultAppSubDir = @"Au\" + script.name; //no. In a script app could create many folders. All these properties can be set.
		//note: don't use Application.ProductName etc. It loads Forms, exception if dynamic assembly, etc.

		#region set auto/once

		[ThreadStatic] static bool _noGetAutoCreate;

		static string _SetAuto(ref string propVar, string value, bool create) {
			lock (_lock) {
				if (propVar == null) {
					if (create && !_noGetAutoCreate) filesystem.createDirectory(value);
					propVar = value;
				}
			}
			return propVar;
		}
		static readonly object _lock = new object();

		static void _SetOnce(ref string propVar, string value, bool create, [CallerMemberName] string m_ = null) {
			lock (_lock) {
				if (propVar != null) {
#if DEBUG
					if (!Debugger.IsAttached) //debugger may get the property. Then _SetAuto sets default value.
#endif
						throw new InvalidOperationException("folders." + m_ + " is already set.");
				}
				if (create) filesystem.createDirectory(value);
				propVar = value;
			}
		}

		#endregion

		/// <summary>
		/// Gets or sets path of folder "temporary files of this application".
		/// Default is <c>folders.Temp + "Au"</c>.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
		/// <remarks>
		/// The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
		/// Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
		/// </remarks>
		public static FolderPath ThisAppTemp {
			get => new(__thisAppTemp ?? _SetAuto(ref __thisAppTemp, Temp + c_defaultAppSubDir, create: true));
			set => _SetOnce(ref __thisAppTemp, value, create: true);
		}
		static string __thisAppTemp;

		/// <summary>
		/// Gets or sets path of folder "user document files of this application".
		/// Default is <c>folders.Documents + "Au"</c>.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
		/// <remarks>
		/// The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
		/// Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
		/// </remarks>
		public static FolderPath ThisAppDocuments {
			get => new(__thisAppDocuments ?? _SetAuto(ref __thisAppDocuments, Documents + c_defaultAppSubDir, create: true));
			set => _SetOnce(ref __thisAppDocuments, value, create: true);
		}
		static string __thisAppDocuments;

		/// <summary>
		/// Gets or sets path of folder "private files of this application of this user account".
		/// Default is <c>folders.RoamingAppData + "Au"</c>.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
		/// <remarks>
		/// The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
		/// Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
		/// </remarks>
		public static FolderPath ThisAppData {
			get => new(__thisAppData ?? _SetAuto(ref __thisAppData, RoamingAppData + c_defaultAppSubDir, create: true));
			set => _SetOnce(ref __thisAppData, value, create: true);
		}
		static string __thisAppData;

		/// <summary>
		/// Gets or sets path of folder "local (non-roaming) private files of this application of this user account".
		/// Default is <c>folders.LocalAppData + "Au"</c>.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
		/// <remarks>
		/// The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
		/// Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
		/// </remarks>
		public static FolderPath ThisAppDataLocal {
			get => new(__thisAppDataLocal ?? _SetAuto(ref __thisAppDataLocal, LocalAppData + c_defaultAppSubDir, create: true));
			set => _SetOnce(ref __thisAppDataLocal, value, create: true);
		}
		static string __thisAppDataLocal;

		/// <summary>
		/// Gets or sets path of folder "common (all users) private files of this application".
		/// Default is <c>folders.ProgramData + "Au"</c>.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
		/// <remarks>
		/// The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
		/// This function does not auto-create the folder; usually it is created when installing the application.
		/// Note: the ProgramData folder has special security permissions. Programs running not as administrator usually cannot write there, unless your installer changed folder security permissions.
		/// </remarks>
		public static FolderPath ThisAppDataCommon {
			get => new(__thisAppDataCommon ?? _SetAuto(ref __thisAppDataCommon, ProgramData + c_defaultAppSubDir, create: false));
			set => _SetOnce(ref __thisAppDataCommon, value, create: false);
		}
		static string __thisAppDataCommon;

		/// <summary>
		/// Gets or sets path of folder "images (icons etc) of this application".
		/// Default is <c>ThisAppBS + "Images"</c>.
		/// </summary>
		/// <exception cref="InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
		/// <remarks>
		/// Used by functions of these classes: <b>icon</b>, <b>popupMenu</b>, <b>toolbar</b>, <b>uiimage</b>, possibly some other.
		/// This function does not auto-create the folder; usually it is created when installing the application.
		/// </remarks>
		public static FolderPath ThisAppImages {
			get => new(__thisAppImages ?? _SetAuto(ref __thisAppImages, ThisAppBS + "Images", create: false));
			set => _SetOnce(ref __thisAppImages, value, create: false);
		}
		static string __thisAppImages;

		/// <summary>
		/// Gets the root directory of this application, like @"C:\" or @"\\network\folder\".
		/// </summary>
		public static string ThisAppDriveBS => __thisAppDrive ??= Path.GetPathRoot(ThisAppBS);
		static string __thisAppDrive;
		//public static FolderPath ThisAppDrive => new(__thisAppDrive ??= Path.GetPathRoot(ThisAppBS));

		/// <summary>
		/// Gets folder of current workspace.
		/// Available in editor process. In script process available if role is miniProgram or editorExtension. Elsewhere null.
		/// </summary>
		public static FolderPath Workspace {
			get => __workspace;
			internal set { __workspace = value; WorkspaceDriveBS = Path.GetPathRoot(value); }
		}
		static FolderPath __workspace;

		/// <summary>
		/// Gets the root directory of <see cref="Workspace"/>, like @"C:\" or @"\\network\folder\".
		/// </summary>
		public static string WorkspaceDriveBS { get; private set; }

		/// <summary>
		/// Gets drive type (fixed, removable, network, etc) of <see cref="WorkspaceDriveBS"/>.
		/// </summary>
		public static DriveType workspaceDriveType => s_driveTypeWS ??= _GetDriveType(WorkspaceDriveBS);
		static DriveType? s_driveTypeWS;

		/// <summary>
		/// Gets drive type (fixed, removable, network, etc) of <see cref="ThisAppDriveBS"/>.
		/// </summary>
		public static DriveType thisAppDriveType => s_driveTypeApp ??= _GetDriveType(ThisAppDriveBS);
		static DriveType? s_driveTypeApp;

		static DriveType _GetDriveType(string path) {
			if (path.Starts(@"\\")) { //DriveInfo does not support it, exception
				if (!path.Starts(@"\\?\")) return DriveType.Network;
				path = path[4..];
			}
			return new DriveInfo(path).DriveType;
		}

		/// <summary>
		/// Gets folder path of caller's source code file.
		/// </summary>
		/// <param name="f_">[](xref:caller_info)</param>
		public static FolderPath sourceCode([CallerFilePath] string f_ = null) => new(pathname.getDirectory(f_));

		/// <summary>
		/// Gets non-redirected path of the System32 folder.
		/// </summary>
		/// <remarks>
		/// If this process is 32-bit and OS is 64-bit, when it uses the <see cref="System"/> folder path (<c>@"C:\WINDOWS\system32"</c>), the OS in most cases redirects it to <c>@"C:\Windows\SysWOW64"</c>, which contains 32-bit versions of program files. Use SystemX64 when you want to avoid the redirection and access the true System32 folder which on 64-bit OS contains 64-bit program files.
		/// More info in class help.
		/// </remarks>
		/// <seealso cref="FileSystemRedirection"/>
		/// <seealso cref="osVersion.is32BitProcessAnd64BitOS"/>
		public static FolderPath SystemX64 => new(__SystemX64 ??= osVersion.is32BitProcessAnd64BitOS ? Windows + "Sysnative" : System);
		static string __SystemX64;

		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesX64 => new(__ProgramFilesX64 ??= osVersion.is32BitProcessAnd64BitOS ? envVar("ProgramW6432") : ProgramFiles);
		static string __ProgramFilesX64;

		/// <summary>More info in class help.</summary>
		public static FolderPath ProgramFilesCommonX64 => new(__ProgramFilesCommonX64 ??= osVersion.is32BitProcessAnd64BitOS ? envVar("CommonProgramW6432") : ProgramFilesCommon);
		static string __ProgramFilesCommonX64;
		//The normal retrieving method for these folders is broken. Fails even on 64-bit OS if process is 32-bit.

		/// <summary>
		/// Gets .NET runtime folder, like <c>C:\Program Files\dotnet\shared\Microsoft.NETCore.App\3.1.0</c>.
		/// </summary>
		public static FolderPath NetRuntime => new(__netRuntime ??= NetRuntimeBS.TrimEnd('\\'));
		static string __netRuntime;

		/// <summary>
		/// Gets .NET runtime folder with <c>'\\'</c> at the end, like <c>C:\Program Files\dotnet\shared\Microsoft.NETCore.App\3.1.0\</c>.
		/// </summary>
		public static string NetRuntimeBS => __netRuntimeBS ??= RuntimeEnvironment.GetRuntimeDirectory();
		static string __netRuntimeBS;

		/// <summary>
		/// Gets .NET runtime desktop folder, like <c>C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\3.1.0</c>.
		/// </summary>
		public static FolderPath NetRuntimeDesktop => new(__netRuntimeDesktop ??= NetRuntimeDesktopBS.TrimEnd('\\'));
		static string __netRuntimeDesktop;

		/// <summary>
		/// Gets .NET runtime desktop folder with <c>'\\'</c> at the end, like <c>C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\3.1.0\</c>.
		/// </summary>
		public static string NetRuntimeDesktopBS => __netRuntimeDesktopBS ??= NetRuntimeBS.RxReplace(@"(?i)\\Microsoft\.\KNETCore(?=\.App\\[^\\]+\\$)", "WindowsDesktop", 1);
		static string __netRuntimeDesktopBS;

		/// <summary>
		/// Gets CD/DVD drive path, like <c>@"D:\"</c>.
		/// Returns null if unavailable.
		/// </summary>
		public static FolderPath CdDvdDrive {
			get {
				foreach (var di in DriveInfo.GetDrives()) {
					if (di.DriveType == DriveType.CDRom) return new(di.Name);
				}
				return default;
			}
		}

		/// <summary>Calls <see cref="removableDrive(int)"/>(0).</summary>
		public static FolderPath RemovableDrive0 => removableDrive(0);
		/// <summary>Calls <see cref="removableDrive(int)"/>(1).</summary>
		public static FolderPath RemovableDrive1 => removableDrive(1);
		/// <summary>Calls <see cref="removableDrive(int)"/>(2).</summary>
		public static FolderPath RemovableDrive2 => removableDrive(2);
		/// <summary>Calls <see cref="removableDrive(int)"/>(3).</summary>
		public static FolderPath RemovableDrive3 => removableDrive(3);

		/// <summary>
		/// Gets removable/external/USB drive path, like <c>@"F:\"</c>.
		/// Returns null if unavailable.
		/// </summary>
		/// <param name="driveIndex">0-based removable drive index.</param>
		/// <remarks>Uses <see cref="DriveInfo.GetDrives"/> and counts only drives of type DriveType.Removable.</remarks>
		public static FolderPath removableDrive(int driveIndex = 0) {
			foreach (DriveInfo di in DriveInfo.GetDrives()) {
				if (di.DriveType == DriveType.Removable && driveIndex-- == 0) return new(di.Name);
			}
			return default;
		}

		/// <summary>
		/// Gets removable/external/USB drive name (like <c>@"F:\"</c>) by its volume label.
		/// Returns null if unavailable.
		/// </summary>
		/// <param name="volumeLabel">Volume label. You can see it in drive Properties dialog; it is not the drive name that is displayed in File Explorer.</param>
		public static FolderPath removableDrive(string volumeLabel) {
			foreach (DriveInfo di in DriveInfo.GetDrives()) {
				if (di.DriveType == DriveType.Removable) {
					string v = null; try { v = di.VolumeLabel; } catch { continue; }
					if (!v.Eqi(volumeLabel)) continue;
					return new(di.Name);
				}
			}
			return default;
		}

		/// <summary>
		/// Gets the value of an environment variable in current process.
		/// Returns null if variable not found.
		/// </summary>
		/// <seealso cref="Environment.GetEnvironmentVariable"/>
		/// <seealso cref="Environment.SetEnvironmentVariable"/>
		/// <seealso cref="pathname.expand"/>
		public static FolderPath envVar(string envVar) => new(Api.GetEnvironmentVariable(envVar));

		#endregion

		#region private functions

		//Gets non-virtual known folder path from KNOWNFOLDERID specified with 4 uints.
		static FolderPath _Get(uint a, uint b, uint c, uint d) {
			//info: we don't use caching. It seems the API use caching internally.
			//tested: with IKnownFolder much slower.

			var guid = new _Api.KNOWNFOLDERID(a, b, c, d);
			if (0 != _Api.SHGetKnownFolderPath(guid, _Api.KNOWN_FOLDER_FLAG.KF_FLAG_DONT_VERIFY, default, out string R)) R = null;
			return new(R);
		}

		//Gets virtual known folder ITEMIDLIST from KNOWNFOLDERID specified with 4 uints.
		static Pidl _GetVI(uint a, uint b, uint c, uint d) {
			var guid = new _Api.KNOWNFOLDERID(a, b, c, d);
			if (0 != _Api.SHGetKnownFolderIDList(guid, _Api.KNOWN_FOLDER_FLAG.KF_FLAG_DONT_VERIFY, default, out IntPtr pidl)) return null;
			return new Pidl(pidl);
		}

		//Gets virtual known folder ITEMIDLIST from KNOWNFOLDERID specified with 4 uints.
		//Returns string ":: ITEMIDLIST".
		static FolderPath _GetV(uint a, uint b, uint c, uint d) {
			using var pidl = _GetVI(a, b, c, d); //never mind: could do it without creating new Pidl
			return new(pidl?.ToHexString());
		}

		#endregion

		#region API

		static class _Api {
			//GUID that can be inited with 4 uints.
			internal struct KNOWNFOLDERID {
				uint _a; ushort _b, _c; byte _d, _e, _f, _g, _h, _i, _j, _k;

				public KNOWNFOLDERID(uint a, uint b, uint c, uint d) {
					_a = a;
					_b = (ushort)(b >> 16);
					_c = (ushort)b;
					_d = (byte)(c >> 24);
					_e = (byte)(c >> 16);
					_f = (byte)(c >> 8);
					_g = (byte)c;
					_h = (byte)(d >> 24);
					_i = (byte)(d >> 16);
					_j = (byte)(d >> 8);
					_k = (byte)d;
				}
			}

			[DllImport("shell32.dll")]
			internal static extern int SHGetKnownFolderPath(in KNOWNFOLDERID rfid, KNOWN_FOLDER_FLAG dwFlags, IntPtr hToken, out string ppszPath);

			[DllImport("shell32.dll")]
			internal static extern int SHGetKnownFolderIDList(in KNOWNFOLDERID rfid, KNOWN_FOLDER_FLAG dwFlags, IntPtr hToken, out IntPtr ppidl);

			[Flags]
			internal enum KNOWN_FOLDER_FLAG : uint {
				KF_FLAG_SIMPLE_IDLIST = 0x00000100,
				KF_FLAG_NOT_PARENT_RELATIVE = 0x00000200,
				KF_FLAG_DEFAULT_PATH = 0x00000400,
				KF_FLAG_INIT = 0x00000800,
				KF_FLAG_NO_ALIAS = 0x00001000,
				KF_FLAG_DONT_UNEXPAND = 0x00002000,
				KF_FLAG_DONT_VERIFY = 0x00004000,
				KF_FLAG_CREATE = 0x00008000,
				KF_FLAG_NO_APPCONTAINER_REDIRECTION = 0x00010000,
				KF_FLAG_ALIAS_ONLY = 0x80000000
			}

			internal enum KF_DEFINITION_FLAGS {
				KFDF_LOCAL_REDIRECT_ONLY = 0x2,
				KFDF_ROAMABLE = 0x4,
				KFDF_PRECREATE = 0x8,
				KFDF_STREAM = 0x10,
				KFDF_PUBLISHEXPANDEDPATH = 0x20
			}

#pragma warning disable CS0649 //field never assigned
			internal struct KNOWNFOLDER_DEFINITION {
				public KF_CATEGORY category;
				public string pszName;
				public string pszDescription;
				public Guid fidParent;
				public string pszRelativePath;
				public string pszParsingName;
				public string pszToolTip;
				public string pszLocalizedName;
				public string pszIcon;
				public string pszSecurity;
				public uint dwAttributes;
				public KF_DEFINITION_FLAGS kfdFlags;
				public Guid ftidType;
			}
#pragma warning restore CS0649 //field never assigned

			internal enum FFFP_MODE {
				FFFP_EXACTMATCH,
				FFFP_NEARESTPARENTMATCH
			}

			[ComImport, Guid("8BE2D872-86AA-4d47-B776-32CCA40C7018"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
			internal unsafe interface IKnownFolderManager {
				[PreserveSig] int FolderIdFromCsidl(int nCsidl, out Guid pfid);
				[PreserveSig] int FolderIdToCsidl(in Guid rfid, out int pnCsidl);
				[PreserveSig] int GetFolderIds(out Guid* ppKFId, out int pCount);
				[PreserveSig] int GetFolder(in Guid rfid, out IKnownFolder ppkf);
				[PreserveSig] int GetFolderByName([In, MarshalAs(UnmanagedType.LPWStr)] string pszCanonicalName, out IKnownFolder ppkf);
				//[PreserveSig] int RegisterFolder(in Guid rfid, in KNOWNFOLDER_DEFINITION pKFD);
				//[PreserveSig] int UnregisterFolder(in Guid rfid);
				//[PreserveSig] int FindFolderFromPath([In, MarshalAs(UnmanagedType.LPWStr)] string pszPath, FFFP_MODE mode, out IKnownFolder ppkf);
				//[PreserveSig] int FindFolderFromIDList(IntPtr pidl, out IKnownFolder ppkf);
				//[PreserveSig] int Redirect(in Guid rfid, wnd hwnd, uint flags, [In, MarshalAs(UnmanagedType.LPWStr)] string pszTargetPath, uint cFolders, [MarshalAs(UnmanagedType.LPArray)] [In] Guid[] pExclusion, char** ppszError);
			}

			[ComImport, Guid("4df0c730-df9d-4ae3-9153-aa6b82e9795a"), ClassInterface(ClassInterfaceType.None)]
			internal class KnownFolderManager { }

			internal enum KF_CATEGORY {
				KF_CATEGORY_VIRTUAL = 1,
				KF_CATEGORY_FIXED = 2,
				KF_CATEGORY_COMMON = 3,
				KF_CATEGORY_PERUSER = 4
			}

			[ComImport, Guid("3AA7AF7E-9B36-420c-A8E3-F77D4674A488"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
			internal unsafe interface IKnownFolder {
				[PreserveSig] int GetId(out Guid pkfid);
				[PreserveSig] int GetCategory(out KF_CATEGORY pCategory);
				[PreserveSig] int GetShellItem(uint dwFlags, in Guid riid, void** ppv);
				[PreserveSig] int GetPath(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] out string ppszPath); //tested: .NET correctly calls CoTaskMemFree
				[PreserveSig] int SetPath(uint dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string pszPath);
				[PreserveSig] int GetIDList(uint dwFlags, out IntPtr ppidl);
				[PreserveSig] int GetFolderType(out Guid pftid);
				[PreserveSig] int GetRedirectionCapabilities(out uint pCapabilities);
				[PreserveSig] int GetFolderDefinition(out KNOWNFOLDER_DEFINITION pKFD);
			}
		}

		#endregion

		#region public methods

		/// <summary>
		/// Gets canonical names and paths of all known folders, including custom known folders registerd by applications.
		/// These names can be used with <see cref="getFolder"/>.
		/// </summary>
		public static unsafe Dictionary<string, string> getKnownFolders() {
			var dict = new Dictionary<string, string>();

			var man = new _Api.KnownFolderManager() as _Api.IKnownFolderManager;
			Guid* gp = null;
			try {
				if (man.GetFolderIds(out gp, out int nIds) != 0) return null;
				for (int i = 0; i < nIds; i++) {
					_Api.IKnownFolder kf = null;
					try {
						if (man.GetFolder(gp[i], out kf) != 0) continue;
						if (kf.GetFolderDefinition(out var fd) != 0) continue;
						string path = null;
						if (fd.category == _Api.KF_CATEGORY.KF_CATEGORY_VIRTUAL) {
							path = "<virtual>";
						} else {
							if (kf.GetPath(0, out path) != 0) path = "<unavailable>";
						}
						dict.Add(fd.pszName, path);
						//tested: .NET correctly frees struct strings. Don't need FreeKnownFolderDefinitionFields, which is an inline function that calls CoTaskMemFree.
					}
					catch { }
					finally { Api.ReleaseComObject(kf); }
				}
			}
			catch {
				dict = null;
			}
			finally {
				Marshal.FreeCoTaskMem((IntPtr)gp);
				Api.ReleaseComObject(man);
			}
			return dict;
		}

		/// <summary>
		/// Gets path of a known folder by its name as string.
		/// Returns null if unavailable.
		/// </summary>
		/// <param name="folderName">
		/// Can be:
		/// - name of a property of this class, like <c>"Documents"</c>, <c>"Temp"</c>, <c>"ThisApp"</c>. The property must return <b>FolderPath</b>.
		/// - name of a property of the nested class <see cref="shell"/>, like <c>"shell.ControlPanel"</c>. Gets <c>":: ITEMIDLIST"</c>.
		/// - known folder canonical name. See <see cref="getKnownFolders"/>. If has prefix <c>"shell."</c>, gets <c>":: ITEMIDLIST"</c>. Much slower, but allows to get paths of folders registered by applications.
		/// </param>
		/// <seealso cref="pathname.expand"/>
		public static FolderPath getFolder(string folderName) {
			if (folderName.NE()) return default;
			bool isVirtual = folderName.Starts("shell.");
			if (isVirtual) folderName = folderName[6..];

			//properties of this class
			Type ty = isVirtual ? typeof(shell) : typeof(folders);
			if (ty.GetProperty(folderName)?.GetValue(null) is FolderPath fp) return fp;
			//Using reflection is not the fastest way, but simplest, cannot make bugs, and don't need maintenance. Fast enough.

			//default and custom registered known folders by canonical name
			string R = null;
			_Api.IKnownFolderManager man = null; _Api.IKnownFolder kf = null;
			try {
				man = (_Api.IKnownFolderManager)new _Api.KnownFolderManager();
				if (man.GetFolderByName(folderName, out kf) != 0) return default;
				if (isVirtual) {
					if (0 != kf.GetIDList(0, out IntPtr pidl)) return default;
					R = Pidl.ToHexString(pidl);
					Marshal.FreeCoTaskMem(pidl);
				} else {
					if (0 != kf.GetPath(0, out R)) return default;
					R = pathname.expand(R);
				}
				//tested: works in MTA apartment too. And all props.
			}
			catch { }
			finally {
				Api.ReleaseComObject(kf);
				Api.ReleaseComObject(man);
			}

			return new(R);

			//speed:
			//	The get-property code is 2 times slower than calling properties directly.
			//	The IKnownFolderManager code is 90 times slower than the get-property code.
		}

		#endregion

		//DON'T: public static class VirtualNAME that returns parsing name, eg "::{CLSID}\...".
		//	Good: native/.NET shellexecute supports it.
		//	Bad: native/.NET shellexecute supports only some. Almost nothing works in a 32-bit process on 64-bit OS; then even cannot convert the string to ITEMIDLIST. Some parsing names have other formats and the API gets wrong parsing names.

		//DON'T: The + operator returns FolderPath. Then folders.Desktop + subfolder + file would return "desktop\subfolder\file". Probably not good.
		//CONSIDER: operator / instead of +. Then could do things like 'folders.x / "subfolder" / "file"' and 'f /= "append"'.

		/// <summary>
		/// If string starts with a known/special folder path, gets folder name + relative path and returns true.
		/// For example if string is "C:\Windows\System32\notepad.exe", gets "folders.System" and "notepad.exe".
		/// </summary>
		/// <param name="path">Any string. Can be null. Case-insensitive. Supports ":: ITEMIDLIST" (see <see cref="Pidl.ToHexString"/>).</param>
		/// <param name="folder">Receives special folder string like <c>"folders.System"</c>.</param>
		/// <param name="name">Receives filename or relative path in the folder.</param>
		/// <remarks>
		/// Quite slow first time in process, eg 50 ms, because gets all folder paths. Later uses cached paths.
		/// </remarks>
		/// <seealso cref="pathname.expand"/>
		public static bool unexpandPath(string path, out string folder, out string name) {
			var p = path; folder = name = null;
			if (!p.NE()) {
				p = p.Lower();
				if (p.Starts(":: ")) {
					foreach (var v in _upv.Value) {
						int n = v.path.Length;
						if (p.Starts(v.path)) {
							folder = "folders.shell." + v.name;
							name = path[n..];
							return true;
						}
					}
				} else {
					p = p.Replace('/', '\\');
					foreach (var v in _up.Value) {
						int n = v.path.Length;
						if (p.Starts(v.path) && (p.Length == n || p[n] == '\\')) {
							folder = "folders." + v.name;
							if (p.Length > n) n++;
							name = path[n..];
							return true;
						}
					}
				}
			}
			return false;
		}

		/// <summary>
		/// If string starts with a known/special folder path, replaces that part with %folders.FolderName%. Else returns unchanged string.
		/// For example if string is "C:\Windows\System32\notepad.exe", returns "%folders.System%\notepad.exe".
		/// </summary>
		/// <inheritdoc cref="unexpandPath(string, out string, out string)"/>
		public static string unexpandPath(string path) {
			if (unexpandPath(path, out var s1, out var s2)) path = $@"%{s1}%\{s2}";
			return path;
		}

		static readonly Lazy<List<(string path, string name)>> _up = new(() => {
			var a = new List<(string path, string name)>(120); //105
			_noGetAutoCreate = true;
			foreach (var pi in typeof(folders).GetProperties()) {
				if (pi.PropertyType == typeof(FolderPath) && pi.GetValue(null) is FolderPath fp) {
					var s = fp.ToString();
					if (!s.NE()) a.Add((s.Lower(), pi.Name));
				}
			}
			_noGetAutoCreate = false;
			return a;
		});

		static readonly Lazy<List<(string path, string name)>> _upv = new(() => {
			var a = new List<(string path, string name)>(30); //22
			foreach (var pi in typeof(folders.shell).GetProperties()) {
				if (pi.PropertyType == typeof(FolderPath) && pi.GetValue(null) is FolderPath fp) {
					var s = fp.ToString();
					//print.it(pi.Name, s);
					if (!s.NE()) a.Add((s, pi.Name));
				}
			}
			return a;
		});
	}
}

namespace Au.Types {
	/// <summary>
	/// Most functions of <see cref="folders"/> class return a value of this type.
	/// Contains folder path (string) and has operator + to append a string with backslash if need. Has implicit conversions from/to string.
	/// </summary>
	public struct FolderPath {
		readonly string _path;
		public FolderPath(string path) { _path = path; }

		public static explicit operator FolderPath(string path) => new(path); //not implicit. Example: var s = "STRING " + folders.ThisApp; // converts "STRING " to FolderPath and result is @"STRING \C:\path"
		public static implicit operator string(FolderPath f) => f._path;

		public override string ToString() => _path;

		/// <summary>
		/// Returns the path string. For some folders it can be null.
		/// </summary>
		public string Path => _path;

		/// <summary>
		/// Returns the path string. If it is null, throws <b>InvalidOperationException</b>.
		/// </summary>
		/// <exception cref="InvalidOperationException"></exception>
		public string PathOrThrow => _path ?? throw new InvalidOperationException("the special folder path is null");

		/// <summary>
		/// Returns true if the path is null.
		/// </summary>
		public bool IsNull => _path == null;

		/// <summary>
		/// Calls <see cref="pathname.combine"/>(fp, append).
		/// Example: <c>string s = folders.Desktop + "file.txt";</c>
		/// </summary>
		/// <exception cref="ArgumentException"><i>fp</i> is empty.</exception>
		public static string operator +(FolderPath fp, string append) {
			if (fp._path.NE()) throw new ArgumentException("No folder path.");
			return pathname.combine(fp._path, append);
		}
	}
}
