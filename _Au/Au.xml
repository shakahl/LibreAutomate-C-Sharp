<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Au</name>
    </assembly>
    <members>
        <member name="T:Au.AAcc">
            <summary>
            Accessible object.
            Finds controls and smaller objects in a window or web page. Clicks, gets properties, etc.
            </summary>
            <remarks>
            Accessible objects (AO) are various user interface (UI) objects in windows and controls. For example buttons, links, list items. This class can find them, get properties, click, etc. Especially useful with web pages, because there are no controls. And many other windows don't use controls but support AO. But not all UI objects are AO.
            
            An <b>AAcc</b> instance holds an AO COM pointer (<msdn>IAccessible</msdn>) and a simple element id (int). Most <b>AAcc</b> functions wrap <b>IAccessible</b> interface functions or/and related API.
            
            <b>AAcc</b> functions that get properties don't throw exception when the wrapped <b>IAccessible</b>/etc function failed (returned an error code of <b>HRESULT</b> type). Then they return "" (string properties), 0, false, null or empty collection, dependin on return type. Applications implement AOs differently, often with bugs, and their <b>IAccessible</b> interface functions return a variety of error codes. It's impossible to reliably detect whether the error code means a serious error or the property is merely unavailable. These <b>AAcc</b> functions also set the last error code of this thread = the return value (<b>HRESULT</b>) of the <b>IAccessible</b> function, and callers can use <see cref="T:Au.ALastError"/> to get it. If <b>ALastError.Code</b> returns 1 (<b>S_FALSE</b>), in most cases it's not an error, just the property is unavailable. On error it will probably be a negative error code.
            
            You can dispose <b>AAcc</b> variables to release the COM object, but it is not necessary (GC will do it later).
            
            An <b>AAcc</b> variable cannot be used in multiple threads. Only <b>Dispose</b> can be called in any thread.
            
            AOs are implemented and live in their applications. This class just communicates with them.
            
            Many applications have various problems with their AOs: bugs, incorrect/nonstandard/partial implementation, or initially disabled. This class implements workarounds for known problems, where possible.
            
            <a data-toggle="collapse" data-target="#collapse1" aria-expanded="false" aria-controls="collapse1">Known problematic applications</a>
            <div class="collapse" id="collapse1">
            <table>
            <tr>
            <th>Application</th>
            <th>Problems</th>
            </tr>
            <tr>
             <td>Chrome web browser. Also Opera and other apps that use Chrome code. Window class name is like "Chrome_WidgetWin_1".</td>
             <td>
              <ol>
               <li>Web page AOs initially are disabled(missing). Workarounds:
                <ul>
                 <li>Functions Find, Wait and FindAll enable it if used role prefix "web:" or "chrome:". Functions FromXY, FromMouse and Focused enable it if window class name starts with "Chrome". However Chrome does it lazily, therefore first time the functions often get wrong AO. Note: this auto-enabing may fail with future Chrome versions.</li>
                 <li>Start Chrome with command line --force-renderer-accessibility.</li>
                 <li>In the future the script editor will have an option to enable Chrome AOs when it starts.</li>
                </ul>
               </li>
               <li>Some new web browser versions add new features or bugs that break something.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Firefox web browser.</td>
             <td>
              <ol>
               <li>By default, the Find function is about 50 times slower than it could be. Also for this reason the Wait function consumes much CPU. And HTML attributes may be unavailable. See <see cref="F:Au.Types.AFFlags.NotInProc"/>. Workaround: disable the Firefox multiprocess feature: open URL about:config, find browser.tabs.remote.autostart, set it = false, restart Firefox. If there is no such option, right-click and create it, as Boolean. If there are more than one similar options, set them all = false. Note: Firefox may reset it when upgrading or reinstalling, or even remove it in the future. If this does not work, google how to disable Firefox multiprocess.</li>
               <li>When Firefox starts, its web page AOs are unavailable. It creates them only when somebody asks (eg function Find), but does it lazily, and Find at first fails. Workaround: use Wait, not Find.</li>
               <li>Ocassionally Firefox briefly turns off its web page AOs. Workaround: use Wait, not Find. With other web browsers also it's better to use Wait.</li>
               <li>Some new web browser versions add new features or bugs that break something.</li>
              </ol>
             </td>
            </tr>
            <tr>
            <td>Edge web browser, JavaFX and other applications that don't have true accessible objects but have UI Automation elements.</td>
             <td>
              <ol>
               <li>To find AOs in these applications, need flag <see cref="F:Au.Types.AFFlags.UIA"/>.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Java applications that use AWT/Swing. Window class name starts with "SunAwt".</td>
             <td>
              <ol>
               <li>Not supported on 32-bit OS.</li>
               <li>Must be enabled Java Access Bridge (JAB).<br/>If JAB is disabled or does not work, the "Find accessible object" tool shows an "enable" link when you try to capture something in a Java window. The link calls Au.Tools.FormAAcc.Java.EnableDisableJabUI. Or you can enable JAB in Control Panel -> Ease of Access Center -> Use the computer without a display. Or use jabswitch.exe. Then restart Java apps. Also may need to restart apps that tried to use Java AOs.</li>
               <li>Your process must have the same 32/64 bitness as the installed Java. To remove this limitation, install Java 32-bit and 64-bit (they coexist).</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>OpenOffice.</td>
             <td>
              <ol>
               <li>Often crashes after using AOs, usually when closing. Noticed in OpenOffice 4.1.4; may be fixed in newer versions.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>LibreOffice.</td>
             <td>
              <ol>
               <li>AOs are unavailable unless this process is 32-bit (when LibreOffice is 64-bit). Also need flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Some controls.</td>
             <td>
              <ol>
               <li>AOs of some controls are not connected to the AO of the parent control. Then Find cannot find them if searches in whole window.<br/>Workaround: search only in that control. For example, use <i>prop</i> <c>"class"</c> or <c>"id"</c>. If it's a web browser control, use role prefix <c>"web:"</c>. Or find the control with <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/> and search in it. Or use <see cref="M:Au.AAcc.Finder.Find(Au.AWnd,Au.AWnd.ChildFinder)"/>.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Some controls with flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.</td>
             <td>
              AOs of many standard Windows controls have bugs when they are retrieved without loading dll into the target process (see <see cref="F:Au.Types.AFFlags.NotInProc"/>). Known bugs:
              <ol>
               <li>Toolbar buttons don't have Name in some cases.</li>
               <li><see cref="M:Au.AAcc.Focus(System.Boolean)"/> and <see cref="M:Au.AAcc.Select(Au.Types.AccSELFLAG)"/> often don't work properly.</li>
              </ol>
              Workarounds: Don't use <see cref="F:Au.Types.AFFlags.NotInProc"/>. Or use <see cref="F:Au.Types.AFFlags.UIA"/>.
             </td>
            </tr>
            <tr>
             <td>When cannot load dll into the target process. For example Windows Store apps.</td>
             <td>
              <ol>
               <li>Function Find is much slower. Function Wait then consumes much more CPU. More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>Processes of a different 32/64 bitness than this process.</td>
             <td>
              <ol>
               <li>To load the dll is used rundll32.exe, which makes slower by about 50 ms first time.</li>
              </ol>
             </td>
            </tr>
            <tr>
             <td>DPI-scaled windows.</td>
             <td>
              <ol>
               <li>Currently this library does not support auto-scaled windows when using high DPI (text size 125%, 150% or more). If the target process is auto-scaled and this process isn't (or vice versa, or they have a different scaling factor), most coordinate-related functions don't work properly. For example, they get wrong AO rectangles.</li>
              </ol>
             </td>
            </tr>
            </table>
            </div>
            </remarks>
            <example>
            Click link "Example" in Chrome.
            <code><![CDATA[
            var w = AWnd.Find("* Chrome").OrThrow();
            var a = AAcc.Find(w, "web:LINK", "Example").OrThrow();
            a.DoAction();
            ]]></code>
            Click a link, wait for new web page, click a link in it.
            <code><![CDATA[
            var w = AWnd.Find("* Chrome").OrThrow();
            var a = AAcc.Wait(1, w, "web:LINK", "Link 1");
            a.DoActionAndWaitForNewWebPage();
            a = AAcc.Wait(10, w, "web:LINK", "Link 2");
            a.DoActionAndWaitForNewWebPage();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AAcc.#ctor(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Creates AAcc from IAccessible and child id.
            By default does not AddRef.
            iacc must not be Is0.
            </summary>
        </member>
        <member name="M:Au.AAcc.#ctor(Au.Types.Cpp.Cpp_Acc,System.Boolean)">
            <summary>
            Creates AAcc from Cpp_Acc.
            By default does not AddRef.
            x.acc must not be Is0.
            </summary>
        </member>
        <member name="M:Au.AAcc._Set(System.IntPtr,System.Int32,Au.AAcc._Misc,System.Boolean)">
            <summary>
            Sets fields.
            _iacc must be 0, iacc not 0.
            </summary>
        </member>
        <member name="M:Au.AAcc.Dispose(System.Boolean)">
            
        </member>
        <member name="M:Au.AAcc.Dispose">
            <summary>
            Releases IAccessible COM object and clears this variable.
            </summary>
        </member>
        <member name="M:Au.AAcc.Finalize">
            
        </member>
        <member name="P:Au.AAcc.SimpleElementId">
            <summary>
            Gets or changes simple element id, also known as child id.
            </summary>
            <remarks>
            Most accessible objects (AO) are not simple elements. Then this property is 0.
            Often (but not always) this property is the 1-based item index in parent AO. For example LISTITEM in LIST.
            The 'set' function sometimes can be used as a fast alternative to <see cref="M:Au.AAcc.Navigate(System.String,System.Double)"/>. It modifies only this variable. It does not check whether the value is valid.
            Simple elements cannot have child AOs.
            </remarks>
        </member>
        <member name="P:Au.AAcc.MiscFlags">
            <summary>
            Returns some additional info about this variable, such as how the accessible object was retrieved (inproc, UIA, Java).
            </summary>
        </member>
        <member name="P:Au.AAcc.Level">
            <summary>
            Gets or sets indentation level for <see cref="M:Au.AAcc.ToString"/>.
            </summary>
            <remarks>
            When Find or similar function finds an accessible object, it sets this property of the AAcc variable. If FromXY etc, it is 0 (unknown).
            When searching in a window, at level 0 are direct children of the WINDOW object. When searching in controls (specified class or id), at level 0 is the object of the control; however if used path, at level 0 are direct children. When searching in AAcc, at level 0 are direct children of the AAcc. When searching in web page (role prefix <c>"web:"</c> etc), at level 0 is the web page object (role DOCUMENT or PANE).
            </remarks>
        </member>
        <member name="P:Au.AAcc._Disposed">
            <summary>
            Returns true if this variable is disposed.
            </summary>
        </member>
        <member name="M:Au.AAcc.FromWindow(Au.AWnd,Au.Types.AccOBJID,Au.Types.AWFlags)">
            <summary>
            Gets accessible object of window or control or its standard part - client area, titlebar etc.
            </summary>
            <param name="w">Window or control.</param>
            <param name="objid">Window part id. Default AccOBJID.WINDOW. Also can be a custom id supported by that window, cast int to AccOBJID.</param>
            <param name="flags">Flags.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
            <exception cref="T:System.ArgumentException"><i>objid</i> is QUERYCLASSNAMEIDX or NATIVEOM.</exception>
            <remarks>
            Uses API <msdn>AccessibleObjectFromWindow</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.FromXY(Au.Types.POINT,Au.Types.AXYFlags)">
            <summary>
            Gets accessible object from point.
            </summary>
            <param name="p">
            Coordinates relative to the primary screen.
            Tip: When need coordinates relative to another screen or/and the work area, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen,System.Boolean,System.Boolean)"/> or tuple (x, y, workArea) etc. Example: <c>var a = AAcc.FromXY((x, y, true));</c>. Also when need <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.
            </param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
            <remarks>
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.FromMouse(Au.Types.AXYFlags)">
            <summary>
            Gets accessible object from mouse cursor (pointer) position.
            </summary>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
            <remarks>
            Uses API <msdn>AccessibleObjectFromPoint</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.Focused(System.Boolean)">
            <summary>
            Gets the accessible object that has the keyboard focus.
            Returns null if fails.
            </summary>
            <param name="useUIAutomation">
            Use UI Automation API.
            Need this with windows that don't support accessible objects but support UI Automation elements. Can be used with most other windows too.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </param>
        </member>
        <member name="M:Au.AAcc.FromEvent(Au.AWnd,Au.Types.AccOBJID,System.Int32)">
            <summary>
            Gets the accessible object that generated the event that is currently being processed by the callback function used with API <msdn>SetWinEventHook</msdn> or <see cref="T:Au.AHookAcc"/>.
            Returns null if failed. Suports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="w"></param>
            <param name="idObject"></param>
            <param name="idChild"></param>
            <remarks>
            The parameters are of the callback function.
            Uses API <msdn>AccessibleObjectFromEvent</msdn>.
            Often fails because the object already does not exist, because the callback function is called asynchronously, especially when the event is OBJECT_DESTROY, OBJECT_HIDE, SYSTEM_*END.
            Returns null if failed. Always check the return value, to avoid NullReferenceException. An exception in the callback function kills this process.
            </remarks>
        </member>
        <member name="T:Au.AAcc._FuncId">
            <summary>
            Used only for debug.
            </summary>
        </member>
        <member name="M:Au.AAcc._Hresult(Au.AAcc._FuncId,System.Int32)">
            <summary>
            Calls Native.SetError and returns hr.
            In Debug config also outputs error in red.
            If hr looks like not an error but just the property or action is unavailable, changes it to S_FALSE and does not show error. These are: S_FALSE, DISP_E_MEMBERNOTFOUND, E_NOTIMPL.
            _FuncId also can be char, like (_FuncId)'n' for name.
            </summary>
        </member>
        <member name="M:Au.AAcc.ToString">
            <summary>
            Formats string from main properties of this accessible object.
            </summary>
            <remarks>
            The string starts with role. Other properties have format like <c>x="value"</c>, where x is a property character like with <see cref="M:Au.AAcc.GetProperties(System.String,Au.Types.AccProperties@)"/>; character e is <see cref="P:Au.AAcc.SimpleElementId"/>. HTML attributes have format <c>@name="value"</c>. In string values are used C# escape sequences, for example \r\n for new line.
            Indentation depends on <see cref="P:Au.AAcc.Level"/>.
            </remarks>
            <seealso cref="M:Au.AAcc.PrintAll(Au.AWnd,System.String,Au.Types.AFFlags,System.String)"/>
        </member>
        <member name="M:Au.AAcc.PrintAll(Au.AWnd,System.String,Au.Types.AFFlags,System.String)">
            <summary>
            Displays properties of all found accessible objects of window w.
            </summary>
            <remarks>
            Uses <see cref="M:Au.AAcc.ToString"/>.
            Catches exceptions. On exception prints <c>$"!exception! exceptionType exceptionMessage"</c>.
            Parameters are of <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.
            By default skips invisible objects and objects in menus. Use flags to include them.
            Chrome web page accessible objects normally are disabled (missing) when it starts. Use role prefix <c>"web:"</c> or <c>"chrome:"</c> to enable. See example.
            </remarks>
            <example>
            Displays visible accessible objects in Chrome web page.
            <code><![CDATA[
            AOutput.Clear();
            var w = AWnd.Find("* Chrome").OrThrow();
            Print("---- all ----");
            AAcc.PrintAll(w, "web:");
            Print("---- links ----");
            AAcc.PrintAll(w, "web:LINK");
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AAcc.Finder">
            <summary>
            Contains accessible object (AO) properties and is used to find the AO.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.
            </remarks>
            <example>
            Find window that contains certain AO, and get the AO too.
            <code><![CDATA[
            var f = new AAcc.Finder("BUTTON", "Apply"); //AO properties
            AWnd w = AWnd.Find(cn: "#32770", also: t => f.Find(t));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AAcc.Finder.Result">
            <summary>
            The found accessible object.
            null if not found. null if used <see cref="P:Au.AAcc.Finder.ResultGetProperty"/>.
            </summary>
        </member>
        <member name="P:Au.AAcc.Finder.ResultProperty">
            <summary>
            The requested propery of the found accessible object, depending on <see cref="P:Au.AAcc.Finder.ResultGetProperty"/>.
            null if: 1. Object not found. 2. <b>ResultGetProperty</b> not used or is '-'. 3. Failed to get the property.
            </summary>
            <remarks>
            The type depends on the property. Most properties are String. Others: <see cref="P:Au.AAcc.Rect"/>, <see cref="P:Au.AAcc.State"/>, <see cref="P:Au.AAcc.WndContainer"/>, <see cref="M:Au.AAcc.HtmlAttributes"/>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.Finder.ResultGetProperty">
            <summary>
            Set this when you need only some property of the accessible object (name, etc) and not the object itself.
            The value is a character, the same as with <see cref="M:Au.AAcc.GetProperties(System.String,Au.Types.AccProperties@)"/>, for example 'n' for Name. Use '-' if you don't need any property.
            </summary>
            <exception cref="T:System.ArgumentException">Used parameter <i>also</i> or <i>navig</i>.</exception>
        </member>
        <member name="P:Au.AAcc.Finder.NavigFailed">
            <summary>
            true if used parameter <i>navig</i> and the intermediate object was found but the navigation did not find the final object.
            </summary>
        </member>
        <member name="M:Au.AAcc.Finder.#ctor(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String)">
            <summary>
            Stores the specified accessible object properties in this object. Reference: <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.
            Does not search now. For it call <b>Find</b> or <b>Wait</b>.
            </summary>
        </member>
        <member name="M:Au.AAcc.Finder.Find(Au.AWnd,Au.AWnd.ChildFinder)">
            <summary>
            Finds accessible object (AO) in the specified control of window w.
            Returns true if found. The <see cref="P:Au.AAcc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="w">Window that contains the control.</param>
            <param name="controls">Control properties. This functions searches in all matching controls.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AAcc.Finder.Find(Au.AWnd)"/>.</exception>
            <remarks>
            Alternatively you can specify control class name or id in role. How this function is different: 1. Allows to specify more control properties. 2. Works better/faster when the control is of a different process or thread than the parent window; else slightly slower.
            </remarks>
        </member>
        <member name="M:Au.AAcc.Finder.Find(Au.AWnd)">
            <summary>
            Finds accessible object (AO) in window w, like <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.
            Returns true if found. The <see cref="P:Au.AAcc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="w">Window or control that contains the AO.</param>
            <exception cref="T:System.ArgumentException">
            - <i>role</i> is "" or invalid.
            - <i>name</i> is invalid wildcard expression (<c>"**options "</c> or regular expression).
            - <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            - flag <see cref="F:Au.Types.AFFlags.UIA"/> when searching in web page (role prefix "web:" etc).
            </exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
        </member>
        <member name="M:Au.AAcc.Finder.Find(Au.AAcc)">
            <summary>
            Finds accessible object (AO) in another AO, like <see cref="M:Au.AAcc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String)"/>.
            Returns true if found. The <see cref="P:Au.AAcc.Finder.Result"/> property will be the found AO.
            </summary>
            <param name="a">Direct or indirect parent AO.</param>
            <exception cref="T:System.ArgumentNullException">a is null.</exception>
            <exception cref="T:System.ArgumentException">
            - <i>role</i> is "" or invalid or has a prefix ("web:" etc).
            - <i>name</i> is invalid wildcard expression (<c>"**options "</c> or regular expression).
            - <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            - flag <see cref="F:Au.Types.AFFlags.UIA"/>.
            - <see cref="P:Au.AAcc.SimpleElementId"/> is not 0.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
        </member>
        <member name="M:Au.AAcc.Finder.Wait(System.Double,Au.AWnd)">
            <summary>
            Finds accessible object (AO) in window w.
            The same as <see cref="M:Au.AAcc.Finder.Find(Au.AWnd)"/>, but waits until the AO is found or the given time expires.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="w">Window or control that contains the AO.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AAcc.Finder.Find(Au.AWnd)"/>.</exception>
        </member>
        <member name="M:Au.AAcc.Finder.Wait(System.Double,Au.AAcc)">
            <summary>
            Finds accessible object (AO) in another AO.
            The same as <see cref="M:Au.AAcc.Finder.Find(Au.AAcc)"/>, but waits until the AO is found or the given time expires.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="a">Direct or indirect parent AO.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AAcc.Finder.Find(Au.AAcc)"/>.</exception>
        </member>
        <member name="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)">
            <summary>
            Finds an accessible object (AO) in window.
            Returns the found AO. Returns null if not found.
            </summary>
            <param name="w">Window or control that contains the AO.</param>
            <param name="role">
            AO role, like <c>"LINK"</c> or <c>nameof(AccROLE.LINK)</c>. Or path, like <c>"ROLE/ROLE/ROLE"</c>.
            Can be used standard roles (see <see cref="T:Au.Types.AccROLE"/>) and custom roles (like <c>"div"</c> in Firefox). More info: <see cref="P:Au.AAcc.Role"/>.
            
            Case-sensitive. Not wildcard.
            null means 'can be any'. Cannot be "".
            
            Can have a prefix:
            - <c>"web:"</c> - search only in the visible web page, not in whole window. Examples: <c>"web:LINK"</c>, <c>"web:/LIST/LISTITEM/LINK"</c>.\
              Supports Firefox, Chrome, Internet Explorer (IE) and apps that use their code. With other windows, searches in the first found visible AO that has DOCUMENT role.\
              Tip: To search only NOT in web pages, use <i>prop</i> <c>"notin=DOCUMENT"</c> (Chrome, Firefox) or <c>"notin=PANE"</c> (IE).
            - <c>"firefox:"</c> - search only in the visible web page of Firefox or Firefox-based web browser. If w window class name starts with "Mozilla", can be used <c>"web:"</c> instead.
            - <c>"chrome:"</c> - search only in the visible web page of Chrome or Chrome-based web browser. If w window class name starts with "Chrome", can be used <c>"web:"</c> instead.
            
            <note>Chrome web page accessible objects normally are disabled (don't exist). Use prefix <c>"web:"</c> or <c>"chrome:"</c> to enable.</note>
            
            Prefix cannot be used:
            - if <i>prop</i> contains <c>"id"</c> or <c>"class"</c>;
            - with flag <see cref="F:Au.Types.AFFlags.UIA"/>;
            - with the non-static <b>Find</b> overload (searching in an AO).
            
            Can be path consisting of roles separated by "/". Examples:
            - <c>"web:DOCUMENT/div/LIST/LISTITEM/LINK"</c> - find LINK using its full path in web page.
            - <c>"web:/div/LIST//LINK"</c> - the empty parts mean 'any role'. For example don't need to specify DOCUMENT because in web pages the first part is always DOCUMENT (Firefox, Chrome) or PANE (IE).
            - <c>"web:/div/LIST[4]/LISTITEM[-1]/LINK"</c> - the 4 is 1-based index of div child from which to start searching (4-th, then 3-th, 5-th and so on). It can make faster. Negative means 'index from end', for example use -1 to search in reverse order. Flag <see cref="F:Au.Types.AFFlags.Reverse"/> is not applied to path parts with indexes. If index is invalid, will use the nearest valid index.
            - <c>"web:/div/LIST[4!]/LISTITEM[-1!]/LINK"</c> - like the above, but the LIST must be exactly 4-th child (don't search 3-th, 5-th etc) and the LISTITEM must be the last child. This can be useful when waiting (uses less CPU), however useless if AO indices in the window or web page change often.
            - <c>"web://[4]/[-1!]/[2]"</c> - index without role.
            - <c>"CLIENT/WINDOW/TREE/TREEITEM[-1]"</c> - path in window or control. The first path part is a direct child AO of the WINDOW AO of the window/control. The WINDOW AO itself is not included in the search; if you need it, instead use <see cref="M:Au.AAcc.FromWindow(Au.AWnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.
            </param>
            <param name="name">
            AO name (<see cref="P:Au.AAcc.Name"/>).
            String format: [](xref:wildcard_expression).
            null means 'any'. "" means 'empty or unavailable'.
            </param>
            <param name="prop">
            Other AO properties and search settings.
            Format: one or more <c>"name=value"</c>, separated with <c>"\0"</c> or <c>"\0 "</c>, like <c>"description=xxx\0 @href=yyy"</c>. Names must match case. Values of string properties are wildcard expressions.
            
            - <c>"class"</c> - search only in child controls that have this class name (see <see cref="P:Au.AWnd.ClassName"/>).
            Cannot be used when searching in an AO.
            - <c>"id"</c> - search only in child controls that have this id (see <see cref="P:Au.AWnd.ControlId"/>). If the value is not a number - Windows Forms control name (see <see cref="P:Au.AWnd.NameWinForms"/>); case-sensitive, not wildcard.
            Cannot be used when searching in an AO.
            - <c>"value"</c> - <see cref="P:Au.AAcc.Value"/>.
            - <c>"description"</c> - <see cref="P:Au.AAcc.Description"/>.
            - <c>"state"</c> - <see cref="P:Au.AAcc.State"/>. List of states that the AO must have and/or not have.
            Example: <c>"state=CHECKED, FOCUSABLE, !DISABLED"</c>.
            Example: <c>"state=0x100010, !0x1"</c>.
            Will find AO that has all states without <c>"!"</c> prefix and does not have any of states with <c>"!"</c> prefix.
            - <c>"rect"</c> - <see cref="P:Au.AAcc.Rect"/>. Can be specified left, top, width and/or height, using <see cref="M:Au.Types.RECT.ToString"/> format.
            Example: <c>"rect={L=1155 T=1182 W=132 H=13}"</c>.
            Example: <c>"rect={W=132 T=1182}"</c>.
            The L T coordinates are relative to the primary screen.
            - <c>"level"</c> - level (see <see cref="P:Au.AAcc.Level"/>) at which the AO can be found. Can be exact level, or minimal and maximal level separated by space.
            The default value is 0 1000.
            Alternatively you can use path in role, like <c>"////LINK"</c>.
            - <c>"elem"</c> - <see cref="P:Au.AAcc.SimpleElementId"/>.
            - <c>"action"</c> - <see cref="P:Au.AAcc.DefaultAction"/>.
            - <c>"key"</c> - <see cref="P:Au.AAcc.KeyboardShortcut"/>.
            - <c>"help"</c> - <see cref="P:Au.AAcc.Help"/>.
            - <c>"uiaid"</c> - <see cref="P:Au.AAcc.UiaId"/>.
            - <c>"maxcc"</c> - when searching, skip children of AO that have more than this number of direct children. It can make faster.
            The default value is 10000. It also prevents hanging or crashing when an AO in the object tree has large number of children. For example OpenOffice Calc TABLE has one billion children.
            - <c>"notin"</c> - when searching, skip children of AO that have these roles. It can make faster.
            Example: <c>"notin=TREE,LIST,TOOLBAR"</c>.
            Roles in the list must be separated with <c>","</c> or <c>", "</c>. Case-sensitive, not wildcard.
            See also: <see cref="F:Au.Types.AFFlags.MenuToo"/>.
            - <c>"@attr"</c> - <see cref="M:Au.AAcc.HtmlAttribute(System.String)"/>. Here "attr" is any attribute name.
            
            Example: <c>"@id=example"</c>.
            </param>
            <param name="flags"></param>
            <param name="also">
            Callback function. Called for each matching AO. Let it return true if this is the wanted AO.
            Example: the AO must contain point x y: <c>o => o.GetRect(out var r, o.WndTopLevel) &amp;&amp; r.Contains(266, 33)</c>
            </param>
            <param name="skip">
            0-based index of matching AO.
            For example, if 1, the function skips the first matching AO and returns the second.
            </param>
            <param name="navig">If not null, the specified object is an intermediate object. After finding it, call <see cref="M:Au.AAcc.Navigate(System.String,System.Double)"/> with this string and return its result.</param>
            <param name="controls">
            Properties of child controls where to search.
            This is an alternative for class/id in <i>prop</i>. Allows to specify more control properties. Works better/faster when the control is of a different process or thread than the parent window; else slightly slower.
            </param>
            
            <exception cref="T:System.ArgumentException">
            - <i>role</i> is "" or invalid.
            - <i>name</i> is invalid wildcard expression (<c>"**options "</c> or regular expression).
            - <i>prop</i> has invalid format or contains unknown property names or invalid wildcard expressions.
            - <i>navig</i> string is invalid.
            - <i>flags</i> has <see cref="F:Au.Types.AFFlags.UIA"/> when searching in web page (role prefix <c>"web:"</c> etc).
            </exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, window of a higher [](xref:uac) integrity level process.</exception>
            
            <remarks>
            To create code for this function, use dialog "Find accessible object". It is form <b>Au.Tools.FormAAcc</b> in Au.Tools.dll.
            
            Walks the tree of accessible objects, until finds a matching AO.
            
            Uses <see cref="T:Au.AAcc.Finder"/>. You can use it directly. See example.
            
            In wildcard expressions supports PCRE regular expressions (prefix <c>"**r "</c>) but not .NET regular expressions (prefix <c>"**R "</c>). They are similar.
            
            To find web page AOs usually it's better to use <see cref="M:Au.AAcc.Wait(System.Double,Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String)"/> instead, it's more reliable.
            
            More info in <see cref="T:Au.AAcc"/> topic.
            </remarks>
            <example>
            Find link "Example" in web page, and click. Throw <b>NotFoundException</b> if not found.
            <code><![CDATA[
            var w = AWnd.Find("* Chrome").OrThrow();
            var a = AAcc.Find(w, "web:LINK", "Example").OrThrow();
            a.DoAction();
            ]]></code>
            Try to find link "Example" in web page. Return if not found.
            <code><![CDATA[
            var w = AWnd.Find("* Chrome").OrThrow();
            var a = AAcc.Find(w, "web:LINK", "Example");
            if(a == null) { Print("not found"); return; }
            a.DoAction();
            ]]></code>
            Use <see cref="T:Au.AAcc.Finder"/>.
            <code><![CDATA[
            var w = AWnd.Find("* Chrome").OrThrow();
            var f = new AAcc.Finder("BUTTON", "Example");
            if(!f.Find(w)) { Print("not found"); return; }
            AAcc a = f.Result;
            a.DoAction();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AAcc.Find(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String)">
            <summary>
            Finds a descendant accessible object (AO) of this AO.
            Returns the found AO. Returns null if not found.
            </summary>
            <exception cref="T:System.ArgumentException">Exceptions of other overload, plus:
            - <i>flags</i> has <see cref="F:Au.Types.AFFlags.UIA"/>.
            - <see cref="P:Au.AAcc.SimpleElementId"/> is not 0.
            </exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.AAcc.Wait(System.Double,Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String)">
            <summary>
            Finds accessible object (AO) in window. Waits until the AO is found or the given time expires.
            More info: <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns the found AO. On timeout returns null if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:Au.Types.AuWndException"/>
            <exception cref="T:Au.Types.AuException"/>
        </member>
        <member name="M:Au.AAcc.Wait(System.Double,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String)">
            <summary>
            Finds a descendant accessible object (AO) of this AO. Waits until the AO is found or the given time expires.
            More info: <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns the found AO. On timeout returns null if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"/>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:Au.Types.AuException"/>
        </member>
        <member name="M:Au.AAcc.FindAll(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean})">
            <summary>
            Finds all matching accessible objects in window.
            More info: <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.
            </summary>
            <returns>Array of 0 or more elements.</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:Au.Types.AuWndException"/>
            <exception cref="T:Au.Types.AuException"/>
            <example>
            Get all taskbar buttons (Windows 10).
            <code><![CDATA[
            var w = AWnd.Find(null, "Shell_TrayWnd").OrThrow();
            foreach(var a in AAcc.FindAll(w, "BUTTON", prop: "level=7")) Print(a);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AAcc.FindAll(System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean})">
            <summary>
            Finds all matching descendant accessible objects (AO) of this AO.
            More info: <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.
            </summary>
            <returns>Array of 0 or more elements.</returns>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:Au.Types.AuException"/>
            <example>
            Get all taskbar buttons (Windows 10).
            <code><![CDATA[
            var w = AWnd.Find(null, "Shell_TrayWnd").OrThrow();
            var atb = AAcc.Find(w, "TOOLBAR", "Running applications").OrThrow();
            foreach(var a in atb.FindAll("BUTTON", prop: "level=0")) Print(a);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AAcc.WndContainer">
            <summary>
            Gets the container window or control of this accessible object.
            </summary>
            <remarks>
            Returns default(AWnd) if failed. Supports <see cref="T:Au.ALastError"/>.
            All objects must support this property, but some have bugs and can fail or return a wrong window.
            Uses API <msdn>WindowFromAccessibleObject</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.WndTopLevel">
            <summary>
            Gets the top-level window that contains this accessible object.
            </summary>
            <remarks>
            Returns default(AWnd) if failed. Supports <see cref="T:Au.ALastError"/>.
            All objects must support this property, but some have bugs and can return default(AWnd).
            Uses API <msdn>WindowFromAccessibleObject</msdn> and API <msdn>GetAncestor</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.Rect">
            <summary>
            Gets location of this accessible object in screen.
            </summary>
            <remarks>
            Calls <see cref="M:Au.AAcc.GetRect(Au.Types.RECT@)"/>.
            Returns empty rectangle if failed or this property is unavailable. Supports <see cref="T:Au.ALastError"/>.
            Most but not all objects support this property.
            </remarks>
        </member>
        <member name="M:Au.AAcc.GetRect(Au.Types.RECT@)">
            <summary>
            Gets location of this accessible object in screen.
            </summary>
            <param name="r">Receives object rectangle in screen coordinates.</param>
            <remarks>
            Returns false if failed or this property is unavailable. Supports <see cref="T:Au.ALastError"/>.
            Most but not all objects support this property.
            Uses <msdn>IAccessible.accLocation</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.GetRect(Au.Types.RECT@,Au.AWnd)">
            <summary>
            Gets location of this accessible object in the client area of window w.
            </summary>
            <param name="r">Receives object rectangle in w client area coordinates.</param>
            <param name="w">Window or control.</param>
            <remarks>
            Returns false if failed or this property is unavailable. Supports <see cref="T:Au.ALastError"/>.
            Most but not all objects support this property.
            Uses <msdn>IAccessible.accLocation</msdn> and <see cref="M:Au.AWnd.MapScreenToClient(Au.Types.RECT@)"/>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.RoleInt">
            <summary>
            Gets standard non-string role, as enum AccROLE.
            </summary>
            <remarks>
            Most objects have a standard role, as enum <see cref="T:Au.Types.AccROLE"/>. Some objects have a custom role, usually as string, for example in web pages in Firefox and Chrome.
            Returns 0 if role is string or if failed. Supports <see cref="T:Au.ALastError"/>.
            All objects must support this property. If failed, probably the object is invalid, for example its window was closed.
            Uses <msdn>IAccessible.get_accRole</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.Role">
            <summary>
            Gets standard or custom role, as string.
            </summary>
            <remarks>
            Most objects have a standard role, as enum <see cref="T:Au.Types.AccROLE"/>. Some objects have a custom role, usually as string, for example in web pages in Firefox and Chrome.
            For standard roles this function returns enum <see cref="T:Au.Types.AccROLE"/> member name. For string roles - the string. For unknown non-string roles - the int value like "0" or "500".
            Returns "" if failed. Supports <see cref="T:Au.ALastError"/>.
            All objects must support this property. If failed, probably the object is invalid, for example its window was closed.
            Uses <msdn>IAccessible.get_accRole</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.State">
            <summary>
            Gets object state (flags).
            </summary>
            <remarks>
            Returns 0 if failed. Supports <see cref="T:Au.ALastError"/>.
            Uses <msdn>IAccessible.get_accState</msdn>.
            </remarks>
            <example>
            <code><![CDATA[
            if(a.State.Has(AccSTATE.INVISIBLE)) Print("has state INVISIBLE");
            if(a.IsInvisible) Print("invisible");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AAcc.IsChecked">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state CHECKED. </summary>
        </member>
        <member name="P:Au.AAcc.IsDisabled">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state UNAVAILABLE. </summary>
            <remarks>Does not check whether this object is in a disabled parent/ancestor object.</remarks>
        </member>
        <member name="P:Au.AAcc.IsFocused">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state FOCUSED. </summary>
        </member>
        <member name="P:Au.AAcc.IsInvisible">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state INVISIBLE and does not have state OFFSCREEN. </summary>
            <remarks>
            If the object has both INVISIBLE and OFFSCREEN states, it is either invisible or just offscreen, depending on application etc. Then this function works like Find and similar functions: for most objects returns false (is visible), but for objects that have these roles returns true (invisible): WINDOW, DOCUMENT, PROPERTYPAGE, GROUPING, ALERT, MENUPOPUP.
            Does not check whether this object is in an invisible parent/ancestor object.
            </remarks>
        </member>
        <member name="P:Au.AAcc.IsOffscreen">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state OFFSCREEN. </summary>
        </member>
        <member name="P:Au.AAcc.IsPassword">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state PROTECTED. </summary>
            <remarks>This state is used for password fields.</remarks>
        </member>
        <member name="P:Au.AAcc.IsPressed">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state PRESSED. </summary>
        </member>
        <member name="P:Au.AAcc.IsReadonly">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state READONLY. </summary>
        </member>
        <member name="P:Au.AAcc.IsSelected">
            <summary> Calls <see cref="P:Au.AAcc.State"/> and returns true if has state SELECTED. </summary>
        </member>
        <member name="M:Au.AAcc._BstrToString(System.Int32,Au.Types.BSTR)">
            <summary>
            Converts BSTR to string and disposes the BSTR.
            If hr is not 0, returns "" (never null).
            </summary>
        </member>
        <member name="P:Au.AAcc.Name">
            <summary>
            Gets name.
            </summary>
            <remarks>
            Object name usually is its read-only text (eg button text, link text), or its adjacent read-only text (eg text label by this edit box). It usually does not change, therefore can be used to find or identify the object.
            Returns "" if name is unavailable or if failed. Supports <see cref="T:Au.ALastError"/>.
            Uses <msdn>IAccessible.get_accName</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.LibNameOfWindow(Au.AWnd)">
            <summary>
            Gets <see cref="P:Au.AAcc.Name"/> of window/control w.
            Returns null if w invalid. Returns "" if failed to get name.
            </summary>
        </member>
        <member name="P:Au.AAcc.Value">
            <summary>
            Gets or sets value.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to set value.</exception>
            <remarks>
            Usually it is editable text or some other value that can be changed at run time, therefore in most cases it cannot be used to find or identify the object reliably.
            The 'get' function returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.ALastError"/>.
            Most objects don't support 'set'.
            Uses <msdn>IAccessible.get_accValue</msdn> or <msdn>IAccessible.put_accValue</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.Description">
            <summary>
            Gets description.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.ALastError"/>.
            Uses <msdn>IAccessible.get_accDescription</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.Help">
            <summary>
            Gets help text.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.ALastError"/>.
            Uses <msdn>IAccessible.get_accHelp</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.UiaId">
            <summary>
            Gets UI Automation element AutomationId property.
            </summary>
            <remarks>
            Only objects found with flag <see cref="F:Au.Types.AFFlags.UIA"/> can have this property.
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.KeyboardShortcut">
            <summary>
            Gets keyboard shortcut.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.ALastError"/>.
            Uses <msdn>IAccessible.get_accKeyboardShortcut</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AAcc.DefaultAction">
            <summary>
            Gets default action.
            </summary>
            <remarks>
            Returns "" if this property is unavailable or if failed. Supports <see cref="T:Au.ALastError"/>.
            If this is a Java accessible object, returns all actions that can be used with <see cref="M:Au.AAcc.DoJavaAction(System.String)"/>, like "action1, action2, action3", from which the first is considered default and is used by <see cref="M:Au.AAcc.DoAction"/>.
            Uses <msdn>IAccessible.get_accDefaultAction</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.DoAction">
            <summary>
            Performs the object's default action (see <see cref="P:Au.AAcc.DefaultAction"/>). Usually it is 'click', 'press' or similar.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Fails if the object does not have a default action. Then you can use <see cref="M:Au.AExtAu.MouseClick(Au.AAcc,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)"/>, or try <see cref="M:Au.AAcc.VirtualClick"/>, <see cref="M:Au.AAcc.Select(Au.Types.AccSELFLAG)"/>, <see cref="M:Au.AAcc.Focus(System.Boolean)"/> and keyboard functions.
            The action can take long time, for example show a dialog. This function normally does not wait. It allows the caller to automate the dialog. If it waits, try <see cref="M:Au.AAcc.DoJavaAction(System.String)"/> or one of the above functions (MouseClick etc).
            Uses <msdn>IAccessible.accDoDefaultAction</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.VirtualClick">
            <summary>
            Posts mouse-left-click message to the container window, using coordinates of this object.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to get rectangle, or the object is invisible/offscreen.</exception>
            <remarks>
            Does not move the mouse.
            Does not wait until the target application finishes processing the message.
            Works not with all objects.
            Use (try) this function when the object does not support <see cref="M:Au.AAcc.DoAction"/>. When both don't work, use MouseClick.
            </remarks>
        </member>
        <member name="M:Au.AAcc.VirtualRightClick">
            <summary>
            Posts mouse-right-click message to the container window, using coordinates of this object.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to get rectangle, or the object is invisible/offscreen.</exception>
            <remarks>
            Does not move the mouse.
            Does not wait until the target application finishes processing the message.
            Works not with all objects. When does not work, use MouseClick.
            </remarks>
        </member>
        <member name="M:Au.AAcc.DoJavaAction(System.String)">
            <summary>
            Performs one of actions supported by this Java accessible object.
            </summary>
            <param name="action">
            Action name. See <see cref="P:Au.AAcc.DefaultAction"/>.
            If null (default), performs default action (like <see cref="M:Au.AAcc.DoAction"/>) or posts Space key message. More info in Remarks.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Read more about Java accessible objects in <see cref="T:Au.AAcc"/> topic.
            
            Problem: if the action opens a dialog, DoAction/DoJavaAction do not return until the dialog is closed (or fail after some time). The caller then waits and cannot automate the dialog. Also then this process cannot exit until the dialog is closed. If the action parameter is null and the object is focusable, this function tries a workaround: it makes the object (button etc) focused and posts Space key message, which should press the button; then this function does not wait.
            </remarks>
        </member>
        <member name="M:Au.AAcc.DoActionAndWaitForNewWebPage(System.Double,System.Action{Au.AAcc})">
            <summary>
            Calls <see cref="M:Au.AAcc.DoAction"/> or <i>action</i> and waits until window name changes and web page name changes.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).
            Default 60 seconds.
            </param>
            <param name="action">If used, calls it instead of <see cref="M:Au.AAcc.DoAction"/>.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, when this object is invalid, or its top-level window does not contain a web page.</exception>
            <exception cref="T:Au.Types.AuWndException">The window was closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.AAcc.DoAction"/> or by the <i>action</i> function.</exception>
            <remarks>
            This function is used to click a link in a web page and wait until current web page is gone. It prevents a following 'wait for object' function from finding a matching object in the old page, which would be bad.
            This function does not wait until the new page is completely loaded. There is no reliable/universal way for it. Instead, after calling it you can call a 'wait for object' function which waits for a known object that must be in the new page.
            This function cannot be used when the new page has the same title as current page. Then it waits until <i>secondsTimeout</i> time or forever. The same if the action does not open a web page.
            </remarks>
        </member>
        <member name="M:Au.AAcc.Select(Au.Types.AccSELFLAG)">
            <summary>
            Selects or deselects.
            </summary>
            <param name="how">Specifies whether to select, focus, add to selection etc. Can be two flags, for example <c>AccSELFLAG.TAKEFOCUS | AccSELFLAG.TAKESELECTION</c>.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <exception cref="T:Au.Types.AuWndException">Failed to activate the window (<see cref="M:Au.AWnd.Activate"/>) or focus the control (<see cref="M:Au.AWnd.Focus"/>).</exception>
            <remarks>
            Uses <msdn>IAccessible.accSelect</msdn>.
            Not all objects support it. Most objects support not all flags. It depends on <see cref="T:Au.Types.AccSTATE"/> FOCUSABLE, SELECTABLE, MULTISELECTABLE, EXTSELECTABLE, DISABLED.
            Many object have bugs, especially with flag TAKEFOCUS. More bugs when the object found with flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.Focus(System.Boolean)">
            <summary>
            Makes this object focused for keyboard input.
            </summary>
            <param name="andSelect">Add flag TAKESELECTION. Note: it is for selecting a list item, not for selecting text in a text box.</param>
            <remarks>
            Calls <see cref="M:Au.AAcc.Select(Au.Types.AccSELFLAG)"/> with flag TAKEFOCUS and optionally TAKESELECTION.
            Not all objects support this action and not all work correctly. More info in Select documentation.
            </remarks>
        </member>
        <member name="P:Au.AAcc.SelectedChildren">
            <summary>
            Gets selected direct child items.
            Returns empty array if there are no selected items of if failed. Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="P:Au.AAcc.ChildCount">
            <summary>
            Gets the number of direct child objects.
            </summary>
            <remarks>
            Uses <msdn>IAccessible.get_accChildCount</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.GetProperties(System.String,Au.Types.AccProperties@)">
            <summary>
            Gets multiple properties.
            </summary>
            <param name="props">
            Which properties to get. Each character specifies a property:
            'R' - <see cref="P:Au.AAcc.Role"/>.
            'n' - <see cref="P:Au.AAcc.Name"/>.
            'v' - <see cref="P:Au.AAcc.Value"/>.
            'd' - <see cref="P:Au.AAcc.Description"/>.
            'h' - <see cref="P:Au.AAcc.Help"/>.
            'a' - <see cref="P:Au.AAcc.DefaultAction"/>.
            'k' - <see cref="P:Au.AAcc.KeyboardShortcut"/>.
            'u' - <see cref="P:Au.AAcc.UiaId"/>.
            's' - <see cref="P:Au.AAcc.State"/>.
            'r' - <see cref="P:Au.AAcc.Rect"/>.
            'w' - <see cref="P:Au.AAcc.WndContainer"/>.
            'o' - <see cref="M:Au.AAcc.Html(System.Boolean)"/> outer.
            'i' - <see cref="M:Au.AAcc.Html(System.Boolean)"/> inner.
            '@' - <see cref="M:Au.AAcc.HtmlAttributes"/>.
            </param>
            <param name="result">Receives results.</param>
            <exception cref="T:System.ArgumentException">Unknown property character.</exception>
            <remarks>
            The returned variable contains values of properties specified in <i>props</i>. When a property is empty or failed to get, the member variable is "", empty dictionary or default value of that type; never null.
            
            Normally this function is faster than calling multiple property functions, because it makes single remote procedure call. But not if this accessible object was found with flag <see cref="F:Au.Types.AFFlags.NotInProc"/> etc.
            
            Returns false if fails, for example when the object's window is closed. Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AAcc.Navigate(System.String,System.Double)">
            <summary>
            Gets an adjacent or related accessible object (AO) - next, child, parent, etc.
            Returns null if not found.
            </summary>
            <param name="navig">
            String consisting of one or more navigation direction strings separated by space, like <c>"parent next child4 first"</c>.
            - <c>"next"</c> - next sibling AO in the same parent AO.
            - <c>"previous"</c> - previous sibling AO in the same parent AO.
            - <c>"first"</c> - first child AO.
            - <c>"last"</c> - last child AO.
            - <c>"parent"</c> - parent (container) AO.
            - <c>"child"</c> - child AO by 1-based index. Example: <c>"child3"</c> (3-th child). Negative index means from end, for example -1 is the last child.
            - <c>"#N"</c> - N is a numeric value to pass to <msdn>IAccessible.accNavigate</msdn> as navDir. Can be any standard or custom value supported by the AO.
            
            Can be only 2 letters, like <c>"pr"</c> for <c>"previous"</c>.
            A string like <c>"next3"</c> or <c>"next,3"</c> is the same as <c>"next next next"</c>. Except for <c>"child"</c>.
            
            For <c>"next"</c>, <c>"previous"</c>, <c>"firstchild"</c>, <c>"lastchild"</c> and <c>"#N"</c> is used <msdn>IAccessible.accNavigate</msdn>. Not all AOs support it. Some AOs skip invisible siblings. Instead you can use <c>"parent childN"</c> or <c>"childN"</c>.
            For <c>"parent"</c> is used <msdn>IAccessible.get_accParent</msdn>. Few AOs don't support. Some AOs return a different parent than in the AO tree.
            For <c>"child"</c> is used API <msdn>AccessibleChildren</msdn>.
            </param>
            <param name="secondsToWait">Wait for the wanted AO max this number of seconds. If negative, waits forever.</param>
            <exception cref="T:System.ArgumentException">Invalid <i>navig</i> string.</exception>
            <example>
            <code><![CDATA[
            a = a.Navigate("parent next ch3", true);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AAcc.Html(System.Boolean)">
            <summary>
            Gets HTML.
            </summary>
            <param name="outer">If true, gets outer HTML (with tag and attributes), else inner HTML.</param>
            <remarks>
            Returns "" if this is not a HTML element or if failed. Supports <see cref="T:Au.ALastError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            If this is the root of web page (role DOCUMENT or PANE), gets web page body HTML.
            </remarks>
        </member>
        <member name="M:Au.AAcc.HtmlAttribute(System.String)">
            <summary>
            Gets a HTML attribute.
            </summary>
            <param name="name">Attribute name, for example <c>"href"</c>, <c>"id"</c>, <c>"class"</c>. Full, case-sensitive.</param>
            <remarks>
            Returns "" if this is not a HTML element or does not have the specified attribute or failed. Supports <see cref="T:Au.ALastError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            </remarks>
            <exception cref="T:System.ArgumentException">name is null/""/invalid.</exception>
        </member>
        <member name="M:Au.AAcc.HtmlAttributes">
            <summary>
            Gets all HTML attributes.
            </summary>
            <remarks>
            Returns empty dictionary if this is not a HTML element or does not have attributes or failed. Supports <see cref="T:Au.ALastError"/>.
            Works with Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). This object must be found without flag NotInProc.
            </remarks>
        </member>
        <member name="M:Au.AAcc.ScrollTo">
            <summary>
            Scrolls this accessible object into view.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to scroll, or the object does not support scrolling.</exception>
            <remarks>
            This function works with these objects:
            - Web page objects in Firefox, Chrome, Internet Explorer and apps that use their code (Thunderbird, Opera, web browser controls...). With Find use role prefix "web:", "firefox:" or "chrome:", and don't use flag <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            - Objects in Edge browser, standard treeview and listview controls, some other. With Find use flag <see cref="F:Au.Types.AFFlags.UIA"/>.
            </remarks>
        </member>
        <member name="T:Au.Types.AFFlags">
            <summary>
            Flags for <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.Reverse">
            <summary>
            Search in reverse order. It can make faster.
            When control class or id is specified in the <i>prop</i> argument, controls are searched not in reverse order. Only accessible objects in them are searched in reverse order.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.HiddenToo">
            <summary>
            The accessible object can be invisible.
            Without this flag skips objects that are invisible (have state INVISIBLE) or are descendants of invisible WINDOW, DOCUMENT, PROPERTYPAGE, GROUPING, ALERT, MENUPOPUP.
            Regardless of this flag, always skips invisible standard objects of nonclient area: TITLEBAR, MENUBAR, SCROLLBAR, GRIP.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.MenuToo">
            <summary>
            Always search in MENUITEM.
            Without this flag skips MENUITEM descendant objects (for speed), unless role is MENUITEM or MENUPOPUP or searching in web page.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.ClientArea">
            <summary>
            Search only in the client area of the window or control.
            Skips the title bar, standard menubars and scrollbars. Searches only in the client area root object (but will not find the object itself).
            When control class or id is specified in the <i>prop</i> argument, this flag is applied to these controls. Not applied to other controls.
            Don't use this flag when searching in AAcc or web page (role prefix "web:" etc) or with flag UIA.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.NotInProc">
            <summary>
            Search without loading dll into the target process.
            Disadvantages: 1. Much slower. 2. Some properties are not supported, for example HTML attributes (while searching and later). 3. And more.
            Even without this flag, the default search method is not used with Windows Store app windows, console windows, most Java windows, windows of protected processes and processes of higher [](xref:uac) integrity level, Firefox web page if its multiprocess feature is not disabled.
            Some windows have child controls that belong to a different process or thread than the window. Example - Internet Explorer. When searching in such windows, the default search method is not used when searching in these controls. Workaround - find the control(s) and search in it/them. For it can be used one of: 1. With Internet Explorer use role prefix "web:". 2. Find the control with <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/> and search in it. 3. Use <see cref="M:Au.AAcc.Finder.Find(Au.AWnd,Au.AWnd.ChildFinder)"/>.
            Don't need this flag when searching in AAcc (then it is inherited from the Acc variable).
            See also: <see cref="P:Au.AAcc.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AFFlags.UIA">
            <summary>
            Use UI Automation API.
            Need this flag to find objects in windows that don't support accessible objects but support UI Automation elements.
            Examples of such windows: Microsoft Edge web browser (web page), JavaFX applications.
            Objects found with this flag never have HtmlX properties, but can have <see cref="P:Au.AAcc.UiaId"/>.
            This flag can be used with most other windows too.
            Don't use this flag when searching in AAcc (then it is inherited from the Acc variable) or web page (role prefix "web:" etc).
            See also: <see cref="P:Au.AAcc.MiscFlags"/>.
            </summary>
        </member>
        <member name="T:Au.Types.LibAFFlags">
            <summary>
            A workaround to add internal members to public enums.
            </summary>
        </member>
        <member name="F:Au.Types.LibAFFlags.AFFlags_Mark">
            <summary>
            Used by tools like "Find accessible object", together with AccMiscFlags_Marked.
            </summary>
        </member>
        <member name="F:Au.Types.LibAFFlags.AccMiscFlags_Marked">
            <summary>
            Used by tools like "Find accessible object", together with AFFlags_Mark.
            </summary>
        </member>
        <member name="T:Au.Types.AWFlags">
            <summary>
            Flags for <see cref="M:Au.AAcc.FromWindow(Au.AWnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AWFlags.NoThrow">
            <summary>Don't throw exception when fails. Then returns null.</summary>
        </member>
        <member name="F:Au.Types.AWFlags.NotInProc">
            <summary>
            Don't load dll into the target process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AXYFlags">
            <summary>
            Flags for <see cref="M:Au.AAcc.FromXY(Au.Types.POINT,Au.Types.AXYFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.UIA">
            <summary>
            Use UI Automation API.
            Need this flag with some windows that don't support accessible objects but support UI Automation elements.
            When this flag is not specified, the function detects most such windows and uses UI Automation API, but the detection is not perfect.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            This flag can be used with most other windows too.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.PreferLink">
            <summary>
            Get the direct parent object if it's LINK or BUTTON.
            Usually links have one or more children of type TEXT, STATICTEXT, IMAGE or other.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.NotInProc">
            <summary>
            Don't load dll into the target process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AXYFlags.NoThrow">
            <summary>Don't throw exception when fails. Then returns null.</summary>
        </member>
        <member name="T:Au.Types.AccMiscFlags">
            <summary>
            Flags returned by <see cref="P:Au.AAcc.MiscFlags"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.InProc">
            <summary>
            This accessible object was retrieved by the dll loaded into its process.
            More info: <see cref="F:Au.Types.AFFlags.NotInProc"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.UIA">
            <summary>
            This accessible object was retrieved using UI Automation API.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccMiscFlags.Java">
            <summary>
            This accessible object was retrieved using Java Access Bridge API.
            More info: <see cref="T:Au.AAcc"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AccOBJID">
            <summary>
            Accessible object ids of window parts and some special objects.
            Used with <see cref="M:Au.AAcc.FromWindow(Au.AWnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>
            </summary>
            <remarks>
            The names are as in API <msdn>AccessibleObjectFromWindow</msdn> documentation but without prefix "OBJID_". Except Java and UIA.
            </remarks>
        </member>
        <member name="F:Au.Types.AccOBJID.QUERYCLASSNAMEIDX">
            <summary>
            Can be used with API <msdn>WM_GETOBJECT</msdn>, not with <see cref="M:Au.AAcc.FromWindow(Au.AWnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccOBJID.NATIVEOM">
            <summary>
            Can be used with API <msdn>AccessibleObjectFromWindow</msdn>, not with <see cref="M:Au.AAcc.FromWindow(Au.AWnd,Au.Types.AccOBJID,Au.Types.AWFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.AccOBJID.Java">
            <summary>
            The root Java object. Can be used when the window's class name starts with "SunAwt".
            </summary>
        </member>
        <member name="F:Au.Types.AccOBJID.UIA">
            <summary>
            Use UI Automation API.
            More info: <see cref="F:Au.Types.AFFlags.UIA"/>.
            </summary>
        </member>
        <member name="T:Au.Types.AccROLE">
            <summary>
            Standard roles of accessible objects.
            Used with <see cref="P:Au.AAcc.RoleInt"/>
            </summary>
            <remarks>
            Most names are as in API <msdn>IAccessible.get_accRole Object Roles</msdn> documentation but without prefix "ROLE_SYSTEM_". These are renamed: PUSHBUTTON to BUTTON, CHECKBUTTON to CHECKBOX, GRAPHIC to IMAGE, OUTLINE to TREE, OUTLINEITEM to TREEITEM, OUTLINEBUTTON to TREEBUTTON,
            </remarks>
        </member>
        <member name="T:Au.Types.AccSTATE">
            <summary>
            Accessible object state flags.
            Used by <see cref="P:Au.AAcc.State"/>.
            </summary>
            <remarks>
            Most names are as in API <msdn>IAccessible.get_accState Object State Constants</msdn> documentation but without prefix "STATE_SYSTEM_".
            </remarks>
        </member>
        <member name="T:Au.Types.AccSELFLAG">
            <summary>
            Accessible object selection flags.
            Used by <see cref="M:Au.AAcc.Select(Au.Types.AccSELFLAG)"/>.
            </summary>
            <remarks>
            The names are as in API <msdn>IAccessible.accSelect</msdn> documentation but without prefix "SELFLAG_".
            </remarks>
        </member>
        <member name="T:Au.Types.AccEVENT">
            <summary>
            Event constants for <see cref="T:Au.AHookAcc"/>.
            </summary>
            <remarks>
            The names are as in API <msdn>SetWinEventHook Event Constants</msdn> documentation but without prefix "EVENT_".
            </remarks>
        </member>
        <member name="T:Au.Types.AccHookFlags">
            <summary>
            Flags for <see cref="T:Au.AHookAcc"/>.
            </summary>
            <remarks>
            The names are as in API <msdn>SetWinEventHook</msdn> documentation but without prefix "WINEVENT_".
            There are no flags for OUTOFCONTEXT and INCONTEXT. OUTOFCONTEXT is default (0). INCONTEXT cannot be used in managed code.
            </remarks>
        </member>
        <member name="F:Au.Types.AccHookFlags.SKIPOWNTHREAD">
            <summary>Don't receive events generated by this thread.</summary>
        </member>
        <member name="F:Au.Types.AccHookFlags.SKIPOWNPROCESS">
            <summary>Don't receive events generated by threads of this process.</summary>
        </member>
        <member name="T:Au.Types.AccProperties">
            <summary>
            Used with <see cref="M:Au.AAcc.GetProperties(System.String,Au.Types.AccProperties@)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SizeOf``1(``0)">
            <summary>
            Gets the native size of a struct variable.
            Returns Marshal.SizeOf(typeof(T)).
            Speed: the same (in Release config) as Marshal.SizeOf(typeof(T)), and 2 times faster than Marshal.SizeOf(v).
            </summary>
        </member>
        <member name="M:Au.Types.Api.SizeOf``1">
            <summary>
            Gets the native size of a type.
            Returns Marshal.SizeOf(typeof(T)).
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetProcAddress(System.String,System.String)">
            <summary>
            Gets dll module handle (Api.GetModuleHandle) or loads dll (Api.LoadLibrary), and returns unmanaged exported function address (Api.GetProcAddress).
            See also: GetDelegate.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(``0@,System.String,System.String)">
            <summary>
            Calls <see cref="M:Au.Types.Api.GetProcAddress(System.String,System.String)"/> (loads dll or gets handle) and <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.GetDelegate``1(``0@,System.IntPtr,System.String)">
            <summary>
            Calls API <see cref="M:Au.Types.Api.GetProcAddress(System.IntPtr,System.String)"/> and <see cref="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.ReleaseComObject``1(``0)">
            <summary>
            If o is not null, calls <see cref="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SetDIBitsToDevice(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Void*,System.UInt32)">
            <summary>
            lpbmi can be BITMAPINFOHEADER/BITMAPV5HEADER or BITMAPCOREHEADER.
            </summary>
        </member>
        <member name="M:Au.Types.Api.SECURITY_ATTRIBUTES.#ctor(System.String)">
            <summary>
            Creates SECURITY_ATTRIBUTES from string security descriptor.
            securityDescriptor can be null; then lpSecurityDescriptor will be null;
            </summary>
        </member>
        <member name="F:Au.Types.Api.SECURITY_ATTRIBUTES.ForLowIL">
            <summary>
            Creates SECURITY_ATTRIBUTES that allows UAC low IL processes to open the kernel object.
            </summary>
        </member>
        <member name="F:Au.Types.Api.SECURITY_ATTRIBUTES.ForPipes">
            <summary>
            Creates SECURITY_ATTRIBUTES that allows UAC medium IL processes to open the pipe.
            Like of PipeSecurity that allows ReadWrite for AuthenticatedUserSid.
            </summary>
        </member>
        <member name="F:Au.Types.Api.WINDOWPLACEMENT.flags">
            <summary> WPF_ </summary>
        </member>
        <member name="F:Au.Types.Api.AuExtraInfo">
            <summary>
            Extra info value of key and mouse events sent by functions of this library.
            </summary>
        </member>
        <member name="P:Au.Types.Api.KBDLLHOOKSTRUCT.IsInjected">
            <summary>
            true if the event was generated by software.
            </summary>
        </member>
        <member name="P:Au.Types.Api.KBDLLHOOKSTRUCT.IsInjectedByAu">
            <summary>
            true if the event was generated by functions of this library.
            </summary>
        </member>
        <member name="P:Au.Types.Api.KBDLLHOOKSTRUCT.BlockEvent">
            <summary>
            The 'set' function adds or removes flag 0x80000000.
            The 'get' function returns true if flag 0x80000000 is set.
            </summary>
        </member>
        <member name="T:Au.Types.Api.KBDLLHOOKSTRUCT2">
            <summary>
            Used to pass KBDLLHOOKSTRUCT from the triggers hook server process to a client process.
            If they are of different 64/32 bitness, then sizeof(KBDLLHOOKSTRUCT) is different, but sizeof(KBDLLHOOKSTRUCT2) is the same, max of them.
            </summary>
        </member>
        <member name="P:Au.Types.Api.MSLLHOOKSTRUCT.IsInjected">
            <summary>
            true if the event was generated by software.
            </summary>
        </member>
        <member name="P:Au.Types.Api.MSLLHOOKSTRUCT.IsInjectedByAu">
            <summary>
            true if the event was generated by functions of this library.
            </summary>
        </member>
        <member name="P:Au.Types.Api.MSLLHOOKSTRUCT.BlockEvent">
            <summary>
            The 'set' function adds or removes flag 0x80000000.
            The 'get' function returns true if flag 0x80000000 is set.
            </summary>
        </member>
        <member name="T:Au.Types.Api.MSLLHOOKSTRUCT2">
            <summary>
            Used to pass MSLLHOOKSTRUCT and mouse message from the triggers hook server process to a client process.
            If they are of different 64/32 bitness, then sizeof(MSLLHOOKSTRUCT) is different, but sizeof(MSLLHOOKSTRUCT2) is the same, max of them.
            </summary>
        </member>
        <member name="M:Au.Types.Api.CalculatePopupWindowPosition(Au.Types.POINT@,Au.Types.SIZE@,System.UInt32,Au.Types.RECT@,Au.Types.RECT@)">
            <param name="flags">Au.Controls.PopupAlignment</param>
        </member>
        <member name="M:Au.Types.Api.PROPVARIANT.Dispose">
            <summary>
            Calls PropVariantClear.
            </summary>
        </member>
        <member name="T:Au.Types.Native">
            <summary>
            Windows API types and constants used with public functions (parameters etc) of this library.
            </summary>
        </member>
        <member name="T:Au.Types.Native.GUI">
            <summary><see cref="T:Au.Types.Native.GUITHREADINFO"/> flags.</summary>
        </member>
        <member name="F:Au.Types.Native.CREATESTRUCT.lpszClass">
            <summary>Can be string or atom (ushort).</summary>
        </member>
        <member name="T:Au.Types.Native.WNDPROC">
            <summary>API <msdn>WNDPROC</msdn></summary>
        </member>
        <member name="T:Au.Types.Native.SUBCLASSPROC">
            <summary>API <msdn>SUBCLASSPROC</msdn></summary>
        </member>
        <member name="T:Au.Types.Native.SWP">
            <summary>API <msdn>SetWindowPos</msdn> flags.</summary>
        </member>
        <member name="T:Au.Types.Native.HWND">
            <summary>
            Special window handle values.
            See API <msdn>SetWindowPos</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.Native.GWL">
            <summary>
            Window long constants.
            See API <msdn>GetWindowLong</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.Native.GCL">
            <summary>
            Window class long constants.
            See API <msdn>WNDCLASSEX</msdn>, API <msdn>GetClassLong</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.Native.SMTO">
            <summary>API <msdn>SendMessageTimeout</msdn> flags.</summary>
        </member>
        <member name="T:Au.Types.Native.TDM">
            <summary>
            Messages that your <see cref="T:Au.ADialog"/> event handler can send to the dialog.
            </summary>
        </member>
        <member name="T:Au.Types.Native.TDN">
            <summary>
            Notification messages that your <see cref="T:Au.ADialog"/> event handler receives.
            </summary>
        </member>
        <member name="T:Au.Types.Native.TDE">
            <summary>
            Constants for Native.TDM.SET_ELEMENT_TEXT and Native.TDM.UPDATE_ELEMENT_TEXT messages and ADialog.Send.Text().
            Used with <see cref="T:Au.ADialog"/>.
            </summary>
        </member>
        <member name="T:Au.Types.Native.TDIE">
            <summary>
            Constants for Native.TDM.UPDATE_ICON message used with <see cref="T:Au.ADialog"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WS">
            <summary>
            Window styles.
            See API <msdn>CreateWindowEx</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.WS_EX">
            <summary>
            Window extended styles.
            See API <msdn>CreateWindowEx</msdn>.
            </summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_AccFromWindow(System.Int32,Au.AWnd,Au.Types.AccOBJID,Au.Types.Cpp.Cpp_Acc@,Au.Types.BSTR@)">
            <summary>
            flags: 1 not inproc, 2 get only name.
            </summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_RegexCompile(System.String,Au.Types.LPARAM,Au.Types.RXFlags,System.Int32@,Au.Types.BSTR@)">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="T:Au.Types.Cpp.RegexMatch">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="M:Au.Types.Cpp.Cpp_RegexMatch(System.Runtime.InteropServices.HandleRef,System.String,Au.Types.LPARAM,Au.Types.LPARAM,Au.Types.RXMatchFlags,Au.Types.Cpp.PcreCalloutT,Au.Types.Cpp.RegexMatch@,Au.Types.BSTR@)">
            <summary>This and related API are documented in the C++ dll project.</summary>
        </member>
        <member name="T:Au.Types.OptDebug">
            <summary>
            Options for showing run-time warnings and other info that can be useful to find problems in code at run time.
            </summary>
        </member>
        <member name="M:Au.Types.OptDebug.#ctor(Au.Types.OptDebug)">
            <summary>
            Initializes this instance with default values or values copied from another instance.
            </summary>
            <param name="cloneOptions">If not null, copies its options into this variable.</param>
        </member>
        <member name="M:Au.Types.OptDebug.Reset">
            <summary>
            Resets all options. Copies from <see cref="P:Au.AOpt.Static.Debug"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OptDebug.Verbose">
            <summary>
            If true, some library functions may display more warnings and other info.
            If not explicitly set, the default value depends on the build configuration of the entry assymbly: true if Debug, false if Release.
            </summary>
        </member>
        <member name="M:Au.Types.OptDebug.DisableWarnings(System.String[])">
            <summary>
            Disables one or more run-time warnings.
            </summary>
            <param name="warningsWild">One or more warnings as case-insensitive wildcard strings. See <see cref="M:Au.AExtString.Like(System.String,System.String,System.Boolean)"/>.</param>
            <remarks>
            Adds the strings to an internal list. When <see cref="M:Au.AStatic.PrintWarning(System.String,System.Int32,System.String)"/> is called, it looks in the list. If finds the warning in the list, does not show the warning.
            It's easy to auto-restore warnings with 'using', like in the second example. Restoring is optional.
            </remarks>
            <example>
            This code at the very start of script disables two warnings in all threads.
            <code><![CDATA[
            AOpt.Static.Debug.DisableWarnings("*part of warning 1 text*", "*part of warning 2 text*");
            ]]></code>
            Temporarily disable all warnings in this thread.
            <code><![CDATA[
            AOpt.Debug.Verbose = true;
            PrintWarning("one");
            using(AOpt.Debug.DisableWarnings("*")) {
            	PrintWarning("two");
            }
            PrintWarning("three");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.OptDebug.IsWarningDisabled(System.String)">
            <summary>
            Returns true if the specified warning text matches a wildcard string added with <see cref="M:Au.Types.OptDebug.DisableWarnings(System.String[])"/>.
            </summary>
            <param name="text">Warning text. Case-insensitive.</param>
        </member>
        <member name="T:Au.Types.OptDebug.RestoreWarnings">
            <summary>Infrastructure.</summary>
        </member>
        <member name="M:Au.Types.OptDebug.RestoreWarnings.Dispose">
            <summary>Restores warnings.</summary>
        </member>
        <member name="T:Au.Types.OptMouse">
            <summary>
            Options for functions of class <see cref="T:Au.AMouse"/>.
            </summary>
            <remarks>
            Total <c>Click(x, y)</c> time is: mouse move + <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/> + button down + <see cref="P:Au.Types.OptMouse.ClickSpeed"/> + button down + <see cref="P:Au.Types.OptMouse.ClickSpeed"/> + <see cref="P:Au.Types.OptMouse.ClickSleepFinally"/>.
            </remarks>
            <seealso cref="P:Au.AOpt.Mouse"/>
            <seealso cref="P:Au.AOpt.Static.Mouse"/>
        </member>
        <member name="M:Au.Types.OptMouse.#ctor(Au.Types.OptMouse)">
            <summary>
            Initializes this instance with default values or values copied from another instance.
            </summary>
            <param name="cloneOptions">If not null, copies its options into this variable.</param>
        </member>
        <member name="M:Au.Types.OptMouse.LibCopyOrDefault(Au.Types.OptMouse)">
            <summary>
            Copies options from o, or sets default if o==null. Like ctor does.
            </summary>
        </member>
        <member name="M:Au.Types.OptMouse.Reset">
            <summary>
            Resets all options. Copies from <see cref="P:Au.AOpt.Static.Mouse"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OptMouse.ClickSpeed">
            <summary>
            How long to wait (milliseconds) after sending each mouse button down or up event (2 events for click, 4 for double-click).
            Default: 20. Valid values: 0 - 1000 (1 s). Valid values for <see cref="P:Au.AOpt.Static.Mouse"/>: 0 - 100 (1 s).
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.Types.OptMouse.MoveSpeed">
            <summary>
            If not 0, makes mouse movements slower, not instant.
            Default: 0. Valid values: 0 (instant) - 10000 (slowest). Valid values for <see cref="P:Au.AOpt.Static.Mouse"/>: 0 - 100.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Used by <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>, <see cref="M:Au.AMouse.Click(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and other functions that generate mouse movement events, except <see cref="M:Au.AMouse.MoveRecorded(System.String,System.Double)"/>.
            It is not milliseconds or some other unit. It adds intermediate mouse movements and small delays when moving the mouse cursor to the specified point. The speed also depends on the distance.
            Value 0 (default) does not add intermediate mouse movements. Adds at least 1 if some mouse buttons are pressed. Value 1 adds at least 1 intermediate mouse movement. Values 10-50 are good for visually slow movements.
            </remarks>
        </member>
        <member name="P:Au.Types.OptMouse.ClickSleepFinally">
            <summary>
            How long to wait (milliseconds) before a 'mouse click' or 'mouse wheel' function returns.
            Default: 10. Valid values: 0 - 10000 (10 s). Valid values for <see cref="P:Au.AOpt.Static.Mouse"/>: 0 - 100.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            The 'click' functions also sleep <see cref="P:Au.Types.OptMouse.ClickSpeed"/> ms after button down and up. Default <b>ClickSpeed</b> is 20, default <b>ClickSleepFinally</b> is 10, therefore default click time without mouse-move is 20+20+10=50.
            </remarks>
        </member>
        <member name="P:Au.Types.OptMouse.MoveSleepFinally">
            <summary>
            How long to wait (milliseconds) after moving the mouse cursor. Used in 'move+click' functions too.
            Default: 10. Valid values: 0 - 1000 (1 s). Valid values for <see cref="P:Au.AOpt.Static.Mouse"/>: 0 - 100.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Used by <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> (finally), <see cref="M:Au.AMouse.Click(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> (between moving and clicking) and other functions that generate mouse movement events.
            </remarks>
        </member>
        <member name="P:Au.Types.OptMouse.Relaxed">
            <summary>
            Make some functions less strict (throw less exceptions etc).
            Default: false.
            </summary>
            <remarks>
            This option is used by these functions:
            - <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>, <see cref="M:Au.AMouse.Click(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and other functions that move the cursor (mouse pointer):
            <br/>false - throw exception if cannot move the cursor to the specified x y. For example it the x y is not in screen.
            <br/>true - try to move anyway. Don't throw exception, regardless of the final cursor position (which probably will be at a screen edge).
            - <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>, <see cref="M:Au.AMouse.Click(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and other functions that move the cursor (mouse pointer):
            <br/>false - before moving the cursor, wait while a mouse button is pressed by the user or another thread. It prevents an unintended drag-drop.
            <br/>true - do not wait.
            - <see cref="M:Au.AMouse.Click(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and other functions that click or press a mouse button using window coordinates:
            <br/>false - don't allow to click in another window. If need, activate the specified window (or its top-level parent). If that does not help, throw exception. However if the window is a control, allow x y anywhere in its top-level parent window.
            <br/>true - allow to click in another window. Don't activate the window and don't throw exception.
            </remarks>
        </member>
        <member name="T:Au.Types.OptKey">
            <summary>
            Options for functions of class <see cref="T:Au.AKeys"/>.
            Some options also are used with <see cref="T:Au.AClipboard"/> functions that send keys (Ctrl+V etc).
            </summary>
            <seealso cref="P:Au.AOpt.Key"/>
            <seealso cref="P:Au.AOpt.Static.Key"/>
        </member>
        <member name="M:Au.Types.OptKey.#ctor(Au.Types.OptKey)">
            <summary>
            Initializes this instance with default values or values copied from another instance.
            </summary>
            <param name="cloneOptions">If not null, copies its options into this variable.</param>
        </member>
        <member name="M:Au.Types.OptKey.LibCopyOrDefault(Au.Types.OptKey)">
            <summary>
            Copies options from o, or sets default if o==null. Like ctor does.
            </summary>
        </member>
        <member name="M:Au.Types.OptKey.Reset">
            <summary>
            Resets all options. Copies from <see cref="P:Au.AOpt.Static.Key"/>.
            </summary>
        </member>
        <member name="M:Au.Types.OptKey.LibGetHookOptionsOrThis(Au.AWnd)">
            <summary>
            Returns this variable or OptKey cloned from this variable and possibly modified by Hook.
            </summary>
            <param name="wFocus">The focused or active window. Use Lib.GetWndFocusedOrActive().</param>
        </member>
        <member name="P:Au.Types.OptKey.TextSpeed">
            <summary>
            How long to wait (milliseconds) between pressing and releasing each character key. Used by <see cref="M:Au.AKeys.Text(System.String)"/>, <see cref="M:Au.AKeys.Key(System.Object[])"/> (arguments of type <see cref="T:Au.Types.KText"/>) and similar functions.
            Default: 0. Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.AOpt.Static.Key"/>: 0 - 10.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Not used for 'keys' parameters. See <see cref="P:Au.Types.OptKey.KeySpeed"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.KeySpeed">
            <summary>
            How long to wait (milliseconds) between pressing and releasing each key. Used by <see cref="M:Au.AKeys.Key(System.Object[])"/> (string arguments) and similar functions.
            Default: 1. Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.AOpt.Static.Key"/>: 0 - 10.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Not used for 'text' parameters. See <see cref="P:Au.Types.OptKey.TextSpeed"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.KeySpeedClipboard">
            <summary>
            How long to wait (milliseconds) between sending Ctrl+V and Ctrl+C keys of clipboard functions (paste, copy).
            Default: 5. Valid values: 0 - 1000 (1 second). Valid values for <see cref="P:Au.AOpt.Static.Key"/>: 0 - 50.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            In most apps copy/paste works without this delay. Known apps that need it: Internet Explorer's address bar, BlueStacks.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.SleepFinally">
            <summary>
            How long to wait (milliseconds) before a 'send keys or text' function returns.
            Default: 10. Valid values: 0 - 10000 (10 seconds). Valid values for <see cref="P:Au.AOpt.Static.Key"/>: 0 - 100.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Not used by <see cref="M:Au.AClipboard.CopyText(System.Boolean,Au.Types.OptKey)"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.TextOption">
            <summary>
            How functions send text to the active window (keys, clipboard, etc).
            Default: <see cref="F:Au.Types.KTextOption.Characters"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OptKey.PasteLength">
            <summary>
            To send text use clipboard (like with option <see cref="F:Au.Types.KTextOption.Paste"/>) if text length is &gt;= this value.
            Default: 300.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.Types.OptKey.PasteEnter">
            <summary>
            When pasting text that ends with newline characters, remove the last newline and after pasting send the Enter key.
            Default: false.
            </summary>
            <remarks>
            Some apps remove the last newline when pasting. For example Word, WordPad, OpenOffice, LibreOffice, standard rich text controls. This option is a workaround.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.RestoreClipboard">
            <summary>
            Whether to restore clipboard data when copying or pasting text.
            Default: true.
            By default restores only text. See also <see cref="P:Au.Types.OptKey.RestoreClipboardAllFormats"/>, <see cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OptKey.RestoreClipboardAllFormats">
            <summary>
            When copying or pasting text, restore clipboard data of all formats that are possible to restore.
            Default: false - restore only text.
            </summary>
            <remarks>
            Restoring data of all formats set by some apps can be slow or cause problems. More info: <see cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>.
            
            This property is static, not thread-static. It should be set (if need) at the very start of script and not changed later.
            </remarks>
            <seealso cref="P:Au.Types.OptKey.RestoreClipboard"/>
            <seealso cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>
        </member>
        <member name="P:Au.Types.OptKey.RestoreClipboardExceptFormats">
            <summary>
            When copying or pasting text, and <see cref="P:Au.Types.OptKey.RestoreClipboardAllFormats"/> is true, do not restore clipboard data of these formats.
            Default: null.
            </summary>
            <remarks>
            To restore clipboard data, the copy/paste functions at first get clipboard data. Getting data of some formats set by some apps can be slow (100 ms or more) or cause problems (the app can change something in its window or even show a dialog).
            It also depends on whether this is the first time the data is being retrieved. The app can render data on demand, when some app is retrieving it from the clipboard first time; then can be slow etc.
            
            You can use function <see cref="M:Au.Types.OptKey.PrintClipboard"/> to see format names and get-data times.
            
            There are several kinds of clipboard formats - registered, standard, private and display. Only registered formats have string names. For standard formats use API contant names, like "CF_WAVE". Private, display and metafile formats are never restored.
            These formats are never restored: CF_METAFILEPICT, CF_ENHMETAFILE, CF_PALETTE, CF_OWNERDISPLAY, CF_DSPx formats, CF_GDIOBJx formats, CF_PRIVATEx formats. Some other formats too, but they are automatically synthesized from other formats if need. Also does not restore if data size is 0 or &gt; 10 MB.
            
            This property is static, not thread-static. It should be set (if need) at the very start of script and not changed later.
            </remarks>
            <seealso cref="P:Au.Types.OptKey.RestoreClipboard"/>
            <seealso cref="M:Au.Types.OptKey.PrintClipboard"/>
        </member>
        <member name="M:Au.Types.OptKey.PrintClipboard">
            <summary>
            Prints some info about current clipboard data.
            </summary>
            <remarks>
            Shows this info in the output, for each clipboard format: format name, time spent to get data (microseconds), data size (bytes), and whether this format would be restored (depends on <see cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>).
            <note>Copy something to the clipboard each time before calling this function. Don't use <see cref="M:Au.AClipboard.CopyText(System.Boolean,Au.Types.OptKey)"/> and don't call this function in loop. Else it shows small times.</note>
            The time depends on app, etc. More info: <see cref="P:Au.Types.OptKey.RestoreClipboardExceptFormats"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.NoModOff">
            <summary>
            When starting to send keys or text, don't release modifier keys.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.Types.OptKey.NoCapsOff">
            <summary>
            When starting to send keys or text, don't turn off CapsLock.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.Types.OptKey.NoBlockInput">
            <summary>
            While sending or pasting keys or text, don't block user-pressed keys.
            Default: false.
            </summary>
            <remarks>
            If false (default), user-pressed keys are sent afterwards. If true, user-pressed keys can be mixed with script-pressed keys, which is particularly dangerous when modifier keys are mixed (and combined) with non-modifier keys.
            </remarks>
        </member>
        <member name="P:Au.Types.OptKey.Hook">
            <summary>
            Callback function that can modify options of 'send keys or text' functions depending on active window etc.
            Default: null.
            </summary>
            <remarks>
            The callback function is called by <see cref="M:Au.AStatic.Key(System.Object[])"/>, <see cref="M:Au.AStatic.Text(System.String)"/>, <see cref="M:Au.AKeys.Send(System.Boolean)"/>, <see cref="M:Au.AClipboard.PasteText(System.String,Au.Types.OptKey)"/> and similar functions. Not called by <see cref="M:Au.AClipboard.CopyText(System.Boolean,Au.Types.OptKey)"/>.
            </remarks>
            <seealso cref="T:Au.Types.KOHookData"/>
        </member>
        <member name="T:Au.Types.KOHookData">
            <summary>
            Parameter type of the <see cref="P:Au.Types.OptKey.Hook"/> callback function.
            </summary>
        </member>
        <member name="F:Au.Types.KOHookData.opt">
            <summary>
            Options used by the 'send keys or text' function. The callback function can modify them, except Hook, NoModOff, NoCapsOff, NoBlockInput.
            </summary>
        </member>
        <member name="F:Au.Types.KOHookData.w">
            <summary>
            The focused control. If there is no focused control - the active window. Use <c>w.Window</c> to get top-level window; if <c>w.Window == w</c>, <b>w</b> is the active window, else the focused control. The callback function is not called if there is no active window.
            </summary>
        </member>
        <member name="T:Au.Types.KTextOption">
            <summary>
            How functions send text.
            See <see cref="P:Au.Types.OptKey.TextOption"/>.
            </summary>
            <remarks>
            There are three ways to send text to the active app using keys: 1. Characters (default) - use special key code VK_PACKET. 2. Keys - press keybord keys. 3. Paste - use the clipboard and Ctrl+V.
            Most but not all apps support all three ways. Most Unicode characters cannot be sent with <b>Keys</b>.
            Depending on text, the 'send text' functions may use other method than specified. For some characters or for whole text. More info below.
            Many apps don't support Unicode surrogate pairs sent as keys. If the text contains such characters, is used <b>Paste</b> instead of other options (implicitly). These characters are rarely used.
            </remarks>
        </member>
        <member name="F:Au.Types.KTextOption.Characters">
            <summary>
            Send text characters using special key code VK_PACKET.
            Few apps don't support it.
            This option is default.
            Supports most Unicode characters.
            For newlines sends key Enter, because VK_PACKET often does not work well.
            </summary>
        </member>
        <member name="F:Au.Types.KTextOption.Keys">
            <summary>
            Send text keys, with Shift or other modifiers where need, depending on the keyboard layout of the active window. The numpad keys are not used.
            All apps support it.
            Some characters cannot be easily typed using the keyboard. For example most non-ASCII characters. Sends these characters like with the <b>Characters</b> option.
            </summary>
        </member>
        <member name="F:Au.Types.KTextOption.Paste">
            <summary>
            Paste text using the clipboard and Ctrl+V.
            Few apps don't support it.
            This option is recommended for long text, because other ways then are too slow.
            Other options are unreliable when text length is more than 4000 or 5000 and the target app is too slow to process sent characters. Then <see cref="P:Au.Types.OptKey.TextSpeed"/> can help.
            Also, other options are unreliable when the target app modifies typed text, for example has such features as auto-complete or auto-indent. However some apps modify even pasted text, for example trim the last newline.
            When pasting text, previous clipboard data is lost. Only text is restored.
            </summary>
        </member>
        <member name="T:Au.Types.OptWaitFor">
            <summary>
            Options for 'wait for' functions.
            </summary>
            <seealso cref="P:Au.AOpt.WaitFor"/>
            <seealso cref="M:Au.AWaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/>
            <seealso cref="T:Au.AWaitFor.Loop"/>
        </member>
        <member name="P:Au.Types.OptWaitFor.Period">
            <summary>
            The sleep time between checking the wait condition. Milliseconds.
            Default: 10. Valid values: 1-1000.
            </summary>
            <remarks>
            Most 'wait for' functions of this library use <see cref="T:Au.AWaitFor.Loop"/>, which repeatedly checks the wait condition and sleeps (waits) several ms. This property sets the initial sleep time, which then is incremented by <b>Period</b>/10 ms (default 1 ms) in each loop until reaches <b>Period</b>*50 (default 500 ms).
            This property makes the response time shorter or longer. If &lt;10, makes it shorter (faster response), but increases CPU usage; if &gt;10, makes it longer (slower response).
            </remarks>
            <seealso cref="P:Au.AWaitFor.Loop.Period"/>
            <example>
            <code><![CDATA[
            AOpt.WaitFor.Period = 100;
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Types.OptWaitFor.DoEvents">
            <summary>
            Use <see cref="M:Au.ATime.SleepDoEvents(System.Int32)"/> instead of <see cref="M:Au.ATime.Sleep(System.Int32)"/>.
            Default: false.
            </summary>
            <remarks>
            Use this property when need to process Windows messages, events, hooks, timers, etc while waiting. More info: <see cref="M:Au.ATime.SleepDoEvents(System.Int32)"/>.
            </remarks>
            <seealso cref="M:Au.AWaitFor.MessagesAndCondition(System.Double,System.Func{System.Boolean})"/>
            <example>
            <code><![CDATA[
            AOpt.WaitFor.DoEvents = true;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.OptWaitFor.#ctor(System.Int32,System.Boolean)">
            
        </member>
        <member name="M:Au.Types.OptWaitFor.Reset">
            <summary>
            Resets all options.
            </summary>
        </member>
        <member name="M:Au.Types.OptWaitFor.op_Implicit(System.Int32)~Au.Types.OptWaitFor">
            <summary>
            Implicit conversion from int. Sets <see cref="P:Au.Types.OptWaitFor.Period"/>.
            </summary>
        </member>
        <member name="M:Au.Types.OptWaitFor.op_Implicit(System.Boolean)~Au.Types.OptWaitFor">
            <summary>
            Implicit conversion from bool. Sets <see cref="P:Au.Types.OptWaitFor.DoEvents"/>.
            </summary>
        </member>
        <member name="T:Au.Types.OTRestoreMouse">
            <summary>Used by <see cref="P:Au.AOpt.Temp.Mouse"/>.</summary>
        </member>
        <member name="M:Au.Types.OTRestoreMouse.Dispose">
            <summary>Restores options.</summary>
        </member>
        <member name="T:Au.Types.OTRestoreKey">
            <summary>Used by <see cref="P:Au.AOpt.Temp.Key"/>.</summary>
        </member>
        <member name="M:Au.Types.OTRestoreKey.Dispose">
            <summary>Restores options.</summary>
        </member>
        <member name="T:Au.Types.NoDoc">
            <summary>
            In DocFX-generated help files removes documentation and auto-generated links in TOC and class pages.
            </summary>
        </member>
        <member name="T:Au.Types.PSFormat">
            <summary>
            Used with <see cref="T:Au.Types.ParamStringAttribute"/> to specify string parameter format.
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.None">
            
        </member>
        <member name="F:Au.Types.PSFormat.AKeys">
            <summary>
            Keys. See <see cref="M:Au.AKeys.Key(System.Object[])"/>.
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.AWildex">
            <summary>
            [Wildcard expression](xref:wildcard_expression).
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.ARegex">
            <summary>
            PCRE regular expression.
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.ARegexReplacement">
            <summary>
            PCRE regular expression replacement string.
            </summary>
        </member>
        <member name="F:Au.Types.PSFormat.Regex">
            <summary>
            .NET regular expression.
            </summary>
        </member>
        <member name="T:Au.Types.ParamStringAttribute">
            <summary>
            Specifies that the function parameter that has this attribute is a string of the specified format, for example regular expression.
            Code editors should help to create correct string arguments: provide tools or reference, show errors.
            </summary>
        </member>
        <member name="M:Au.Types.ParamStringAttribute.#ctor(Au.Types.PSFormat)">
            
        </member>
        <member name="P:Au.Types.ParamStringAttribute.Format">
            
        </member>
        <member name="T:Au.Types.SetAddRemove">
            <summary>
            Specifies whether to set, add or remove flags.
            </summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Set">
            <summary>Set flags = the specified value.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Add">
            <summary>Add the specified flags, don't change others.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Remove">
            <summary>Remove the specified flags, don't change others.</summary>
        </member>
        <member name="F:Au.Types.SetAddRemove.Xor">
            <summary>Toggle the specified flags, don't change others.</summary>
        </member>
        <member name="T:Au.Types.AuException">
            <summary>
            The base exception class used in this library.
            Thrown when something fails and there is no better exception type for that failure.
            </summary>
            <remarks>
            Some constructors support Windows API error code. Then <see cref="P:Au.Types.AuException.Message"/> will contain its error description.
            If the string passed to the constructor starts with "*", replaces the "*" with "Failed to ". If does not end with ".", appends ".".
            </remarks>
        </member>
        <member name="M:Au.Types.AuException.#ctor">
            <summary>
            Sets Message = "Failed.".
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.String)">
            <summary>
            Sets Message = message.
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32)">
            <summary>
            Sets Message = "Failed. " + ALastError.MessageFor(winApiErrorCode).
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : ALastError.Code.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32,System.String)">
            <summary>
            Sets Message = message + " " + ALastError.MessageFor(winApiErrorCode).
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : ALastError.Code.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.String,System.Exception)">
            <summary>
            Sets Message = message + "\r\n\t" + innerException.Message.
            Sets NativeErrorCode = 0.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>
            Sets Message = message + " " + ALastError.MessageFor(winApiErrorCode) + "\r\n\t" + innerException.Message.
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : ALastError.Code.
            </summary>
        </member>
        <member name="P:Au.Types.AuException.NativeErrorCode">
            <summary> Gets the Windows API error code. </summary>
        </member>
        <member name="P:Au.Types.AuException.Message">
            <summary> Gets error message. </summary>
        </member>
        <member name="F:Au.Types.AuException.FormattedMessage">
            <summary> String created by FormatMessage(), which should be called by the Message override if null. Initially null. </summary>
        </member>
        <member name="M:Au.Types.AuException.FormatMessage(System.String,System.String)">
            <summary>
            Formats error message. Sets and returns FormattedMessage.
            As base text, uses the text passed to the constructor (default "Failed.").
            If it starts with "*", replaces the "*" with "Failed to ".
            If it ends with "*", replaces the "*" with commonPostfix if it is not empty.
            If then the message does not end with ".", appends ".".
            If appendMessage is null, uses ALastError.MessageFor(NativeErrorCode) if NativeErrorCode not 0.
            If then appendMessage is not empty, appends " " and appendMessage.
            Also appends InnerException.Message in new tab-indented line if InnerException is not null.
            </summary>
        </member>
        <member name="M:Au.Types.AuException.ThrowIfHresultNot0(System.Int32,System.String)">
            <summary>
            If errorCode is not 0, throws AuException that includes the code and its message.
            More info: <see cref="M:Au.Types.AuException.FormatMessage(System.String,System.String)"/>.
            </summary>
            <param name="errorCode">Windows API error code or HRESULT.</param>
            <param name="message">Main message. The message of the error code will be appended to it.</param>
        </member>
        <member name="M:Au.Types.AuException.ThrowIfHresultNegative(System.Int32,System.String)">
            <summary>
            If errorCode is less than 0, throws AuException that includes the code and its message.
            More info: <see cref="M:Au.Types.AuException.FormatMessage(System.String,System.String)"/>.
            </summary>
            <param name="errorCode">Windows API error code or HRESULT.</param>
            <param name="message">Main message. The message of the error code will be appended to it.</param>
        </member>
        <member name="M:Au.Types.AuException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            
        </member>
        <member name="M:Au.Types.AuException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            
        </member>
        <member name="T:Au.Types.AuWndException">
            <summary>
            Exception thrown mostly by <see cref="T:Au.AWnd"/> functions.
            </summary>
            <remarks>
            Some constructors support Windows API error code. Then Message also will contain its error description.
            If error code ERROR_INVALID_WINDOW_HANDLE, Message also depends on whether the window handle is 0.
            If parameter <i>winApiErrorCode</i> is 0 or not used: if the window handle is invalid, uses ERROR_INVALID_WINDOW_HANDLE.
            If the string passed to the constructor starts with "*", replaces the "*" with "Failed to ". If ends with "*", replaces the "*" with " window.". If does not end with ".", appends ".".
            </remarks>
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(Au.AWnd)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            Sets Message = "Failed.".
            </summary>
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(Au.AWnd,System.String)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            </summary>
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(Au.AWnd,System.Int32)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? ALastError.Code : ERROR_INVALID_WINDOW_HANDLE).
            Sets Message = "Failed.".
            </summary>
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(Au.AWnd,System.Int32,System.String)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? ALastError.Code : ERROR_INVALID_WINDOW_HANDLE).
            </summary>
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(Au.AWnd,System.String,System.Exception)">
            <summary>
            Sets NativeErrorCode = w.IsAlive ? 0 : ERROR_INVALID_WINDOW_HANDLE.
            </summary>
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(Au.AWnd,System.Int32,System.String,System.Exception)">
            <summary>
            Sets NativeErrorCode = (winApiErrorCode != 0) ? winApiErrorCode : (w.IsAlive ? ALastError.Code : ERROR_INVALID_WINDOW_HANDLE).
            </summary>
        </member>
        <member name="P:Au.Types.AuWndException.Window">
            <summary> Gets the window passed to the constructor. </summary>
        </member>
        <member name="P:Au.Types.AuWndException.Message">
            <summary> Gets error message. </summary>
        </member>
        <member name="M:Au.Types.AuWndException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            
        </member>
        <member name="M:Au.Types.AuWndException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            
        </member>
        <member name="T:Au.Types.NotFoundException">
            <summary>
            Functions that search for an object can throw this exception when not found.
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor">
            <summary>
            Sets Message = "Not found.".
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor(System.String)">
            <summary>
            Sets Message = message.
            </summary>
        </member>
        <member name="M:Au.Types.NotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            
        </member>
        <member name="T:Au.Types.Coord">
            <summary>
            Contains x or y coordinate. Used for parameters of functions like AMouse.Move, AWnd.Move.
            Allows to easily specify coordinates of these types: normal, reverse (from right or bottom of a rectangle), fractional (fraction of width or height of a rectangle), null.
            Also has functions to convert to normal coodinates.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Type">
            <summary>
            Value type.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Value">
            <summary>
            Non-fraction value.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.FractionValue">
            <summary>
            Fraction value.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.IsEmpty">
            <summary>
            Returns true if Type == None (when assigned default(Coord)).
            </summary>
        </member>
        <member name="M:Au.Types.Coord.op_Implicit(System.Int32)~Au.Types.Coord">
            <summary>
            Creates Coord of Normal type.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.Reverse(System.Int32)">
            <summary>
            Creates Coord of Reverse type.
            Value 0 is at the right or bottom, and does not belong to the rectangle. Positive values are towards left or top.
            </summary>
        </member>
        <member name="M:Au.Types.Coord.Fraction(System.Double)">
            <summary>
            Creates Coord of Fraction type.
            Value 0.0 is the left or top of the rectangle. Value 1.0 is the right or bottom of the rectangle. Values &lt;0.0 and &gt;=1.0 are outside of the rectangle.
            </summary>
        </member>
        <member name="P:Au.Types.Coord.Center">
            <summary>
            Returns <c>Fraction(0.5)</c>.
            </summary>
            <seealso cref="M:Au.Types.Coord.Fraction(System.Double)"/>
        </member>
        <member name="P:Au.Types.Coord.Max">
            <summary>
            Returns <c>Reverse(0)</c>.
            This point will be outside of the rectangle. See also <see cref="P:Au.Types.Coord.MaxInside"/>.
            </summary>
            <seealso cref="M:Au.Types.Coord.Reverse(System.Int32)"/>
        </member>
        <member name="P:Au.Types.Coord.MaxInside">
            <summary>
            Returns <c>Reverse(1)</c>.
            This point will be inside of the rectangle, at the very right or bottom, assuming the rectangle is not empty.
            </summary>
            <seealso cref="M:Au.Types.Coord.Reverse(System.Int32)"/>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInRect(Au.Types.Coord,Au.Types.Coord,Au.Types.RECT,System.Boolean,System.Boolean)">
            <summary>
            Converts fractional/reverse coordinates to normal coordinates in a rectangle.
            </summary>
            <param name="x">X coordinate relative to r.</param>
            <param name="y">Y coordinate relative to r.</param>
            <param name="r">The rectangle.</param>
            <param name="widthHeight">Use only width and height of r. If false (default), the function adds r offset (left and top).</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center. Not used with widthHeight.</param>
        </member>
        <member name="M:Au.Types.Coord.NormalizeInWindow(Au.Types.Coord,Au.Types.Coord,Au.AWnd,System.Boolean,System.Boolean)">
            <summary>
            Returns normal coordinates relative to the client area of a window. Converts fractional/reverse coordinates etc.
            </summary>
            <param name="x">X coordinate relative to the client area of w.</param>
            <param name="y">Y coordinate relative to the client area of w.</param>
            <param name="w">The window.</param>
            <param name="nonClient">x y are relative to the entire w rectangle, not to its client area.</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center.</param>
        </member>
        <member name="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen,System.Boolean,System.Boolean)">
            <summary>
            Returns normal coordinates relative to the primary screen. Converts fractional/reverse coordinates etc.
            </summary>
            <param name="x">X coordinate relative to the specified screen (default - primary).</param>
            <param name="y">Y coordinate relative to the specified screen (default - primary).</param>
            <param name="workArea">x y are relative to the work area.</param>
            <param name="screen">If used, x y are relative to this screen. Default - primary screen.</param>
            <param name="widthHeight">Use only width and height of the screen rectangle. If false, the function adds its offset (left and top, which can be nonzero if using the work area or a non-primary screen).</param>
            <param name="centerIfEmpty">If x or y is default(Coord), use Coord.Center.</param>
        </member>
        <member name="M:Au.Types.Coord.ToString">
            
        </member>
        <member name="T:Au.Types.CoordType">
            <summary>
            <see cref="T:Au.Types.Coord"/> variable value type.
            </summary>
        </member>
        <member name="F:Au.Types.CoordType.None">
            <summary>
            No value. The variable is default(Coord).
            </summary>
        </member>
        <member name="F:Au.Types.CoordType.Normal">
            <summary>
            <see cref="P:Au.Types.Coord.Value"/> is pixel offset from left or top of a rectangle.
            </summary>
        </member>
        <member name="F:Au.Types.CoordType.Reverse">
            <summary>
            <see cref="P:Au.Types.Coord.Value"/> is pixel offset from right or bottom of a rectangle, towards left or top.
            </summary>
        </member>
        <member name="F:Au.Types.CoordType.Fraction">
            <summary>
            <see cref="P:Au.Types.Coord.FractionValue"/> is fraction of a rectangle, where 0.0 is left or top, and 1.0 is right or bottom (outside of the rectangle).
            </summary>
        </member>
        <member name="T:Au.Types.PopupXY">
            <summary>
            Can be used to specify coordinates for various popup windows and other UI objects.
            </summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord})~Au.Types.PopupXY">
            <summary>Specifies position relative to the work area of the primary screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,System.Boolean})~Au.Types.PopupXY">
            <summary>Specifies position relative to the primary screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,Au.AScreen})~Au.Types.PopupXY">
            <summary>Specifies position relative to the work area of the specified screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen})~Au.Types.PopupXY">
            <summary>Specifies position relative to the specified screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,Au.AScreen,System.Boolean})~Au.Types.PopupXY">
            <summary>Specifies position relative to the specified screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.Types.POINT)~Au.Types.PopupXY">
            <summary>Specifies position relative to the primary screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.AScreen)~Au.Types.PopupXY">
            <summary>Specifies the center of the work area of the specified screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.AScreen,System.Boolean})~Au.Types.PopupXY">
            <summary>Specifies the center of the specified screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{System.Boolean,Au.AScreen})~Au.Types.PopupXY">
            <summary>Specifies the center of the specified screen or its work area.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.Types.RECT,Au.Types.Coord,Au.Types.Coord})~Au.Types.PopupXY">
            <summary>Specifies position in the specified rectangle which is relative to the primary screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.Types.RECT)~Au.Types.PopupXY">
            <summary>Specifies the center of the specified rectangle which is relative to the primary screen.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{Au.AWnd,Au.Types.Coord,Au.Types.Coord})~Au.Types.PopupXY">
            <summary>Specifies position in the specified window.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(Au.AWnd)~Au.Types.PopupXY">
            <summary>Specifies the center of the specified window.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.Windows.Forms.Control)~Au.Types.PopupXY">
            <summary>Specifies the center of the specified control or form.</summary>
        </member>
        <member name="M:Au.Types.PopupXY.op_Implicit(System.ValueTuple{System.Windows.Forms.Control,Au.Types.Coord,Au.Types.Coord})~Au.Types.PopupXY">
            <summary>Specifies position in the specified control or form.</summary>
        </member>
        <member name="P:Au.Types.PopupXY.Mouse">
            <summary>
            Gets point coordinates below mouse cursor, for showing a tooltip-like popup.
            </summary>
        </member>
        <member name="M:Au.Types.PopupXY.GetScreen">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> specified in <see cref="F:Au.Types.PopupXY.screen"/>. If not specified, gets that of the screen that contains the specified point.
            </summary>
        </member>
        <member name="T:Au.Types.AnyWnd">
            <summary>
            Window handle.
            Used for function parameters where the function needs a window handle as <see cref="T:Au.AWnd"/> but also allows to pass a variable of any of these types: System.Windows.Forms.Control (Form or any control class), System.Windows.Window (WPF window), IntPtr (window handle).
            </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(Au.AWnd)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type AWnd. </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.IntPtr)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type AWnd. </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.Windows.Forms.Control)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type System.Windows.Forms.Control (Form or any control class). </summary>
        </member>
        <member name="M:Au.Types.AnyWnd.op_Implicit(System.Windows.Window)~Au.Types.AnyWnd">
            <summary> Assignment of a value of type System.Windows.Window (WPF window). </summary>
        </member>
        <member name="P:Au.Types.AnyWnd.Wnd">
            <summary>
            Gets the window or control handle as AWnd.
            Returns default(AWnd) if not assigned.
            </summary>
        </member>
        <member name="P:Au.Types.AnyWnd.IsEmpty">
            <summary>
            true if this is default(AnyWnd).
            </summary>
        </member>
        <member name="T:Au.Types.DStringList">
            <summary>
            Used for function parameters to specify multiple strings.
            Contains a string like "One|Two|Three" or string[] or List&lt;string&gt;. Has implicit conversion operators from these types.
            </summary>
        </member>
        <member name="F:Au.Types.DStringList.Value">
            <summary>
            The raw value.
            </summary>
        </member>
        <member name="M:Au.Types.DStringList.op_Implicit(System.String)~Au.Types.DStringList">
            <summary> Assignment of a value of type string. </summary>
        </member>
        <member name="M:Au.Types.DStringList.op_Implicit(System.String[])~Au.Types.DStringList">
            <summary> Assignment of a value of type string[]. </summary>
        </member>
        <member name="M:Au.Types.DStringList.op_Implicit(System.Collections.Generic.List{System.String})~Au.Types.DStringList">
            <summary> Assignment of a value of type List&lt;string&gt;. </summary>
        </member>
        <member name="M:Au.Types.DStringList.ToArray(System.Char)">
            <summary>
            Converts the value to string[].
            </summary>
            <param name="separator">If the value is string, use this character to split it. Default '|'.</param>
            <remarks>
            If the value was string or List, converts to string[] and stores the string[] in <b>Value</b>. If null, returns empty array.
            </remarks>
        </member>
        <member name="T:Au.Types.LPARAM">
            <summary>
            Similar to IntPtr (can be 32-bit or 64-bit), but more useful for usually-non-pointer values, eg wParam/lParam of SendMessage.
            Unlike IntPtr:
            	Has implicit casts from most integral types. And explicit casts to.
            	Does not check overflow when casting from uint etc. IntPtr throws exception on overflow, which can create bugs.
            </summary>
            <remarks>
            There is no struct WPARAM. Use LPARAM instead, because it is the same in all cases except when casting to long or ulong (ambigous signed/unsigned).
            There is no cast operators for enum. When need, cast through int or uint. For AWnd cast through IntPtr.
            </remarks>
        </member>
        <member name="M:Au.Types.LPARAM.Equals(Au.Types.LPARAM)">
            <summary>
            Returns true if other == this.
            Implements IEquatable. Prevents boxing when used as a key of a collection.
            </summary>
        </member>
        <member name="M:Au.Types.LPARAM.CompareTo(Au.Types.LPARAM)">
            <summary>
            Implements IComparable. It allows to sort a collection.
            </summary>
        </member>
        <member name="T:Au.Types.POINT">
            <summary>
            Point coordinates x y.
            </summary>
        </member>
        <member name="M:Au.Types.POINT.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,System.Boolean})~Au.Types.POINT">
            <summary>Specifies position relative to the primary screen or its work area. Calls <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen,System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Au.Types.POINT.op_Implicit(System.ValueTuple{Au.Types.Coord,Au.Types.Coord,Au.AScreen,System.Boolean})~Au.Types.POINT">
            <summary>Specifies position relative to the specified screen or its work area. Calls <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen,System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Au.Types.POINT.op_Implicit(System.ValueTuple{Au.Types.RECT,Au.Types.Coord,Au.Types.Coord})~Au.Types.POINT">
            <summary>Specifies position in the specified rectangle which is relative to the primary screen. Calls <see cref="M:Au.Types.Coord.NormalizeInRect(Au.Types.Coord,Au.Types.Coord,Au.Types.RECT,System.Boolean,System.Boolean)"/>.</summary>
        </member>
        <member name="M:Au.Types.POINT.Offset(System.Int32,System.Int32)">
            <summary>Adds x and y to this.x and this.y.</summary>
        </member>
        <member name="M:Au.Types.POINT.op_Addition(Au.Types.POINT,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Returns <c>new POINT(p.x + d.x, p.y + d.y)</c>.</summary>
        </member>
        <member name="T:Au.Types.SIZE">
            <summary>
            Width and height.
            </summary>
        </member>
        <member name="M:Au.Types.SIZE.op_Addition(Au.Types.SIZE,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Returns <c>new SIZE(z.width + d.x, z.height + d.y)</c>.</summary>
        </member>
        <member name="T:Au.Types.RECT">
            <summary>
            Rectangle coordinates left top right bottom.
            </summary>
            <remarks>
            This type can be used with Windows API functions. The .NET <b>Rectangle</b> etc can't, because their fields are different.
            Has implicit conversions from/to <b>Rectangle</b> and <b>RectangleF</b>.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes this instance.
            </summary>
            <param name="left"></param>
            <param name="top"></param>
            <param name="rightOrWidth">right or width, depending on <i>useWidthHeight</i>.</param>
            <param name="bottomOrHeight">bottom or height, depending on <i>useWidthHeight</i>.</param>
            <param name="useWidthHeight">If true (default), <i>rightOrWidth</i>/<i>bottomOrHeight</i> are width/height. Else right/bottom.</param>
        </member>
        <member name="M:Au.Types.RECT.Set(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets fields like the constructor <see cref="M:Au.Types.RECT.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Is0">
            <summary>
            Returns true if all fields == 0.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.IsEmpty">
            <summary>
            Returns true if the rectangle is empty or invalid: <c>right&lt;=left || bottom&lt;=top;</c>
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Width">
            <summary>
            Gets or sets width.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.Height">
            <summary>
            Gets or sets height.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.CenterX">
            <summary>
            Gets horizontal center.
            </summary>
        </member>
        <member name="P:Au.Types.RECT.CenterY">
            <summary>
            Gets vertical center.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(System.Int32,System.Int32)">
            <summary>
            Returns true if this rectangle contains the specified point.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(Au.Types.POINT)">
            <summary>
            Returns true if this rectangle contains the specified point.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Contains(Au.Types.RECT)">
            <summary>
            Returns true if this rectangle contains entire specified rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Inflate(System.Int32,System.Int32)">
            <summary>
            Makes this rectangle bigger or smaller: <c>left-=dx; right+=dx; top-=dy; bottom+=dy;</c>
            Use negative dx/dy to make the rectangle smaller. Note: too big negative dx/dy can make it invalid (right&lt;left or bottom&lt;top).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Intersect(Au.Types.RECT)">
            <summary>
            Replaces this rectangle with the intersection of itself and the specified rectangle.
            Returns true if the rectangles intersect.
            If they don't intersect, makes this RECT empty (IsEmpty would return true).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Intersect(Au.Types.RECT,Au.Types.RECT)">
            <summary>
            Returns the intersection rectangle of two rectangles.
            If they don't intersect, returns empty rectangle (IsEmpty would return true).
            </summary>
        </member>
        <member name="M:Au.Types.RECT.IntersectsWith(Au.Types.RECT)">
            <summary>
            Returns true if this rectangle and another rectangle intersect.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Offset(System.Int32,System.Int32)">
            <summary>
            Moves this rectangle by the specified offsets: <c>left+=dx; right+=dx; top+=dy; bottom+=dy;</c>
            Negative dx moves to the left. Negative dy moves up.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Union(Au.Types.RECT)">
            <summary>
            Replaces this rectangle with the union of itself and the specified rectangle.
            Union is the smallest rectangle that contains two full rectangles.
            Returns true if finally this rectangle is not empty.
            If either rectangle is empty (Width or Height is &lt;=0), the result is another rectangle. If both empty - empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Union(Au.Types.RECT,Au.Types.RECT)">
            <summary>
            Returns the union of two rectangles.
            Union is the smallest rectangle that contains two full rectangles.
            If either rectangle is empty (Width or Height is &lt;=0), the result is another rectangle. If both empty - empty rectangle.
            </summary>
        </member>
        <member name="M:Au.Types.RECT.Normalize(System.Boolean)">
            <summary>
            If width or height are negative, modifies this rectangle so that they would not be negative.
            </summary>
            <param name="swap">true - swap right/left, bottom/top; false - set right = left, bottom = top.</param>
        </member>
        <member name="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.AScreen,System.Boolean,System.Boolean)">
            <summary>
            Moves this rectangle to the specified coordinates in the specified screen, and ensures that whole rectangle is in screen.
            Final rectangle coordinates are relative to the primary screen.
            </summary>
            <param name="x">X coordinate in the specified screen. If default(Coord) - screen center. Can be Coord.Reverse etc.</param>
            <param name="y">Y coordinate in the specified screen. If default(Coord) - screen center. Can be Coord.Reverse etc.</param>
            <param name="screen">Use this screen (see <see cref="T:Au.AScreen"/>). If null (default), uses the primary screen.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <param name="ensureInScreen">If part of rectangle is not in screen, move and/or resize it so that entire rectangle would be in screen. Default true.</param>
            <remarks>
            This function can be used to calculate new window location before creating it. If window already exists, use <see cref="M:Au.AWnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.AScreen,System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.RECT.MoveInRect(Au.Types.RECT,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves this rectangle to the specified coordinates in another rectangle <i>r</i>.
            </summary>
            <param name="x">X coordinate relative to <i>r</i>. Default - center. Can be Coord.Reverse etc.</param>
            <param name="y">Y coordinate relative to <i>r</i>. Default - center. Can be Coord.Reverse etc.</param>
            <param name="r">Another rectangle.</param>
            <param name="ensureInRect">If part of rectangle is not in <i>r</i>, move and/or resize it so that entire rectangle would be in <i>r</i>. Default true.</param>
        </member>
        <member name="M:Au.Types.RECT.EnsureInScreen(Au.AScreen,System.Boolean)">
            <summary>
            Adjusts this rectangle to ensure that whole rectangle is in screen.
            Initial and final rectangle coordinates are relative to the primary screen.
            </summary>
            <param name="screen">Use this screen (see <see cref="T:Au.AScreen"/>). If null (default), uses screen of the rectangle (or nearest).</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <remarks>
            This function can be used to calculate new window location before creating it. If window already exists, use <see cref="M:Au.AWnd.EnsureInScreen(Au.AScreen,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="T:Au.Types.ColorInt">
            <summary>
            Color, as int in 0xAARRGGBB format.
            Can convert from/to <see cref="T:System.Drawing.Color"/>, <see cref="T:System.Windows.Media.Color"/>, int (0xAARRGGBB), Windows native COLORREF (0xBBGGRR), string.
            </summary>
        </member>
        <member name="F:Au.Types.ColorInt.color">
            <summary>
            Color value in 0xAARRGGBB format.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates ColorInt from color value in 0xAARRGGBB format.
            </summary>
            <param name="colorARGB"></param>
            <param name="makeOpaque">Set alpha = 0xFF.</param>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Int32)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from int color value in 0xRRGGBB format.
            Makes opaque (alpha 0xFF).
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.UInt32)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from uint color value in 0xRRGGBB format.
            Makes opaque (alpha 0xFF).
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Drawing.Color)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from <see cref="T:System.Drawing.Color"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Implicit(System.Windows.Media.Color)~Au.Types.ColorInt">
            <summary>
            Creates ColorInt from <see cref="T:System.Windows.Media.Color"/>.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.FromString(System.String,Au.Types.ColorInt@)">
            <summary>
            Creates ColorInt from color name (<see cref="M:System.Drawing.Color.FromName(System.String)"/>) or string "0xRRGGBB" or "#RRGGBB".
            </summary>
            <remarks>
            If s is a hex number that contains 6 or less hex digits, makes opaque (alpha 0xFF).
            If s is null or invalid, sets c.color = 0 and returns false.
            </remarks>
        </member>
        <member name="M:Au.Types.ColorInt.FromBGR(System.Int32,System.Boolean)">
            <summary>
            Creates ColorInt (0xRRGGBB) from Windows native COLORREF (0xBBGGRR).
            </summary>
            <param name="colorBGR">Color in 0xBBGGRR format.</param>
            <param name="makeOpaque">Set alpha = 0xFF.</param>
        </member>
        <member name="M:Au.Types.ColorInt.ToBGR(System.Boolean)">
            <summary>
            Creates Windows native COLORREF (0xBBGGRR) from ColorInt (0xRRGGBB).
            Returns color in COLORREF format. Does not modify this variable.
            </summary>
            <param name="zeroAlpha">Set the alpha byte = 0.</param>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.Int32">
            <summary>Creates int from ColorInt.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.UInt32">
            <summary>Creates int from ColorInt.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.Drawing.Color">
            <summary>Creates <see cref="T:System.Drawing.Color"/> from ColorInt.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.op_Explicit(Au.Types.ColorInt)~System.Windows.Media.Color">
            <summary>Creates <see cref="T:System.Windows.Media.Color"/> from ColorInt.</summary>
        </member>
        <member name="M:Au.Types.ColorInt.SwapRB(System.Int32)">
            <summary>
            Converts color from ARGB (0xAARRGGBB) to ABGR (0xAABBGGRR) or vice versa (swaps the red and blue bytes).
            ARGB is used in .NET, GDI+ and HTML/CSS.
            ABGR is used by most Windows native API.
            </summary>
        </member>
        <member name="M:Au.Types.ColorInt.GetPerceivedBrightness">
            <summary>
            Calculates color's perceived brightness.
            Returns a value in range 0 (brightness of black color) to 1 (brightness of white color).
            </summary>
            <remarks>
            Unlike Color.GetBrightness, this function gives different weights for red, green and blue components.
            Does not use alpha.
            </remarks>
        </member>
        <member name="M:Au.Types.ColorInt.AdjustLuminance(System.Int32,System.Boolean)">
            <summary>
            Changes color's luminance (makes darker or brighter).
            Returns new color. Does not modify this variable.
            </summary>
            <param name="n">The luminance in units of 0.1 percent of the range (which depends on totalRange). Can be from -1000 to 1000.</param>
            <param name="totalRange">If true, n is in the whole luminance range (from minimal to maximal possible). If false, n is in the range from current luminance of the color to the maximal (if n positive) or minimal (if n negative) luminance.</param>
            <remarks>
            Calls API <msdn>ColorAdjustLuma</msdn>.
            Does not change hue and saturation. Does not use alpha.
            </remarks>
        </member>
        <member name="M:Au.Types.VARIANT.Dispose">
            <summary>
            Calls VariantClear.
            </summary>
        </member>
        <member name="M:Au.Types.VARIANT.ToString">
            <summary>
            Converts to string.
            </summary>
        </member>
        <member name="M:Au.Types.VARIANT.ToStringAndDispose">
            <summary>
            Converts to string.
            Disposes this VARIANT.
            </summary>
        </member>
        <member name="P:Au.Types.BSTR.Is0">
            <summary>
            Returns true if the string is null.
            </summary>
        </member>
        <member name="P:Au.Types.BSTR.Item(System.Int32)">
            <summary>
            Unsafe.
            </summary>
        </member>
        <member name="M:Au.Types.BSTR.ToString">
            <summary>
            Converts to string.
            Does not dispose.
            </summary>
        </member>
        <member name="M:Au.Types.BSTR.ToStringAndDispose">
            <summary>
            Converts to string and disposes.
            </summary>
        </member>
        <member name="T:Au.Types.DIcon">
            <summary>
            Standard icons for <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.DIcon.App">
            <summary>
            Use <msdn>IDI_APPLICATION</msdn> icon from unmanaged resources of this program file.
            If there are no icons - the default program icon.
            </summary>
        </member>
        <member name="T:Au.Types.DEdit">
            <summary>
            Text edit field type for <see cref="M:Au.ADialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/> and <see cref="M:Au.ADialog.SetEditControl(Au.Types.DEdit,System.Object)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.DFlags">
            <summary>
            Flags for <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.CommandLinks">
            <summary>
            Display custom buttons as a column of command-links, not as a row of classic buttons.
            Command links can have multi-line text. The first line has bigger font.
            More info about custom buttons: <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.EndThread">
            <summary>
            Call <see cref="M:System.Threading.Thread.Abort"/> if selected OK button when there are no other buttons. Also when selected Cancel, No, and on timeout.
            The same as <see cref="P:Au.ADialog.FlagEndThread"/>.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.ExpandDown">
            <summary>
            Show expanded text in footer.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.OwnerCenter">
            <summary>
            Show the dialog in the center of the owner window.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.RawXY">
            <summary>
            x y are relative to the primary screen (ignore <see cref="P:Au.ADialog.Screen"/> etc). Don't ensure thet entire window is in screen.
            More info: <see cref="M:Au.ADialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. 
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.Topmost">
            <summary>
            Make the dialog a topmost window (always on top of other windows), regardless of ADialog.Options.TopmostIfNoOwnerWindow etc.
            More info: <see cref="P:Au.ADialog.FlagTopmost"/>. 
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.Wider">
            <summary>
            Set <see cref="P:Au.ADialog.Width"/> = 700.
            </summary>
        </member>
        <member name="F:Au.Types.DFlags.XCancel">
            <summary>
            Allow to cancel even if there is no Cancel button.
            It adds X (Close) button to the title bar, and also allows to close the dialog with the Esc key.
            When the dialog is closed with the X button or Esc, the returned result button id is 0 if there is no Cancel button; else the same as when clicked the Cancel button.
            The same as <see cref="P:Au.ADialog.FlagXCancel"/>.
            </summary>
        </member>
        <member name="T:Au.Types.DResult">
            <summary>
            Result of <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and similar functions: button id, radio button id, check box state, edit field text.
            </summary>
        </member>
        <member name="F:Au.Types.DResult.Timeout">
            <summary>
            Returned <see cref="P:Au.Types.DResult.Button"/> value on timeout.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.Button">
            <summary>
            Gets selected button id.
            On timeout it is DResult.Timeout.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.RadioButton">
            <summary>
            Gets selected (checked) radio button id.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.IsChecked">
            <summary>
            Gets check box state.
            </summary>
        </member>
        <member name="P:Au.Types.DResult.EditText">
            <summary>
            Gets edit field text.
            </summary>
        </member>
        <member name="M:Au.Types.DResult.op_Implicit(Au.Types.DResult)~System.Int32">
            <summary>
            Converts DResult to int.
            Allows to use code <c>switch(ADialog.ShowEx(...))</c> instead of <c>switch(ADialog.ShowEx(...).Button)</c> .
            </summary>
        </member>
        <member name="M:Au.Types.DResult.ToString">
            <summary>
            Formats string $"Button={Button}, RadioButton={RadioButton}, IsChecked={IsChecked}, EditText={EditText}".
            </summary>
        </member>
        <member name="T:Au.Types.DEventArgs">
            <summary>
            Arguments for <see cref="T:Au.ADialog"/> event handlers.
            </summary>
            <remarks>
            To return a non-zero value from the callback function, assign the value to the <b>returnValue</b> field.
            More info: <msdn>TaskDialogCallbackProc</msdn>.
            </remarks>
        </member>
        <member name="F:Au.Types.DEventArgs.message">
            <summary>Reference: <msdn>task dialog notifications</msdn>.</summary>
        </member>
        <member name="P:Au.Types.DEventArgs.LinkHref">
            <summary>
            Clicked hyperlink href attribute value. Use in <see cref="E:Au.ADialog.HyperlinkClicked"/> event handler.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.Button">
            <summary>
            Clicked button id. Use in <see cref="E:Au.ADialog.ButtonClicked"/> event handler.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.TimerTimeMS">
            <summary>
            Dialog timer time in milliseconds. Use in <see cref="E:Au.ADialog.Timer"/> event handler.
            The event handler can set <b>returnValue</b>=1 to reset this.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.DontCloseDialog">
            <summary>
            Your <see cref="E:Au.ADialog.ButtonClicked"/> event handler function can use this to prevent closing the dialog.
            </summary>
        </member>
        <member name="P:Au.Types.DEventArgs.EditText">
            <summary>
            Gets or sets edit field text.
            </summary>
        </member>
        <member name="T:Au.Types.DSend">
            <summary>
            Can be used through <see cref="P:Au.ADialog.Send"/>, to interact with dialog while it is open.
            </summary>
            <remarks>
            Example (in an event handler): <c>e.dialog.Close();</c>
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.Message(Au.Types.Native.TDM,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Sends a message to the dialog.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Example (in an event handler): <c>e.dialog.Send.Message(Native.TDM.CLICK_VERIFICATION, 1);</c>
            Also there are several other functions to send some messages: change text, close dialog, enable/disable buttons, update progress.
            Reference: <msdn>task dialog messages</msdn>.
            NAVIGATE_PAGE currently not supported.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.ChangeText1(System.String,System.Boolean)">
            <summary>
            Changes the main big-font text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.ChangeText2(System.String,System.Boolean)">
            <summary>
            Changes the main small-font text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.ChangeFooterText(System.String,System.Boolean)">
            <summary>
            Changes the footer text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.ChangeExpandedText(System.String,System.Boolean)">
            <summary>
            Changes the expanded area text.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.Close(System.Int32)">
            <summary>
            Clicks a button. Normally it closes the dialog.
            </summary>
            <param name="buttonId">A button id or some other number that will be returned by ShowDialog.</param>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Sends message Native.TDM.CLICK_BUTTON.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.EnableButton(System.Int32,System.Boolean)">
            <summary>
            Enables or disables a button.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Example: <c>d.Created += e => { e.dialog.Send.EnableButton(4, false); };</c>
            Sends message Native.TDM.ENABLE_BUTTON.
            </remarks>
        </member>
        <member name="M:Au.Types.DSend.Progress(System.Int32)">
            <summary>
            Sets progress bar value, 0 to 100.
            </summary>
            <remarks>
            Call this method while the dialog is open, eg in an event handler.
            Sends message Native.TDM.SET_PROGRESS_BAR_POS.
            </remarks>
        </member>
        <member name="T:Au.Types.AMTBase">
            <summary>
            Base class of <see cref="T:Au.AMenu"/> and <see cref="T:Au.AToolbar"/>.
            </summary>
        </member>
        <member name="P:Au.Types.AMTBase.ItemThread">
            <summary>
            In what thread to execute item callback functions.
            Default: current thread.
            </summary>
            <remarks>
            If current thread is a UI thread (has windows etc), and item callback functions execute some long automations in the same thread, current thread probably is hung during that time. Use this property to avoid it.
            This property is applied to items added afterwards.
            </remarks>
        </member>
        <member name="P:Au.Types.AMTBase.ExceptionHandling">
            <summary>
            Whether/how to handle unhandled exceptions in item code.
            Default: <see cref="F:Au.Types.MTExcept.Exception"/> (don't handle exceptions if <see cref="P:Au.Types.AMTBase.ItemThread"/> is <see cref="F:Au.Types.MTThread.Current"/> (default), else show warning).
            </summary>
            <remarks>
            This property is applied to items added afterwards.
            </remarks>
        </member>
        <member name="P:Au.Types.AMTBase.MainToolStrip">
            <summary>
            Gets ToolStrip of AMenu and AToolbar, which override this.
            </summary>
        </member>
        <member name="P:Au.Types.AMTBase.LastItem">
            <summary>
            Gets the last added item as <see cref="T:System.Windows.Forms.ToolStripItem"/>, which is the base type of <see cref="T:System.Windows.Forms.ToolStripMenuItem"/>, <see cref="T:System.Windows.Forms.ToolStripButton"/> and other supported types.
            </summary>
        </member>
        <member name="E:Au.Types.AMTBase.ItemAdded">
            <summary>
            Occurs when an item is added.
            Allows to set item properties in single place instead of after each 'add item' code line.
            For example, the event handler can set item properties common to all items, or set item properties encoded in item text.
            </summary>
        </member>
        <member name="P:Au.Types.AMTBase.IconFlags">
            <summary>
            Flags to pass to <see cref="M:Au.AIcon.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>. See <see cref="T:Au.Types.GIFlags"/>.
            </summary>
            <remarks>
            This property is applied to all items.
            </remarks>
        </member>
        <member name="P:Au.Types.AMTBase.IconSize">
            <summary>
            Image width and height.
            Also can be enum <see cref="P:Au.Types.AMTBase.IconSize"/>, cast to int.
            </summary>
            <exception cref="T:System.InvalidOperationException">The 'set' function is called after adding items.</exception>
            <remarks>
            This property is applied to all items, and can be set only before adding items (else exception).
            To set different icon size for a submenu: <c>using(m.Submenu("sub")) { m.LastMenuItem.DropDown.ImageScalingSize = new Size(24, 24);</c>
            </remarks>
        </member>
        <member name="P:Au.Types.AMTBase.ExtractIconPathFromCode">
            <summary>
            When adding items without explicitly specified icon, extract icon from item code.
            </summary>
            <remarks>
            This property is applied to items added afterwards.
            </remarks>
        </member>
        <member name="M:Au.Types.AMTBase._IconPathFromCode(System.Reflection.MethodInfo)">
            <summary>
            Gets icon path from code that contains string like <c>@"c:\windows\system32\notepad.exe"</c> or <c>@"%AFolders.System%\notepad.exe"</c> or URL/shell.
            Also supports code patterns like 'AFolders.System + "notepad.exe"' or 'AFolders.Virtual.RecycleBin'.
            Returns null if no such string/pattern.
            </summary>
        </member>
        <member name="M:Au.Types.AMTBase.Finalize">
            
        </member>
        <member name="T:Au.Types.MTClickArgs">
            <summary>
            Data passed to Click event handler functions of <see cref="T:Au.AMenu"/> and <see cref="T:Au.AToolbar"/>.
            </summary>
        </member>
        <member name="P:Au.Types.MTClickArgs.Item">
            <summary>
            Gets the clicked item as ToolStripItem.
            </summary>
        </member>
        <member name="P:Au.Types.MTClickArgs.MenuItem">
            <summary>
            Gets the clicked item as ToolStripMenuItem.
            Returns null if it is not ToolStripMenuItem.
            </summary>
        </member>
        <member name="M:Au.Types.MTClickArgs.ToString">
            <summary>
            Gets item text.
            </summary>
        </member>
        <member name="T:Au.Types.MTThread">
            <summary>
            Used with <see cref="P:Au.Types.AMTBase.ItemThread"/>.
            </summary>
        </member>
        <member name="F:Au.Types.MTThread.Current">
            <summary>
            Execute item callback functions in current thread. This is default.
            </summary>
        </member>
        <member name="F:Au.Types.MTThread.ThreadPool">
            <summary>
            Execute item callback functions in thread pool threads (<see cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>).
            Note: current thread does not wait until the callback function finishes.
            </summary>
        </member>
        <member name="F:Au.Types.MTThread.StaThread">
            <summary>
            Execute item callback functions in new STA threads (<see cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)"/>).
            Note: current thread does not wait until the callback function finishes.
            </summary>
        </member>
        <member name="F:Au.Types.MTThread.StaBackgroundThread">
            <summary>
            Execute item callback functions in new STA background threads (<see cref="P:System.Threading.Thread.IsBackground"/>).
            Note: current thread does not wait until the callback function finishes.
            </summary>
        </member>
        <member name="T:Au.Types.MTExcept">
            <summary>
            Used with <see cref="P:Au.Types.AMTBase.ExceptionHandling"/>.
            </summary>
        </member>
        <member name="F:Au.Types.MTExcept.Exception">
            <summary>
            Don't handle exceptions. This is default.
            However if <see cref="P:Au.Types.AMTBase.ItemThread"/> is not <see cref="F:Au.Types.MTThread.Current"/>, handles exceptions and shows warning.
            </summary>
        </member>
        <member name="F:Au.Types.MTExcept.Warning">
            <summary>Handle exceptions. On exception call <see cref="M:Au.AStatic.PrintWarning(System.String,System.Int32,System.String)"/>.</summary>
        </member>
        <member name="F:Au.Types.MTExcept.Silent">
            <summary>Handle exceptions. On exception do nothing.</summary>
        </member>
        <member name="T:Au.Types.MUsingSubmenu">
            <summary>
            Allows to create <see cref="T:Au.AMenu"/> submenus easier.
            Example: <c>using(m.Submenu("Name")) { add items; }</c> .
            </summary>
        </member>
        <member name="P:Au.Types.MUsingSubmenu.MenuItem">
            <summary>
            Gets <b>ToolStripMenuItem</b> of the submenu-item.
            </summary>
        </member>
        <member name="M:Au.Types.MUsingSubmenu.Dispose">
            <summary>
            Calls <see cref="M:Au.AMenu.EndSubmenu"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RFlags">
            <summary>
            Flags for <see cref="M:Au.AExec.Run(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.ShowErrorUI">
            <summary>
            Show error message box if fails, for example if file not found.
            Note: this does not disable exceptions. Still need exception handling. Or call <see cref="M:Au.AExec.TryRun(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.WaitForExit">
            <summary>
            If started new process, wait until it exits.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.NeedProcessHandle">
            <summary>
            Get process handle (<see cref="P:Au.Types.RResult.ProcessHandle"/>), if possible.
            </summary>
        </member>
        <member name="F:Au.Types.RFlags.Admin">
            <summary>
            Run as administrator, probably with UAC consent dialog.
            Uses verb "runas", therefore other verb cannot be specified.
            </summary>
        </member>
        <member name="T:Au.Types.RMore">
            <summary>
            More parameters for <see cref="M:Au.AExec.Run(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)"/>.
            </summary>
        </member>
        <member name="M:Au.Types.RMore.op_Implicit(System.String)~Au.Types.RMore">
            <summary>
            Sets <see cref="F:Au.Types.RMore.CurrentDirectory"/>.
            </summary>
        </member>
        <member name="F:Au.Types.RMore.CurrentDirectory">
            <summary>
            Initial current directory for the new process.
            If null (default), the new process will inherit the curent directory of this process.
            If "", the function gets parent directory path from the <i>file</i> parameter, if possible (if full path is specified or found). If not possible, same as null.
            <note>Some programs look for their files in current directory and fail to start if it is not the program's directory.</note>
            </summary>
        </member>
        <member name="F:Au.Types.RMore.Verb">
            <summary>
            File's right-click menu command, also known as verb. For example "edit", "print", "properties". The default verb is bold in the menu.
            Not all menu items will work. Some may have different name than in the menu.
            </summary>
        </member>
        <member name="F:Au.Types.RMore.OwnerWindow">
            <summary>
            Owner window for error message boxes.
            Also, new window should be opened on the same screen. However many programs ignore it.
            </summary>
        </member>
        <member name="F:Au.Types.RMore.WindowState">
            <summary>
            Preferred window state.
            Many programs ignore it.
            </summary>
        </member>
        <member name="T:Au.Types.RResult">
            <summary>
            Results of <see cref="M:Au.AExec.Run(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RResult.ProcessExitCode">
            <summary>
            The exit code of the process.
            0 if no flag <b>WaitForExit</b> or if cannot wait.
            </summary>
            <remarks>
            Usually the exit code is 0 or a process-defined error code.
            </remarks>
        </member>
        <member name="P:Au.Types.RResult.ProcessId">
            <summary>
            The process id.
            0 if used flag <b>WaitForExit</b> or if did not start new process (eg opened the document in an existing process) or if cannot get it.
            </summary>
        </member>
        <member name="P:Au.Types.RResult.ProcessHandle">
            <summary>
            If used flag <b>NeedProcessHandle</b>, contains process handle. Later the <see cref="T:System.Threading.WaitHandle"/> variable must be disposed.
            null if no flag or if did not start new process (eg opened the document in an existing process) or if cannot get it.
            </summary>
            <example>
            This code does the same as <c>AExec.Run(@"notepad.exe", flags: SRFlags.WaitForExit);</c>
            <code><![CDATA[
            var r = AExec.Run(@"notepad.exe", flags: SRFlags.NeedProcessHandle);
            using(var h = r.ProcessHandle) h?.WaitOne();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.RResult.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RResult.ProcessId"/> as string.
            </summary>
        </member>
        <member name="T:Au.Types.FileDir">
            <summary>
            File system entry type - file, directory, and whether it exists.
            Returned by <see cref="M:Au.AFile.ExistsAs(System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FileDir.NotFound">
            <summary>Does not exist, or failed to get attributes.</summary>
        </member>
        <member name="F:Au.Types.FileDir.File">
            <summary>Is file, or symbolic link to a file.</summary>
        </member>
        <member name="F:Au.Types.FileDir.Directory">
            <summary>Is directory, or symbolic link to a directory.</summary>
        </member>
        <member name="T:Au.Types.FileDir2">
            <summary>
            File system entry type - file, directory, symbolic link, whether it exists and is accessible.
            Returned by <see cref="M:Au.AFile.ExistsAs2(System.String,System.Boolean)"/>.
            The enum value NotFound is 0; AccessDenied is negative ((int)0x80000000); other values are greater than 0.
            </summary>
        </member>
        <member name="F:Au.Types.FileDir2.NotFound">
            <summary>Does not exist.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.File">
            <summary>Is file. Attributes: Directory no, ReparsePoint no.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.Directory">
            <summary>Is directory. Attributes: Directory yes, ReparsePoint no.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.SymLinkFile">
            <summary>Is symbolic link to a file. Attributes: Directory no, ReparsePoint yes.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.SymLinkDirectory">
            <summary>Is symbolic link to a directory, or is a mounted folder. Attributes: Directory yes, ReparsePoint yes.</summary>
        </member>
        <member name="F:Au.Types.FileDir2.AccessDenied">
            <summary>Exists but this process cannot access it and get attributes.</summary>
        </member>
        <member name="T:Au.Types.FAFlags">
            <summary>
            Flags for <see cref="M:Au.AFile.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and some other functions.
            </summary>
        </member>
        <member name="F:Au.Types.FAFlags.UseRawPath">
            <summary>Pass path to the API as it is, without any normalizing and validating.</summary>
        </member>
        <member name="F:Au.Types.FAFlags.DontThrow">
            <summary>
            If failed, return false and don't throw exception.
            Then, if you need error info, you can use <see cref="T:Au.ALastError"/>. If the file/directory does not exist, it will return ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND or ERROR_NOT_READY.
            If failed and the native error code is ERROR_ACCESS_DENIED or ERROR_SHARING_VIOLATION, the returned attributes will be (FileAttributes)(-1). The file probably exists but is protected so that this process cannot access and use it. Else attributes will be 0.
            </summary>
        </member>
        <member name="T:Au.Types.FileProperties">
            <summary>
            File or directory properties. Used with <see cref="M:Au.AFile.GetProperties(System.String,Au.Types.FileProperties@,Au.Types.FAFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FileProperties.Attributes">
            
        </member>
        <member name="F:Au.Types.FileProperties.Size">
            <summary>File size. For directories it is usually 0.</summary>
        </member>
        <member name="F:Au.Types.FileProperties.LastWriteTimeUtc">
            
        </member>
        <member name="F:Au.Types.FileProperties.CreationTimeUtc">
            
        </member>
        <member name="F:Au.Types.FileProperties.LastAccessTimeUtc">
            <summary>Note: this is unreliable. The operating system may not record this time automatically.</summary>
        </member>
        <member name="T:Au.Types.FEFlags">
            <summary>
            flags for <see cref="M:Au.AFile.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.AndSubdirectories">
            <summary>
            Enumerate subdirectories too.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.AndSymbolicLinkSubdirectories">
            <summary>
            Also enumerate symbolic link and mounted folder target directories. Use with AndSubdirectories.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.SkipHidden">
            <summary>
            Skip files and subdirectories that have Hidden attribute.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.SkipHiddenSystem">
            <summary>
            Skip files and subdirectories that have Hidden and System attributes (both).
            These files/directories usually are created and used only by the operating system. Drives usually have several such directories. Another example - thumbnail cache files.
            Without this flag the function skips only these hidden-system root directories when enumerating a drive: <c>"$Recycle.Bin"</c>, <c>"System Volume Information"</c>, <c>"Recovery"</c>. If you want to include them too, use network path of the drive, for example <c>@"\\localhost\D$\"</c> for D drive.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.IgnoreAccessDeniedErrors">
            <summary>
            If fails to get contents of the directory or a subdirectory because of its security settings, assume that the [sub]directory is empty.
            Without this flag then throws exception or calls errorHandler.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.DisableRedirection">
            <summary>
            Temporarily disable file system redirection in this thread of this 32-bit process running on 64-bit Windows.
            Then you can enumerate the 64-bit System32 folder in your 32-bit process.
            Uses API <msdn>Wow64DisableWow64FsRedirection</msdn>.
            For vice versa (in 64-bit process enumerate the 32-bit System folder), instead use path AFolders.SystemX86.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.UseRawPath">
            <summary>
            Don't call <see cref="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)"/>(directoryPath) and don't throw exception for non-full path.
            </summary>
        </member>
        <member name="F:Au.Types.FEFlags.NeedRelativePaths">
            <summary>
            Let <see cref="P:Au.Types.FEFile.Name"/> be path relative to the specified directory path. Like <c>@"\name.txt"</c> or <c>@"\subdirectory\name.txt"</c> instead of "name.txt".
            </summary>
        </member>
        <member name="T:Au.Types.FCFlags">
            <summary>
            flags for <see cref="M:Au.AFile.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> and some other similar functions.
            Used only when copying directory.
            </summary>
        </member>
        <member name="F:Au.Types.FCFlags.SkipHiddenSystem">
            <summary>
            Skip descendant files and directories that have Hidden and System attributes (both).
            They usually are created and used only by the operating system. Drives usually have several such directories. Another example - thumbnail cache files.
            They often are protected and would fail to copy, ruining whole copy operation.
            Without this flag the function skips only these hidden-system root directories when enumerating a drive: "$Recycle.Bin", "System Volume Information", "Recovery".
            </summary>
        </member>
        <member name="F:Au.Types.FCFlags.IgnoreAccessDeniedErrors">
            <summary>
            If fails to get contents of the directory or a subdirectory because of its security settings, don't throw exception but assume that the [sub]directory is empty.
            </summary>
        </member>
        <member name="T:Au.Types.FEFile">
            <summary>
            Contains name and other main properties of a file or subdirectory retrieved by <see cref="M:Au.AFile.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            The values are not changed after creating the variable.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.#ctor(System.String,System.String,Au.Types.Api.WIN32_FIND_DATA@,System.Int32)">
            
        </member>
        <member name="P:Au.Types.FEFile.Name">
            
        </member>
        <member name="P:Au.Types.FEFile.FullPath">
            
        </member>
        <member name="P:Au.Types.FEFile.Size">
            <summary>
            Returns file size. For directories it is usually 0.
            </summary>
        </member>
        <member name="P:Au.Types.FEFile.LastWriteTimeUtc">
            
        </member>
        <member name="P:Au.Types.FEFile.CreationTimeUtc">
            
        </member>
        <member name="P:Au.Types.FEFile.Attributes">
            
        </member>
        <member name="P:Au.Types.FEFile.IsDirectory">
            <summary>
            Returns true if is directory or symbolic link to a directory or mounted folder.
            </summary>
        </member>
        <member name="P:Au.Types.FEFile.Level">
            <summary>
            Descendant level.
            0 if direct child of directoryPath, 1 if child of child, an so on.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.SkipThisDirectory">
            <summary>
            Call this function if don't want to enumerate children of this subdirectory.
            </summary>
        </member>
        <member name="M:Au.Types.FEFile.ToString">
            <summary>
            Returns FullPath.
            </summary>
        </member>
        <member name="T:Au.Types.IfExists">
            <summary>
            What to do if the destination directory contains a file or directory with the same name as the source file or directory when copying, moving or renaming.
            Used with <see cref="M:Au.AFile.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>, <see cref="M:Au.AFile.Move(System.String,System.String,Au.Types.IfExists)"/> and similar functions.
            When renaming or moving, if the destination is the same as the source, these options are ignored and the destination is simply renamed. For example when renaming "file.txt" to "FILE.TXT".
            </summary>
        </member>
        <member name="F:Au.Types.IfExists.Fail">
            <summary>Throw exception. Default.</summary>
        </member>
        <member name="F:Au.Types.IfExists.Delete">
            <summary>Delete destination.</summary>
        </member>
        <member name="F:Au.Types.IfExists.RenameExisting">
            <summary>Rename (backup) destination.</summary>
        </member>
        <member name="F:Au.Types.IfExists.MergeDirectory">
            <summary>
            If destination directory exists, merge the source directory into it, replacing existing files.
            If destination file exists, deletes it.
            If destination directory exists and source is file, fails.
            </summary>
        </member>
        <member name="T:Au.Types.FileId">
            <summary>
            Contains file properties that can be used to uniquely identify the file on a single computer.
            </summary>
            <remarks>
            Can be used with files and directories.
            To get it, use <see cref="M:Au.AFile.More.GetFileId(System.String,Au.Types.FileId@)"/>.
            There are many different ways to specify path to the same file or directory. To determine whether two paths represent the same file, get and compare their <b>FileId</b>.
            </remarks>
        </member>
        <member name="F:Au.Types.FileId.VolumeSerialNumber">
            <summary>The serial number of the volume (aka disk drive) that contains the file.</summary>
        </member>
        <member name="F:Au.Types.FileId.FileIndex">
            <summary>An identifier that is associated with the file. It is unique in that volume.</summary>
        </member>
        <member name="M:Au.Types.FileId.op_Equality(Au.Types.FileId,Au.Types.FileId)">
            
        </member>
        <member name="M:Au.Types.FileId.op_Inequality(Au.Types.FileId,Au.Types.FileId)">
            
        </member>
        <member name="T:Au.Types.FolderPath">
            <summary>
            Most functions of <see cref="T:Au.AFolders"/> class return a value of this type.
            Contains folder path (string) and has operator + to append a string with backslash if need. Has implicit conversions from/to string.
            </summary>
        </member>
        <member name="M:Au.Types.FolderPath.op_Addition(Au.Types.FolderPath,System.String)">
            <summary>
            Calls <see cref="M:Au.APath.Combine(System.String,System.String,System.Boolean,System.Boolean)"/>(fp, append).
            Example: <c>string s = AFolders.Desktop + "file.txt";</c>
            </summary>
            <exception cref="T:Au.Types.AuException">fp is empty. Most likely, used code <c>AFolders.X + "append"</c> and AFolders.X failed to get folder path.</exception>
        </member>
        <member name="T:Au.Types.GIFlags">
            <summary>
            Flags for <see cref="M:Au.AIcon.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.GIFlags.LiteralPath">
            <summary>
            The 'file' argument is literal full path. Don't parse "path,index", don't support ".ext" (file type icon), don't make fully-qualified, etc.
            </summary>
        </member>
        <member name="F:Au.Types.GIFlags.SearchPath">
            <summary>
            If file is not full path, call <see cref="M:Au.AFile.SearchPath(System.String,System.String[])"/>.
            Without this flag searches only in <see cref="P:Au.AFolders.ThisAppImages"/>; with this flag also searches there first.
            </summary>
        </member>
        <member name="T:Au.Types.IconSize">
            <summary>
            Standard icon sizes.
            </summary>
            <seealso cref="M:Au.AIcon.GetShellIconSize(Au.Types.IconSize)"/>
        </member>
        <member name="F:Au.Types.IconSize.SysSmall">
            <summary>
            Icons displayed in window title bar and system notification area (tray). Usually 16x16 when normal DPI, the same as <b>Small</b>.
            </summary>
        </member>
        <member name="F:Au.Types.IconSize.Small">
            <summary>
            Small icons displayed in Explorer folders. Usually 16x16 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Types.IconSize.Large">
            <summary>
            Large icons displayed in Explorer folders. Usually 32x32 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Types.IconSize.ExtraLarge">
            <summary>
            Extra large icons displayed in Explorer folders. Usually 48x48 when normal DPI.
            </summary>
        </member>
        <member name="F:Au.Types.IconSize.Jumbo">
            <summary>
            256x256 icons displayed in Explorer folders.
            </summary>
        </member>
        <member name="T:Au.Types.StockIcon">
            <summary>See <msdn>SHSTOCKICONID</msdn>.</summary>
            <seealso cref="M:Au.AIcon.GetStockIcon(Au.Types.StockIcon,System.Int32)"/>
        </member>
        <member name="T:Au.Types.PNFlags">
            <summary>
            flags for <see cref="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.PNFlags.DontExpandDosPath">
            <summary>Don't call API <msdn>GetLongPathName</msdn>.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.DontPrefixLongPath">
            <summary>Don't call <see cref="M:Au.APath.PrefixLongPathIfNeed(System.String)"/>.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.DontRemoveEndSeparator">
            <summary>Don't remove <c>\</c> character at the end.</summary>
        </member>
        <member name="F:Au.Types.PNFlags.CanBeUrlOrShell">
            <summary>If path is not a file-system path but looks like URL (eg <c>"http:..."</c> or <c>"file:..."</c>) or starts with <c>"::"</c>, don't throw exception and don't process more (only expand environment variables).</summary>
        </member>
        <member name="T:Au.Types.ProcessInfo">
            <summary>
            Contains process id, name and session id.
            </summary>
        </member>
        <member name="F:Au.Types.ProcessInfo.SessionId">
            <summary>User session id.</summary>
        </member>
        <member name="F:Au.Types.ProcessInfo.ProcessId">
            <summary>Process id.</summary>
        </member>
        <member name="F:Au.Types.ProcessInfo.Name">
            <summary>Executable file name, like "notepad.exe".</summary>
        </member>
        <member name="M:Au.Types.ProcessInfo.#ctor(System.Int32,System.Int32,System.String)">
            
        </member>
        <member name="M:Au.Types.ProcessInfo.ToString">
            
        </member>
        <member name="T:Au.Types.SLTransaction">
            <summary>
            A SQLite transaction or savepoint. The main purpose is to automatically rollback if not explicitly committed.
            Usage: <c>using(var trans = new SLTransaction(db)) { ... trans.Commit(); }</c>
            </summary>
        </member>
        <member name="P:Au.Types.SLTransaction.SqlOfDispose">
            <summary>
            Gets or sets SQL to execute when disposing this variable if not called <see cref="M:Au.Types.SLTransaction.Commit(System.String)"/> or <see cref="M:Au.Types.SLTransaction.Rollback(System.String)"/>.
            Initially = parameter <c>sqlOfDispose</c> of constructor.
            </summary>
        </member>
        <member name="M:Au.Types.SLTransaction.#ctor(Au.ASqlite,System.String,System.String)">
            <summary>
            Begins a SQLite transaction and prepares for automatic rollback if not explicitly committed.
            Usage: <c>using(var trans = new SLTransaction(db)) { ... trans.Commit(); }</c>
            </summary>
            <param name="db"></param>
            <param name="sql">SQL to execute now. Default "BEGIN". For nested transaction use "SAVEPOINT name".</param>
            <param name="sqlOfDispose">SQL to execute when disposing this variable if not called <see cref="M:Au.Types.SLTransaction.Commit(System.String)"/> or <see cref="M:Au.Types.SLTransaction.Rollback(System.String)"/>. Default "ROLLBACK". For nested transaction use "ROLLBACK TO name". See also: <see cref="P:Au.Types.SLTransaction.SqlOfDispose"/>.</param>
            <exception cref="T:Au.Types.SLException">Failed to execute sql.</exception>
        </member>
        <member name="M:Au.Types.SLTransaction.Dispose">
            <summary>
            Calls <see cref="M:Au.Types.SLTransaction.Rollback(System.String)"/> if not called <see cref="M:Au.Types.SLTransaction.Commit(System.String)"/> or <see cref="M:Au.Types.SLTransaction.Rollback(System.String)"/>.
            </summary>
            <exception cref="T:Au.Types.SLException">Failed to execute <see cref="P:Au.Types.SLTransaction.SqlOfDispose"/>.</exception>
        </member>
        <member name="M:Au.Types.SLTransaction.Rollback(System.String)">
            <summary>
            Executes a rollback SQL (if in transaction) and disables <see cref="M:Au.Types.SLTransaction.Dispose"/>.
            Usually don't need to call this function explicitly. It is implicitly called when disposing this variable if the transaction was not committed.
            </summary>
            <param name="sql">SQL to execute. Default: <see cref="P:Au.Types.SLTransaction.SqlOfDispose"/>.</param>
            <exception cref="T:Au.Types.SLException">Failed to execute sql.</exception>
        </member>
        <member name="M:Au.Types.SLTransaction.Commit(System.String)">
            <summary>
            Executes a commit SQL and disables <see cref="M:Au.Types.SLTransaction.Dispose"/>.
            </summary>
            <param name="sql">SQL to execute. Default "COMMIT". For nested transaction use "RELEASE name".</param>
            <exception cref="T:Au.Types.SLException">Failed to execute sql.</exception>
        </member>
        <member name="T:Au.Types.SLIndexOrName">
            <summary>
            Used for parameter types of some <see cref="T:Au.ASqliteStatement"/> functions.
            Has implicit conversions from int and string. If int, the value is interpreted as index. If string - as name.
            </summary>
        </member>
        <member name="T:Au.Types.SLException">
            <summary>
            Exception thrown by <see cref="T:Au.ASqlite"/>, <see cref="T:Au.ASqliteStatement"/> and related types.
            </summary>
        </member>
        <member name="P:Au.Types.SLException.ErrorCode">
            <summary>
            The called SQLite API function returned this error code.
            </summary>
        </member>
        <member name="T:Au.Types.SLFlags">
            <summary>
            Flags for <see cref="T:Au.ASqlite"/> constructor.
            </summary>
        </member>
        <member name="F:Au.Types.SLFlags.ReadWriteCreate">
            <summary>Defaut flags. Includes SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE.</summary>
        </member>
        <member name="T:Au.Types.SLError">
            <summary>
            SQLite API error codes. Also two success codes - Row and Done.
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Ok">
            <summary>
            Successful result
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Error">
            <summary>
            SQL error or missing database
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Internal">
            <summary>
            Internal logic error in SQLite
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Perm">
            <summary>
            Access permission denied
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Abort">
            <summary>
            Callback routine requested an abort
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Busy">
            <summary>
            The database file is locked
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Locked">
            <summary>
            A table in the database is locked
            </summary>
        </member>
        <member name="F:Au.Types.SLError.NoMem">
            <summary>
            A malloc() failed
            </summary>
        </member>
        <member name="F:Au.Types.SLError.ReadOnly">
            <summary>
            Attempt to write a readonly database
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Interrupt">
            <summary>
            Operation terminated by sqlite3_interrupt()
            </summary>
        </member>
        <member name="F:Au.Types.SLError.IoErr">
            <summary>
            Some kind of disk I/O error occurred
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Corrupt">
            <summary>
            The database disk image is malformed
            </summary>
        </member>
        <member name="F:Au.Types.SLError.NotFound">
            <summary>
            Unknown opcode in sqlite3_file_control()
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Full">
            <summary>
            Insertion failed because database is full
            </summary>
        </member>
        <member name="F:Au.Types.SLError.CantOpen">
            <summary>
            Unable to open the database file
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Protocol">
            <summary>
            Database lock protocol error
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Empty">
            <summary>
            Database is empty
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Schema">
            <summary>
            The database schema changed
            </summary>
        </member>
        <member name="F:Au.Types.SLError.TooBig">
            <summary>
            String or BLOB exceeds size limit
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Constraint">
            <summary>
            Abort due to constraint violation
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Mismatch">
            <summary>
            Data type mismatch
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Misuse">
            <summary>
            Library used incorrectly
            </summary>
        </member>
        <member name="F:Au.Types.SLError.NoLfs">
            <summary>
            Uses OS features not supported on host
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Auth">
            <summary>
            Authorization denied
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Format">
            <summary>
            Auxiliary database format error
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Range">
            <summary>
            2nd parameter to sqlite3_bind out of range
            </summary>
        </member>
        <member name="F:Au.Types.SLError.NotADb">
            <summary>
            File opened that is not a database file
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Notice">
            <summary>
            Notifications from sqlite3_log()
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Warning">
            <summary>
            Warnings from sqlite3_log()
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Row">
            <summary>
            sqlite3_step() has another row ready
            </summary>
        </member>
        <member name="F:Au.Types.SLError.Done">
            <summary>
            sqlite3_step() has finished executing
            </summary>
        </member>
        <member name="T:Au.Types.UacIL">
            <summary>
            UAC integrity level.
            See <see cref="P:Au.AUac.IntegrityLevel"/>.
            </summary>
        </member>
        <member name="F:Au.Types.UacIL.Untrusted">
            <summary>The most limited rights. Rare.</summary>
        </member>
        <member name="F:Au.Types.UacIL.Low">
            <summary>Very limited rights. Used by web browser tab processes, Windows Store apps.</summary>
        </member>
        <member name="F:Au.Types.UacIL.Medium">
            <summary>Limited rights. Most processes (unless UAC turned off).</summary>
        </member>
        <member name="F:Au.Types.UacIL.UIAccess">
            <summary>Medium IL + can access/automate High IL windows (user interface).</summary>
        </member>
        <member name="F:Au.Types.UacIL.High">
            <summary>Most rights. Processes that run as administrator.</summary>
        </member>
        <member name="F:Au.Types.UacIL.System">
            <summary>Almost all rights. Services, some system processes.</summary>
        </member>
        <member name="F:Au.Types.UacIL.Protected">
            <summary>Undocumented. Rare.</summary>
        </member>
        <member name="F:Au.Types.UacIL.Unknown">
            <summary>Failed to get IL. Unlikely.</summary>
        </member>
        <member name="T:Au.Types.UacElevation">
            <summary>
            <see cref="P:Au.AUac.Elevation"/>.
            </summary>
        </member>
        <member name="F:Au.Types.UacElevation.Unknown">
            <summary>Failed to get. Normally it never happens.</summary>
        </member>
        <member name="F:Au.Types.UacElevation.Default">
            <summary>
            Processes in this user session cannot be elevated.
            Can be: non-administrator user session (processes have limited rights); service session (processes have all rights); UAC is turned off (most processes have administrator rights).
            </summary>
        </member>
        <member name="F:Au.Types.UacElevation.Full">
            <summary>Runs as administrator (High or System integrity level), and UAC is not turned off. Also known as "elevated".</summary>
        </member>
        <member name="F:Au.Types.UacElevation.Limited">
            <summary>Runs as standard user (Medium, UIAccess or Low integrity level) in administrator user session (because of UAC).</summary>
        </member>
        <member name="T:Au.Types.ClipFormats">
            <summary>
            Some clipboard format ids.
            These and other standard and registered format ids can be used with <see cref="T:Au.AClipboardData"/> class functions.
            </summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Text">
            <summary>The text format. Standard, API constant CF_UNICODETEXT. The default format of <see cref="T:Au.AClipboardData"/> add/get text functions.</summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Image">
            <summary>The image format. Standard, API constant CF_BITMAP. Used by <see cref="T:Au.AClipboardData"/> add/get image functions.</summary>
        </member>
        <member name="F:Au.Types.ClipFormats.Files">
            <summary>The file-list format. Standard, API constant CF_HDROP. Used by <see cref="T:Au.AClipboardData"/> add/get files functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.Html">
            <summary>The HTML format. Registered, name "HTML Format". Used by <see cref="T:Au.AClipboardData"/> add/get HTML functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.Rtf">
            <summary>The RTF format. Registered, name "Rich Text Format". Used by <see cref="T:Au.AClipboardData"/> add/get RTF functions.</summary>
        </member>
        <member name="P:Au.Types.ClipFormats.ClipboardViewerIgnore">
            <summary>
            The "Clipboard Viewer Ignore" registered format.
            </summary>
            <remarks>
            Some clipboard viewer/manager programs don't try to get clipboard data if this format is present. For example Ditto, Clipdiary.
            The copy/paste functions of this library add this format to the clipboard to avoid displaying the temporary text/data in these programs, which also could make the paste function slower and less reliable.
            </remarks>
        </member>
        <member name="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)">
            <summary>
            Registers a clipboard format and returns its id. If already registered, just returns id.
            </summary>
            <param name="name">Format name.</param>
            <param name="textEncoding">Text encoding, if it's a text format. Used by <see cref="M:Au.AClipboardData.GetText(System.Int32)"/>, <see cref="M:Au.AClipboardData.AddText(System.String,System.Int32)"/> and functions that call them. For example <see cref="P:System.Text.Encoding.UTF8"/> or <see cref="P:System.Text.Encoding.Default"/> (ANSI). If null, text of unknown formats is considered Unicode UTF-16 (no encoding/decoding needed).</param>
            <remarks>Calls API <msdn>RegisterClipboardFormat</msdn>.</remarks>
        </member>
        <member name="M:Au.Types.ClipFormats.LibGetTextEncoding(System.Int32,System.Boolean@)">
            <summary>
            Gets text encoding for format.
            Returns null if UTF-16 or if the format is unknown and not in s_textEncoding.
            </summary>
        </member>
        <member name="T:Au.Types.HookData">
            <summary>
            Contains types of hook data for hook procedures set by <see cref="T:Au.AHookWin"/> and <see cref="T:Au.AHookAcc"/>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.Keyboard">
            <summary>
            Event data for the hook procedure set by <see cref="M:Au.AHookWin.Keyboard(System.Action{Au.Types.HookData.Keyboard},System.Boolean,System.Boolean)"/>.
            More info: API <msdn>LowLevelKeyboardProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.Keyboard.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="M:Au.Types.HookData.Keyboard.BlockEvent">
            <summary>
            Call this function to steal this event from other hooks and apps.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsExtended">
            <summary>
            Is extended key.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsInjected">
            <summary>
            true if the event was generated by API such as <msdn>SendInput</msdn>.
            false if the event was generated by the keyboard.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsInjectedByAu">
            <summary>
            true if the event was generated by functions of this library.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsAlt">
            <summary>
            Key Alt is pressed.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.IsUp">
            <summary>
            Is key-up event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.Mod">
            <summary>
            If the key is a modifier key (Shift, Ctrl, Alt, Win), returns the modifier flag. Else returns 0.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.Key">
            <summary>
            If <b>vkCode</b> is a left or right modifier key code (LShift, LCtrl, LAlt, RShift, RCtrl, RAlt, RWin), returns the common modifier key code (Shift, Ctrl, Alt, Win). Else returns <b>vkCode</b>.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Keyboard.IsKey(Au.Types.KKey)">
            <summary>
            Returns true if <i>key</i> == <b>vkCode</b> or <i>key</i> is Shift, Ctrl, Alt or Win and <b>vkCode</b> is LShift/RShift, LCtrl/RCtrl, LAlt/RAlt or RWin.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.LibSendInputFlags">
            <summary>
            Converts flags to API SendInput flags KEYEVENTF_KEYUP and KEYEVENTF_EXTENDEDKEY.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Keyboard.ToString">
            
        </member>
        <member name="P:Au.Types.HookData.Keyboard.vkCode">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.scanCode">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.flags">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.time">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Keyboard.dwExtraInfo">
            <summary>API <msdn>KBDLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AuExtraInfo">
            <summary>
            Extra info value used by functions of this library that generate keyboard events. Low-level hooks receive it in <b>dwExtraInfo</b>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.Mouse">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.AHookWin.Mouse(System.Action{Au.Types.HookData.Mouse},System.Boolean,System.Boolean)"/>.
            More info: API <msdn>LowLevelMouseProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.Mouse.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="M:Au.Types.HookData.Mouse.BlockEvent">
            <summary>
            Call this function to steal this event from other hooks and apps.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.Event">
            <summary>
            What event it is (button, move, wheel).
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButtonDown">
            <summary>
            Is button-down event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButtonUp">
            <summary>
            Is button-up event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsButton">
            <summary>
            Is button event (down or up).
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.Button">
            <summary>
            Converts <see cref="P:Au.Types.HookData.Mouse.Event"/> to <see cref="T:Au.Types.MButtons"/>.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsWheel">
            <summary>
            Is wheel event.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsInjected">
            <summary>
            true if the event was generated by API such as <msdn>SendInput</msdn>.
            false if the event was generated by the mouse.
            </summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.IsInjectedByAu">
            <summary>
            true if the event was generated by functions of this library.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.Mouse.ToString">
            
        </member>
        <member name="P:Au.Types.HookData.Mouse.pt">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.mouseData">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.flags">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.time">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="P:Au.Types.HookData.Mouse.dwExtraInfo">
            <summary>API <msdn>MSLLHOOKSTRUCT</msdn></summary>
        </member>
        <member name="T:Au.Types.HookData.MouseEvent">
            <summary>
            Mouse hook event types. See <see cref="P:Au.Types.HookData.Mouse.Event"/>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCbt">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.AHookWin.ThreadCbt(System.Func{Au.Types.HookData.ThreadCbt,System.Boolean},System.Int32,System.Boolean)"/>.
            More info: API <msdn>CBTProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.code">
            <summary>API <msdn>CBTProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.wParam">
            <summary>API <msdn>CBTProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCbt.lParam">
            <summary>API <msdn>CBTProc</msdn></summary>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.ActivationInfo(System.Boolean@,Au.AWnd@)">
            <summary>
            Returns the window handle of the window being activated and gets some more info.
            </summary>
            <param name="fMouse">true if the reason is the mouse.</param>
            <param name="wPrevActive">The previously active window, or default(AWnd).</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.ACTIVATE.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.CreationInfo(Au.Types.Native.CREATESTRUCT*@,Au.AWnd@)">
            <summary>
            Returns the window handle and gets more info about the created window.
            </summary>
            <param name="c">
            API <msdn>CREATESTRUCT</msdn>.
            You can modify x y cx cy.
            </param>
            <param name="wInsertAfter">Window whose position in the Z order precedes that of the window being created, or default(AWnd).</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.CREATEWND.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.MouseInfo(Au.Types.Native.MOUSEHOOKSTRUCT*@)">
            <summary>
            Returns the mouse message and gets some more info about the mouse event.
            </summary>
            <param name="m">API <msdn>MOUSEHOOKSTRUCT</msdn>.</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.CLICKSKIPPED.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.KeyInfo(System.UInt32@)">
            <summary>
            Returns the key code and gets some more info about the keyboard event.
            </summary>
            <param name="lParam"><i>lParam</i> of the key message. Specifies the repeat count, scan code, etc. See API <msdn>WM_KEYDOWN</msdn>.</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.KEYSKIPPED.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.FocusInfo(Au.AWnd@)">
            <summary>
            Returns the window handle and gets some more info about the focus event.
            </summary>
            <param name="wLostFocus">The previously focused window, or default(AWnd).</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.SETFOCUS.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.MoveSizeInfo(Au.Types.RECT*@)">
            <summary>
            Returns the window handle and gets some more info about the move-size event.
            </summary>
            <param name="r">The new rectangle of the window.</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.MOVESIZE.</exception>
        </member>
        <member name="M:Au.Types.HookData.ThreadCbt.MinMaxInfo(System.Int32@)">
            <summary>
            Returns the window handle and gets some more info about the minimize-maximize-restore event.
            </summary>
            <param name="showState">The new show state. See API <msdn>ShowWindow</msdn>. Minimized 6, maximized 3, restored 9.</param>
            <exception cref="T:System.InvalidOperationException"><b>code</b> is not CbtEvent.MINMAX.</exception>
        </member>
        <member name="T:Au.Types.HookData.CbtEvent">
            <summary>
            CBT hook event types. Used with <see cref="T:Au.Types.HookData.ThreadCbt"/>.
            More info: API <msdn>CBTProc</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadGetMessage">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.AHookWin.ThreadGetMessage(System.Action{Au.Types.HookData.ThreadGetMessage},System.Int32,System.Boolean)"/>.
            More info: API <msdn>GetMsgProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadGetMessage.msg">
            <summary>
            Message parameters.
            API <msdn>MSG</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadKeyboard">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.AHookWin.ThreadKeyboard(System.Func{Au.Types.HookData.ThreadKeyboard,System.Boolean},System.Int32,System.Boolean)"/>.
            More info: API <msdn>KeyboardProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.key">
            <summary>
            The key code.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadKeyboard.lParam">
            <summary>
            <i>lParam</i> of the key message. Specifies the key state, scan code, etc. See API <msdn>KeyboardProc</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadMouse">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.AHookWin.ThreadMouse(System.Func{Au.Types.HookData.ThreadMouse,System.Boolean},System.Int32,System.Boolean)"/>.
            More info: API <msdn>MouseProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.PM_NOREMOVE">
            <summary>
            The message has not been removed from the queue, because called API <msdn>PeekMessage</msdn> with flag PM_NOREMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.message">
            <summary>
            The mouse message, for example WM_MOUSEMOVE.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadMouse.m">
            <summary>
            More info about the mouse message.
            API <msdn>MOUSEHOOKSTRUCT</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCallWndProc">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.AHookWin.ThreadCallWndProc(System.Action{Au.Types.HookData.ThreadCallWndProc},System.Int32,System.Boolean)"/>.
            More info: API <msdn>CallWndProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.sentByOtherThread">
            <summary>
            True if the message was sent by another thread.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProc.msg">
            <summary>
            Message parameters.
            API <msdn>CWPSTRUCT</msdn>.
            </summary>
        </member>
        <member name="T:Au.Types.HookData.ThreadCallWndProcRet">
            <summary>
            Hook data for the hook procedure set by <see cref="M:Au.AHookWin.ThreadCallWndProcRet(System.Action{Au.Types.HookData.ThreadCallWndProcRet},System.Int32,System.Boolean)"/>.
            More info: API <msdn>CallWndRetProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.sentByOtherThread">
            <summary>
            True if the message was sent by another thread.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.ThreadCallWndProcRet.msg">
            <summary>
            Message parameters and the return value.
            API <msdn>CWPRETSTRUCT</msdn>.
            </summary>
        </member>
        <member name="M:Au.Types.HookData.ReplyMessage(System.Boolean)">
            <summary>
            Calls API API <msdn>ReplyMessage</msdn>, which allows to use <see cref="T:Au.AAcc"/> and COM in the hook procedure.
            </summary>
            <param name="cancelEvent">
            Don't notify the target window about the event, and don't call other hook procedures.
            This value is used instead of the return value of the hook procedure, which is ignored.
            </param>
            <remarks>
            It can be used as a workaround for this problem: in low-level hook procedure some functions don't work with some windows. For example cannot get an accessible object or use a COM object. Error/exception "An outgoing call cannot be made since the application is dispatching an input-synchronous call (0x8001010D)".
            </remarks>
        </member>
        <member name="T:Au.Types.HookData.AccHookData">
            <summary>
            Hook data for the hook procedure set by <see cref="T:Au.AHookAcc"/>.
            More info: API <msdn>WinEventProc</msdn>.
            </summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.hook">
            <summary>The caller object of your hook procedure. For example can be used to unhook.</summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.wnd">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.ev">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.idObject">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.idChild">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.idThread">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="F:Au.Types.HookData.AccHookData.eventTime">
            <summary>API <msdn>WinEventProc</msdn></summary>
        </member>
        <member name="M:Au.Types.HookData.AccHookData.GetAcc">
            <summary>
            Calls <see cref="M:Au.AAcc.FromEvent(Au.AWnd,Au.Types.AccOBJID,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.BIEvents">
            <summary>
            Used with <see cref="T:Au.AInputBlocker"/> class to specify what user input types to block (keys, mouse).
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.None">
            <summary>
            Do not block.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.Keys">
            <summary>
            Block keys. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.MouseClicks">
            <summary>
            Block mouse clicks and wheel. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.MouseMoving">
            <summary>
            Block mouse moving. Except if generated by functions of this library.
            </summary>
        </member>
        <member name="F:Au.Types.BIEvents.All">
            <summary>
            Block keys, mouse clicks, wheel and mouse moving. Except if generated by functions of this library.
            This flag incluses flags <b>Keys</b>, <b>MouseClicks</b> and <b>MouseMoving</b>.
            </summary>
        </member>
        <member name="T:Au.Types.KMod">
            <summary>
            Modifier keys as flags.
            </summary>
            <remarks>
            The values don't match those in the .NET enum <see cref="T:System.Windows.Forms.Keys"/>. This library does not use the .NET enum for modifier keys, mostly because it: does not have Win as modifier flag; confusing names, for example Alt and Menu.
            </remarks>
            <seealso cref="M:Au.AKeys.More.KModToKeys(Au.Types.KMod)"/>
            <seealso cref="M:Au.AKeys.More.KModFromKeys(System.Windows.Forms.Keys)"/>
            <seealso cref="T:Au.Types.KKey"/>
        </member>
        <member name="T:Au.Types.KKey">
            <summary>
            Virtual-key codes.
            </summary>
            <remarks>
            The values are the same as the native VK_ constants. Also the same as in the <see cref="T:System.Windows.Forms.Keys"/> enum, but not as in the WPF <b>Key</b> enum.
            Some key names are different than VK_/Keys, for example Alt instead of VK_MENU/Menu.
            Most rare and obsolete keys are not included. You can use Keys or VK_ (int) like <c>(KKey)Keys.Attn</c>.
            This library does not use the .NET <b>Keys</b> enum, mostly because it includes modifier key flags and it's easy to confuse eg Shift (flag) with ShiftKey (key). Also this library does not use the WPF <b>Key</b> enum; its values don't match the native VK_ constants that must be used with API functions.
            </remarks>
            <seealso cref="T:Au.Types.KMod"/>
        </member>
        <member name="F:Au.Types.KKey.Break">
            <summary>Ctrl+Pause.</summary>
        </member>
        <member name="F:Au.Types.KKey.Clear">
            <summary>Shift+NumPad5, or NumPad5 when NumLock off.</summary>
        </member>
        <member name="F:Au.Types.KKey.D0">
            <summary>The 0 ) key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D1">
            <summary>The 1 ! key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D2">
            <summary>The 2 @ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D3">
            <summary>The 3 # key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D4">
            <summary>The 4 $ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D5">
            <summary>The 5 % key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D6">
            <summary>The 6 ^ key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D7">
            <summary>The 7 &amp; key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D8">
            <summary>The 8 * key.</summary>
        </member>
        <member name="F:Au.Types.KKey.D9">
            <summary>The 9 ( key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Win">
            <summary>The left Win key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RWin">
            <summary>The right Win key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Apps">
            <summary>The Application/Menu key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Multiply">
            <summary>The numpad * key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Add">
            <summary>The numpad + key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Subtract">
            <summary>The numpad - key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Decimal">
            <summary>The numpad . key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Divide">
            <summary>The numpad / key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LShift">
            <summary>The left Shift key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RShift">
            <summary>The right Shift key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LCtrl">
            <summary>The left Ctrl key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RCtrl">
            <summary>The right Ctrl key.</summary>
        </member>
        <member name="F:Au.Types.KKey.LAlt">
            <summary>The left Alt key.</summary>
        </member>
        <member name="F:Au.Types.KKey.RAlt">
            <summary>The right Alt key.</summary>
        </member>
        <member name="F:Au.Types.KKey.Packet">
            <summary>VK_PACKET. Not a key.</summary>
        </member>
        <member name="T:Au.Types.KText">
            <summary>
            Used as an argument type with <see cref="M:Au.AKeys.Key(System.Object[])"/> and <see cref="M:Au.AStatic.Key(System.Object[])"/> to send text instead of keys. See example.
            </summary>
            <example>
            <code><![CDATA[
            Key((KText)"user", "Tab", (KText)"password", "Enter");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.KText.op_Implicit(System.String)~Au.Types.KText">
            
        </member>
        <member name="M:Au.Types.KText.op_Implicit(Au.Types.KText)~System.String">
            
        </member>
        <member name="T:Au.Types.KHotkey">
            <summary>
            Defines a hotkey as <see cref="T:Au.Types.KMod"/> and <see cref="T:Au.Types.KKey"/>.
            Has implicit conversion operators from string like "Ctrl+Shift+K", tuple (KMod, KKey), enum KKey, enum Keys.
            </summary>
        </member>
        <member name="P:Au.Types.KHotkey.Mod">
            <summary>
            Modifier keys (flags).
            </summary>
        </member>
        <member name="P:Au.Types.KHotkey.Key">
            <summary>
            Key without modifier keys.
            </summary>
        </member>
        <member name="M:Au.Types.KHotkey.#ctor(Au.Types.KMod,Au.Types.KKey)">
            
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.String)~Au.Types.KHotkey">
            <summary>Implicit conversion from string like "Ctrl+Shift+K".</summary>
            <exception cref="T:System.ArgumentException">"Error in hotkey."</exception>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.ValueTuple{Au.Types.KMod,Au.Types.KKey})~Au.Types.KHotkey">
            <summary>Implicit conversion from tuple (KMod, KKey).</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(Au.Types.KKey)~Au.Types.KHotkey">
            <summary>Implicit conversion from <see cref="T:Au.Types.KKey"/> (hotkey without modifiers).</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Implicit(System.Windows.Forms.Keys)~Au.Types.KHotkey">
            <summary>Implicit conversion from <see cref="T:System.Windows.Forms.Keys"/> like <c>Keys.Ctrl|Keys.B</c>.</summary>
        </member>
        <member name="M:Au.Types.KHotkey.op_Explicit(Au.Types.KHotkey)~System.Windows.Forms.Keys">
            <summary>Explicit conversion to <see cref="T:System.Windows.Forms.Keys"/>.</summary>
        </member>
        <member name="M:Au.Types.KHotkey.Deconstruct(Au.Types.KMod@,Au.Types.KKey@)">
            <summary>Allows to split a <b>KHotkey</b> variable like <c>var (mod, key) = hotkey;</c></summary>
        </member>
        <member name="T:Au.Types.MButton">
            <summary>
            <i>button</i> parameter type for <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)"/> and similar functions.
            </summary>
            <remarks>
            There are two groups of values:
            1. Button (Left, Right, Middle, X1, X2). Default or 0: Left.
            2. Action (Down, Up, DoubleClick). Default: click.
            
            Multiple values from the same group cannot be combined. For example Left|Right is invalid.
            Values from different groups can be combined. For example Right|Down.
            </remarks>
        </member>
        <member name="F:Au.Types.MButton.Left">
            <summary>The left button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Right">
            <summary>The right button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Middle">
            <summary>The middle button.</summary>
        </member>
        <member name="F:Au.Types.MButton.X1">
            <summary>The 4-th button.</summary>
        </member>
        <member name="F:Au.Types.MButton.X2">
            <summary>The 5-th button.</summary>
        </member>
        <member name="F:Au.Types.MButton.Down">
            <summary>(flag) Press and don't release.</summary>
        </member>
        <member name="F:Au.Types.MButton.Up">
            <summary>(flag) Don't press, only release.</summary>
        </member>
        <member name="F:Au.Types.MButton.DoubleClick">
            <summary>(flag) Double-click.</summary>
        </member>
        <member name="T:Au.Types.MButtons">
            <summary>
            Flags for mouse buttons.
            Used with functions that check mouse button states (down or up).
            </summary>
            <remarks>
            The values are the same as <see cref="T:System.Windows.Forms.MouseButtons"/>, therefore can be cast to/from.
            </remarks>
        </member>
        <member name="F:Au.Types.MButtons.Left">
            <summary>The left button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.Right">
            <summary>The right button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.Middle">
            <summary>The middle button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.X1">
            <summary>The 4-th button.</summary>
        </member>
        <member name="F:Au.Types.MButtons.X2">
            <summary>The 5-th button.</summary>
        </member>
        <member name="T:Au.Types.MRelease">
            <summary>
            The <b>Dispose</b> function releases mouse buttons pressed by the function that returned this variable.
            </summary>
            <example>
            Drag and drop: start at x=8 y=8, move 20 pixels down, drop.
            <code><![CDATA[
            using(AMouse.LeftDown(w, 8, 8)) AMouse.MoveRelative(0, 20); //the button is auto-released when the 'using' code block ends
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Types.MRelease.op_Implicit(Au.Types.MButton)~Au.Types.MRelease">
            
        </member>
        <member name="M:Au.Types.MRelease.Dispose">
            <summary>
            Releases mouse buttons pressed by the function that returned this variable.
            </summary>
        </member>
        <member name="T:Au.Types.MCursor">
            <summary>
            Standard cursor ids.
            Used with <see cref="M:Au.AMouse.WaitForCursor(System.Double,Au.Types.MCursor,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.MCursor.Arrow">
            <summary>Standard arrow.</summary>
        </member>
        <member name="F:Au.Types.MCursor.IBeam">
            <summary>I-beam (text editing).</summary>
        </member>
        <member name="F:Au.Types.MCursor.Wait">
            <summary>Hourglass.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Cross">
            <summary>Crosshair.</summary>
        </member>
        <member name="F:Au.Types.MCursor.UpArrow">
            <summary>Vertical arrow.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNWSE">
            <summary>Double-pointed arrow pointing northwest and southeast.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNESW">
            <summary>Double-pointed arrow pointing northeast and southwest.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeWE">
            <summary>Double-pointed arrow pointing west and east.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeNS">
            <summary>Double-pointed arrow pointing north and south.</summary>
        </member>
        <member name="F:Au.Types.MCursor.SizeAll">
            <summary>Four-pointed arrow pointing north, south, east, and west.</summary>
        </member>
        <member name="F:Au.Types.MCursor.No">
            <summary>Slashed circle.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Hand">
            <summary>Hand.</summary>
        </member>
        <member name="F:Au.Types.MCursor.AppStarting">
            <summary>Standard arrow and small hourglass.</summary>
        </member>
        <member name="F:Au.Types.MCursor.Help">
            <summary>Arrow and question mark.</summary>
        </member>
        <member name="T:Au.Types.OsdShowMode">
            <summary>
            Whether <see cref="M:Au.AOsd.Show"/> waits or shows the OSD window in this or new thread.
            </summary>
            <remarks>
            If this thread has windows, any value can be used, but usually <b>Auto</b> (default) or <b>ThisThread</b> is the best.
            </remarks>
        </member>
        <member name="F:Au.Types.OsdShowMode.Auto">
            <summary>Depends on <see cref="M:Au.AThread.HasMessageLoop(System.Boolean@)"/>. If it is true, uses <b>ThisThread</b>, else <b>StrongThread</b>. Does not wait.</summary>
        </member>
        <member name="F:Au.Types.OsdShowMode.ThisThread">
            <summary>
            Show the OSD window in this thread and don't wait.
            Should not be used if this thread does not process messages and therefore cannot have windows.
            </summary>
        </member>
        <member name="F:Au.Types.OsdShowMode.WeakThread">
            <summary>Show the OSD window in new thread and don't wait. Set <see cref="P:System.Threading.Thread.IsBackground"/>=true, so that the OSD is closed when other threads of this app end.</summary>
        </member>
        <member name="F:Au.Types.OsdShowMode.StrongThread">
            <summary>Show the OSD window in new thread and don't wait. Set <see cref="P:System.Threading.Thread.IsBackground"/>=false, so that the OSD is not closed when other threads of this app end.</summary>
        </member>
        <member name="F:Au.Types.OsdShowMode.Wait">
            <summary>
            Show the OSD window in this thread and wait until it disappears.
            Waits <see cref="P:Au.AOsd.SecondsTimeout"/> seconds. While waiting, dispatches messages etc; see <see cref="M:Au.ATime.SleepDoEvents(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.OutServMessageType">
            <summary>
            See <see cref="P:Au.Types.OutServMessage.Type"/>.
            </summary>
        </member>
        <member name="F:Au.Types.OutServMessageType.Write">
            <summary>
            Add line to the output window.
            All <see cref="T:Au.Types.OutServMessage"/> members can be used.
            </summary>
        </member>
        <member name="F:Au.Types.OutServMessageType.Clear">
            <summary>
            Clear the output window.
            Only <see cref="P:Au.Types.OutServMessage.Type"/> is used.
            </summary>
        </member>
        <member name="T:Au.Types.OutServMessage">
            <summary>
            Contains message text and/or related info.
            More info: <see cref="T:Au.AOutputServer"/>, <see cref="M:Au.AOutputServer.GetMessage(Au.Types.OutServMessage@)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.OutServMessage.Type">
            <summary>
            Message type.
            Currently there are 2 types - Write and Clear.
            </summary>
        </member>
        <member name="P:Au.Types.OutServMessage.Text">
            <summary>
            Message text.
            Used with OutServMessageType.Write.
            </summary>
        </member>
        <member name="P:Au.Types.OutServMessage.TimeUtc">
            <summary>
            Message time in FILETIME format, UTC.
            Used with OutServMessageType.Write.
            To convert to string: <c>DateTime.FromFileTimeUtc(m.TimeUtc).ToLocalTime().ToString()</c>.
            </summary>
        </member>
        <member name="P:Au.Types.OutServMessage.Caller">
            <summary>
            The <see cref="P:Au.ATask.Name"/> property value of the process that called the Write/Print/etc method.
            Used with OutServMessageType.Write.
            </summary>
        </member>
        <member name="M:Au.Types.OutServMessage.ToString">
            
        </member>
        <member name="T:Au.Types.WIArea">
            <summary>
            Defines the search area for <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/> and similar functions.
            </summary>
            <remarks>
            It can be a window/control, accessible object, another image or a rectangle in screen.
            Also allows to specify a rectangle in it, which makes the search area smaller and the function faster.
            Has implicit conversions from AWnd, AAcc, Bitmap, RECT (rectangle in screen), tuple (AWnd, RECT), tuple (Acc, RECT).
            Example: <c>AWinImage.Find((w, (left, top, width, height)), "image.png");</c>.
            </remarks>
        </member>
        <member name="T:Au.Types.WIFlags">
            <summary>
            Flags for <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.WIFlags.WindowDC">
            <summary>
            Get pixels from the device context (DC) of the window client area, not from screen DC. Usually much faster.
            Can get pixels from window parts that are covered by other windows or offscreen. But not from hidden and minimized windows.
            Does not work on Windows 7 if Aero theme is turned off. Then this flag is ignored.
            Cannot find images in some windows (including Windows Store apps), and in some window parts (glass). All pixels captured from these windows/parts are black.
            If the window is DPI-scaled, the image must be captured from its non-scaled version.
            </summary>
        </member>
        <member name="F:Au.Types.WIFlags.PrintWindow">
            <summary>
            Use API <msdn>PrintWindow</msdn> to get window pixels.
            Like <b>WindowDC</b>, works with background windows, etc. Differences:
            - On Windows 8.1 and later works with all windows (including Windows Store apps) and all window parts.
            - Works without Aero theme too.
            - Slower.
            - Some windows may flicker.
            - Does not work with windows of higher UAC integrity level. Then this flag is ignored.
            </summary>
        </member>
        <member name="T:Au.Types.WIAlso">
            <summary>
            Used with <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/> and <see cref="M:Au.AWinImage.Wait(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>. Its callback function (parameter <i>also</i>) can return one of these values.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.OkReturn">
            <summary>
            Stop searching.
            Let the main function (<b>Find</b> or <b>Wait</b>) return current result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.OkFindMore">
            <summary>
            Find more instances of current image. If used list of images, also search for other images.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.OkFindMoreOfThis">
            <summary>
            Find more instances of current image. When used list of images, don't search for other images.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.OkFindMoreOfList">
            <summary>
            If used list of images, search for other images. Don't search for more instances of current image.
            Then let the main function return current result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.NotFound">
            <summary>
            Stop searching.
            Let <b>Find</b> return null. Let <b>Wait</b> continue waiting. But if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.FindOther">
            <summary>
            Find more instances of current image. If used list of images, also search for other images.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.FindOtherOfThis">
            <summary>
            Find more instances of current image. When used list of images, don't search for other images.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="F:Au.Types.WIAlso.FindOtherOfList">
            <summary>
            If used list of images, search for other images. Don't search for more instances of current image.
            If not found, let <b>Find</b> return null; let <b>Wait</b> continue waiting; but if a <b>Find...Return</b> value used previously, return that result.
            </summary>
        </member>
        <member name="T:Au.Types.WICFlags">
            <summary>
            Flags for <see cref="M:Au.AWinImage.CaptureUI(Au.Types.WICResult@,Au.Types.WICFlags,Au.Types.AnyWnd)"/>.
            </summary>
            <remarks>
            Only one of flags <b>Image</b>, <b>Color</b> and <b>Rectangle</b> can be used. If none, can capture image or color.
            </remarks>
        </member>
        <member name="F:Au.Types.WICFlags.Image">
            <summary>Can capture only image, not color.</summary>
        </member>
        <member name="F:Au.Types.WICFlags.Color">
            <summary>Can capture only color, not image.</summary>
        </member>
        <member name="F:Au.Types.WICFlags.Rectangle">
            <summary>Capture only rectangle, not image/color.</summary>
        </member>
        <member name="F:Au.Types.WICFlags.WindowDC">
            <summary>
            Get pixels from the client area device context (DC) of a user-selected window, not from screen DC.
            More info: <see cref="F:Au.Types.WIFlags.WindowDC"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WICFlags.PrintWindow">
            <summary>
            Get pixels from the client area of a user-selected window using API <msdn>PrintWindow</msdn>.
            More info: <see cref="F:Au.Types.WIFlags.PrintWindow"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WICResult">
            <summary>
            Results of <see cref="M:Au.AWinImage.CaptureUI(Au.Types.WICResult@,Au.Types.WICFlags,Au.Types.AnyWnd)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WICResult.image">
            <summary>
            Captured image.
            null if captured single pixel color or used flag <see cref="F:Au.Types.WICFlags.Rectangle"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WICResult.color">
            <summary>
            Captured color.
            </summary>
        </member>
        <member name="F:Au.Types.WICResult.rect">
            <summary>
            Location of the captured image or rectangle, in screen coordinates.
            </summary>
        </member>
        <member name="F:Au.Types.WICResult.wnd">
            <summary>
            Window or control containing the captured image or rectangle, if whole image is in its client area.
            In some cases may be incorrect, for example if windows moved/opened/closed/etc while capturing.
            </summary>
        </member>
        <member name="T:Au.Types.STIFlags">
            <summary>
            Flags for <see cref="M:Au.AExtString.ToInt(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/> and similar functions.
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.NoHex">
            <summary>
            Don't support hexadecimal numbers (numbers with prefix "0x").
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.IsHexWithout0x">
            <summary>
            The number in string is hexadecimal without a prefix, like "1A".
            </summary>
        </member>
        <member name="F:Au.Types.STIFlags.DontSkipSpaces">
            <summary>
            Fail if string starts with a whitespace character.
            </summary>
        </member>
        <member name="T:Au.Types.SUpper">
            <summary>
            Used with <see cref="M:Au.AExtString.Upper(System.String,Au.Types.SUpper,System.Globalization.CultureInfo)"/>
            </summary>
        </member>
        <member name="F:Au.Types.SUpper.AllChars">
            <summary>
            Convert all characters to upper case.
            </summary>
        </member>
        <member name="F:Au.Types.SUpper.FirstChar">
            <summary>
            Convert only the first character to upper case.
            </summary>
        </member>
        <member name="F:Au.Types.SUpper.TitleCase">
            <summary>
            Convert the first character of each word to upper case and other characters to lower case.
            Calls <see cref="M:System.Globalization.TextInfo.ToTitleCase(System.String)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXMatch">
            <summary>
            Regular expression match info.
            Used with <see cref="T:Au.ARegex"/> class functions and String extension methods like <see cref="M:Au.AExtString.RegexMatch(System.String,System.String,Au.Types.RXMatch@,Au.Types.RXFlags,System.Nullable{System.Range})"/>.
            </summary>
            <remarks>
            Contains info about a regular expression match found in the subject string: index, length, substring, etc.
            Also contains an array of group matches, as <see cref="T:Au.Types.RXGroup"/>. Groups are regular expression parts enclosed in (), except (?...).
            Group matches can be accessed like array elements. Group 0 is whole match. Group 1 is the first group. See examples.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "ab cd-45-ef gh";
            if(s.RegexMatch(@"\b([a-z]+)-(\d+)\b", out RXMatch m))
            	Print(
            		m.GroupCountPlusOne, //3 (whole match and 2 groups)
            		m.Start, //3, same as m[0].Index
            		m.Value, //"cd-45-ef", same as m[0].Value
            		m[1].Start, //3
            		m[1].Value, //"cd"
            		m[2].Start, //6
            		m[2].Value //"45"
            		);
            ]]></code>
            A group in the subject string may not exist even if whole match found. Then its Exists property is false, Index -1, Length 0, Value null.
            <code><![CDATA[
            var s = "ab cd--ef gh";
            if(s.RegexMatch(@"\b([a-z]+)-(\d+)?-([a-z]+)\b", out RXMatch m))
            	Print(
            		m.GroupCountPlusOne, //4 (whole match and 3 groups)
            		m[2].Exists, //false
            		m[2].Start, //-1
            		m[2].Length, //0
            		m[2].Value //null
            		);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Types.RXMatch.GroupCountPlusOne">
            <summary>
            The number of groups in the regular expression, + 1 for the whole match.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Start">
            <summary>
            Start offset of the match in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.End">
            <summary>
            <see cref="P:Au.Types.RXMatch.Start"/> + <see cref="P:Au.Types.RXMatch.Length"/>. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Length">
            <summary>
            Length of the match in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Value">
            <summary>
            The match (substring) in the subject string. The same as that of group 0.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Subject">
            <summary>
            The subject string in which this match was found.
            </summary>
        </member>
        <member name="M:Au.Types.RXMatch.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RXMatch.Value"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.StartNoK">
            <summary>
            Start offset of whole match regardless of \K.
            When the regular expression contains \K, this is less than <see cref="P:Au.Types.RXMatch.Start"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Mark">
            <summary>
            The name of a found mark, or null.
            Marks can be inserted in regular expression pattern like (*MARK:name) or (*:name).
            After a full successful match, it is the last mark encountered on the matching path through the pattern. After a "no match" or a partial match, it is the last encountered mark. For example, consider this pattern: "^(*MARK:A)((*MARK:B)a|b)c". When it matches "bc", the mark is A. The B mark is "seen" in the first branch of the group, but it is not on the matching path. On the other hand, when this pattern fails to match "bx", the mark is B.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Exists">
            <summary>
            Gets the return value of the <see cref="M:Au.ARegex.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/> call.
            Can be false only when the function returned false but a mark is available (see <see cref="P:Au.Types.RXMatch.Mark"/>). Otherwise, when the function returns flase, it returns null instead of a RXMatch object.
            When false, all properties except Exists and Mark have undefined values or throw exception.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.IsPartial">
            <summary>
            Returns true if this match is partial.
            Partial match is possible if used a PARTIAL_ flag.
            </summary>
        </member>
        <member name="P:Au.Types.RXMatch.Item(System.Int32)">
            <summary>
            Gets group info. Index 0 is whole match. Index 1 is the first group.
            </summary>
            <param name="group">1-based group index, or 0 for whole match.</param>
            <exception cref="T:System.IndexOutOfRangeException">The group index is &lt; 0 or &gt;= <see cref="P:Au.Types.RXMatch.GroupCountPlusOne"/>.</exception>
        </member>
        <member name="P:Au.Types.RXMatch.Item(System.String)">
            <summary>
            Gets group info of a named group.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentException">Unknown group name.</exception>
            <remarks>
            If more than 1 group have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
        </member>
        <member name="M:Au.Types.RXMatch.GroupNumberFromName(System.String)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            If more than 1 group have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
            <seealso cref="M:Au.ARegex.GroupNumberFromName(System.String)"/>
        </member>
        <member name="M:Au.Types.RXMatch.GroupNumberFromName(System.String,System.Boolean@)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <param name="notUnique">Receives true if more than 1 group have this name.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            If more than 1 group have this name, prefers the first group that matched (<see cref="P:Au.Types.RXGroup.Exists"/> is true).
            </remarks>
            <seealso cref="M:Au.ARegex.GroupNumberFromName(System.String)"/>
        </member>
        <member name="M:Au.Types.RXMatch.ExpandReplacement(System.String)">
            <summary>
            Returns the expanded version of the specified replacement pattern.
            </summary>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also: replaces $* with the name of the last encountered mark; replaces ${+func} with the return value of a function registered with <see cref="M:Au.ARegex.AddReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.String})"/>.
            </param>
            <remarks>
            Works like <see cref="M:System.Text.RegularExpressions.Match.Result(System.String)"/>.
            See also: <see cref="M:Au.ARegex.Replace(System.String,System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            </remarks>
        </member>
        <member name="T:Au.Types.RXGroup">
            <summary>
            Regular expression group match info.
            Used with <see cref="T:Au.Types.RXMatch"/>, <see cref="T:Au.ARegex"/> and some String extension methods.
            </summary>
            <remarks>
            Groups are regular expression parts enclosed in (). Except non-capturing parts, like (?:...) and (?options). A RXGroup variable contains info about a group found in the subject string: index, length, substring.
            
            Some groups specified in regular expression may not exist in the subject string even if it matches the regular expression. For example, regular expression "A(\d+)?B" matches string "AB", but group (\d+) does not exist. Then <see cref="P:Au.Types.RXGroup.Exists"/> is false, <see cref="P:Au.Types.RXGroup.Start"/> -1, <see cref="P:Au.Types.RXGroup.Length"/> 0, <see cref="P:Au.Types.RXGroup.Value"/> null.
            
            When a group matches multiple times, the RXGroup variable contains only the last instance. For example, if subject is <c>"begin 12 345 67 end"</c> and regular expression is <c>(\d+ )+</c>, value of group 1 is <c>"67"</c>. If you need all instances (<c>"12"</c>, <c>"345"</c>, <c>"67"</c>), instead use .NET <see cref="T:System.Text.RegularExpressions.Regex"/> and <see cref="P:System.Text.RegularExpressions.Group.Captures"/>. Also you can get all instances with <see cref="P:Au.ARegex.Callout"/>.
            
            Examples and more info: <see cref="T:Au.Types.RXMatch"/>, <see cref="T:Au.ARegex"/>.
            </remarks>
        </member>
        <member name="P:Au.Types.RXGroup.Start">
            <summary>
            Start offset of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.End">
            <summary>
            <see cref="P:Au.Types.RXGroup.Start"/> + <see cref="P:Au.Types.RXGroup.Length"/>.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Length">
            <summary>
            Length of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Value">
            <summary>
            String value of the group match in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXGroup.Exists">
            <summary>
            Returns true if the group exists in the subject string, false if does not exist.
            More info in <see cref="T:Au.Types.RXGroup"/> topic. Example in <see cref="T:Au.Types.RXMatch"/> topic.
            </summary>
            <remarks>
            Other ways to detect it: if a group does not exist, its Index is -1 and Value is null.
            </remarks>
        </member>
        <member name="M:Au.Types.RXGroup.ToString">
            <summary>
            Returns <see cref="P:Au.Types.RXGroup.Value"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXCalloutFunc">
            <summary>
            Delegate type of callout callback function.
            See <see cref="P:Au.ARegex.Callout"/>.
            </summary>
        </member>
        <member name="T:Au.Types.RXCalloutData">
            <summary>
            Managed version of PCRE API struct pcre2_callout_block.
            When you set <see cref="P:Au.ARegex.Callout"/>, your callout function's parameter is of this type.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            Most properties are pcre2_callout_block fields as documented in PCRE help. Other properties and methods are easier/safer versions of unsafe fields like offset_vector.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.Result">
            <summary>
            Sets the return value of the callout function, as documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            Default 0.
            If 1, matching fails at the current point, but the testing of other matching possibilities goes ahead, just as if a lookahead assertion had failed.
            If -1 (PCRE2_ERROR_NOMATCH), the match function returns false (no match). Values less tan -2 are PCRE error codes and cause exception.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_number">
            <summary>
            Callout number, eg 5 for "(?C5)".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.capture_top">
            <summary>
            One more than the number of the highest numbered captured group so far.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.capture_last">
            <summary>
            The number of the most recently captured group.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_flags">
            <summary>
            Flags.
            1 PCRE2_CALLOUT_STARTMATCH, 2 PCRE2_CALLOUT_BACKTRACK.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.start_match">
            <summary>
            The offset within the subject string at which the current match attempt started. But depends on \K etc.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.current_position">
            <summary>
            The current offset within the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.pattern_position">
            <summary>
            The offset in the regular expression to the next item to be matched.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.next_item_length">
            <summary>
            The length of the next item to be processed in the regular expression.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_string_offset">
            <summary>
            The callout string offset in the regular expression. Used with callouts like "(?C'calloutString')".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.callout_string">
            <summary>
            The callout string, eg "xyz" for "(?C'xyz')".
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.mark">
            <summary>
            The most recently passed (*MARK), (*PRUNE), or (*THEN) item in the match, or null if no such items have been passed.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            </summary>
        </member>
        <member name="M:Au.Types.RXCalloutData.Group(System.Int32)">
            <summary>
            Gets the start index and length of the specified group in the subject string.
            </summary>
            <param name="group">Group number (1-based index).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>group</i> must be &gt; 0 and &lt; capture_top.</exception>
        </member>
        <member name="M:Au.Types.RXCalloutData.GroupValue(System.Int32)">
            <summary>
            Gets the value (substring) of the specified group.
            </summary>
            <param name="group">Group number (1-based index).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>group</i> must be &gt; 0 and &lt; capture_top.</exception>
        </member>
        <member name="P:Au.Types.RXCalloutData.LastGroup">
            <summary>
            Gets the start index and length of the most recently captured group in the subject string.
            </summary>
        </member>
        <member name="P:Au.Types.RXCalloutData.LastGroupValue">
            <summary>
            Gets the value (substring) of the most recently captured group.
            </summary>
        </member>
        <member name="T:Au.Types.RXFlags">
            <summary>
            Flags for <see cref="T:Au.ARegex"/> constructor.
            Documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>.
            </summary>
            <remarks>
            Many options also can be specified in regular expression (RE):
            - These can be anywhere in RE: (?i) CASELESS, (?m) MULTILINE, (?s) DOTALL, (?n) NO_AUTO_CAPTURE, (?x) EXTENDED, (?xx) EXTENDED_MORE, (?J) DUPNAMES, (?U) UNGREEDY. Can be multiple, like (?ms). Can be unset, like (?-i). RE "\Qtext\E" is like RE "text" with flag LITERAL.
            - Instead of ANCHORED can be used \A or \G at the start of RE. Or ^, except in multiline mode.
            - Instead of ENDANCHORED can be used \z at the end of RE. Or $, except in multiline mode.
            - Flag UTF is implicitly added if RE contains non-ASCII characters and there is no flag NEVER_UTF.
            - These must be at the very start and are named like flags: (*UTF), (*UCP), (*NOTEMPTY), (*NOTEMPTY_ATSTART), (*NO_AUTO_POSSESS), (*NO_DOTSTAR_ANCHOR), (*NO_START_OPT).
            - More info in <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">PCRE syntax reference</see>.
            
            Some of RXFlags flags also exist in <see cref="T:Au.Types.RXMatchFlags"/>. You can set them either when calling ARegex constructor or when calling ARegex functions that have parameter <i>more</i>. You can use different flags for each function call with the same ARegex variable.
            </remarks>
        </member>
        <member name="F:Au.Types.RXFlags.UTF">
            <summary>
            Fully support Unicode text (case-insensitivity etc). More info in PCRE documentation topic <see href="https://www.pcre.org/current/doc/html/pcre2unicode.html">pcre2unicode</see>.
            This flag is implicitly added if regular expression contains non-ASCII characters and there is no flag NEVER_UTF.
            </summary>
        </member>
        <member name="T:Au.Types.RXMatchFlags">
            <summary>
            Flags for <see cref="M:Au.ARegex.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/> and other <see cref="T:Au.ARegex"/> class functions.
            Documented in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>.
            </summary>
            <remarks>
            These flags also exist in <see cref="T:Au.Types.RXFlags"/> (ARegex constructor flags). You can set them either when calling constructor or when calling other functions.
            </remarks>
        </member>
        <member name="T:Au.Types.SegSep">
            <summary>
            Contains several string constants that can be used with some 'split string' functions of this library to specify separators.
            </summary>
        </member>
        <member name="F:Au.Types.SegSep.Whitespace">
            <summary>
            Specifies that separators are spaces, tabs, newlines and other characters for which <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> returns true.
            </summary>
        </member>
        <member name="F:Au.Types.SegSep.Word">
            <summary>
            Specifies that separators are all characters for which <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns false.
            </summary>
        </member>
        <member name="F:Au.Types.SegSep.Line">
            <summary>
            Specifies that separators are substrings "\r\n", as well as single characters '\r' and '\n'.
            </summary>
        </member>
        <member name="T:Au.Types.SegFlags">
            <summary>
            Flags for <see cref="M:Au.AExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/> and some other functions.
            </summary>
        </member>
        <member name="F:Au.Types.SegFlags.NoEmpty">
            <summary>
            Don't return empty substrings.
            For example, is string is "one  two " and separators is " ", return {"one", "two"} instead of {"one", "", "two", ""}.
            </summary>
        </member>
        <member name="T:Au.Types.SegParser">
            <summary>
            Splits a string into substrings as start/end offsets or strings.
            </summary>
            <remarks>
            Can be used with foreach. Normally you don't create <b>SegParser</b> instances explicitly; instead use <see cref="M:Au.AExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/> with foreach.
            Also used by <see cref="M:Au.AExtString.SegSplit(System.String,System.String,Au.Types.SegFlags,System.Int32,System.Nullable{System.Range})"/> and <see cref="M:Au.AExtString.SegLines(System.String,System.Boolean,System.Int32,System.Nullable{System.Range})"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.SegParser.#ctor(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})">
            <summary>
            Initializes this instance to split a string.
            </summary>
            <param name="s">The string.</param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.SegSep"/> constants.</param>
            <param name="flags"></param>
            <param name="range">Part of the string to split.</param>
        </member>
        <member name="M:Au.Types.SegParser.ToStringArray(System.Int32)">
            <summary>
            Returns segment values as string[].
            </summary>
            <param name="maxCount">The maximal number of substrings to get. If negative (default), gets all. Else if there are more substrings, the last element will contain single substring, unlike with <see cref="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)"/>.</param>
        </member>
        <member name="T:Au.Types.WXType">
            <summary>
            The type of text (wildcard expression) of a <see cref="T:Au.AWildex"/> variable.
            </summary>
        </member>
        <member name="F:Au.Types.WXType.Text">
            <summary>
            Simple text (option t, or no *? characters and no t r R options).
            </summary>
        </member>
        <member name="F:Au.Types.WXType.Wildcard">
            <summary>
            Wildcard (has *? characters and no t r R options).
            <b>Match</b> calls <see cref="M:Au.AExtString.Like(System.String,System.String,System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXType.RegexPcre">
            <summary>
            PCRE regular expression (option r).
            <b>Match</b> calls <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXType.RegexNet">
            <summary>
            .NET egular expression (option R).
            <b>Match</b> calls <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXType.Multi">
            <summary>
            Multiple parts (option m).
            <b>Match</b> calls <b>Match</b> for each part (see <see cref="P:Au.AWildex.MultiArray"/>) and returns true if all negative (option n) parts return true (or there are no such parts) and some positive (no option n) part returns true (or there are no such parts).
            If you want to implement a different logic, call <b>Match</b> for each <see cref="P:Au.AWildex.MultiArray"/> element (instead of calling <b>Match</b> for this variable).
            </summary>
        </member>
        <member name="T:Au.Types.ATRole">
            <summary>
            <see cref="P:Au.ATask.Role"/>.
            </summary>
        </member>
        <member name="F:Au.Types.ATRole.ExeProgram">
            <summary>
            The task runs as normal .exe program.
            It can be started from editor or not. It can run on computers where editor not installed.
            </summary>
        </member>
        <member name="F:Au.Types.ATRole.MiniProgram">
            <summary>
            The task runs in Au.Task.exe process.
            It can be started only from editor.
            </summary>
        </member>
        <member name="F:Au.Types.ATRole.EditorExtension">
            <summary>
            The task runs in editor process.
            </summary>
        </member>
        <member name="T:Au.Types.AScript">
            <summary>
            This class is used in automation script files as base of their main class. Adds some features.
            </summary>
            <remarks>
            This class adds these features:
            1. The static constructor subscribes to the <see cref="E:System.AppDomain.UnhandledException"/> event. On unhandled exception prints exception info. Without this class not all unhandled exceptions would be printed.
            2. Provides virtual function <see cref="M:Au.Types.AScript.OnUnhandledException(System.UnhandledExceptionEventArgs)"/>. The script can override it.
            3. Provides property <see cref="P:Au.Types.AScript.Triggers"/>.
            
            More features may be added in the future.
            </remarks>
        </member>
        <member name="M:Au.Types.AScript.#ctor">
            
        </member>
        <member name="M:Au.Types.AScript.OnUnhandledException(System.UnhandledExceptionEventArgs)">
            <summary>
            Prints exception info.
            Override this function to intercept unhandled exceptions. Call the base function if want to print exception info as usually.
            </summary>
            <param name="e"></param>
        </member>
        <member name="P:Au.Types.AScript.Triggers">
            <summary>
            Gets or sets an <see cref="T:Au.Triggers.ActionTriggers"/> instance, as a field of this class.
            </summary>
            <remarks>
            This property can be used in automation scripts to avoid creating an <b>ActionTriggers</b> variable explicitly. The returned value is a field of this class. The <b>ActionTriggers</b> object is auto-created when callig this property first time or after setting it = null.
            In automation scripts this property is available because this class is the base of the Script class. In other classes need to create an <b>ActionTriggers</b> variable explicitly. In scripts you also can create explicitly if you like, for example to have more than one instance.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Hotkey["Ctrl+K"] = o => Print(o.Trigger);
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Types.RAFlags">
            <summary>
            Flags for <see cref="M:Au.RunAssembly.Run(System.String,System.String[],System.Int32,Au.Types.RAFlags,System.String)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WHFlags">
            <summary>
            Flags for <see cref="M:Au.AWaitFor.Handle(System.Double,Au.Types.WHFlags,System.IntPtr[])"/>
            </summary>
        </member>
        <member name="F:Au.Types.WHFlags.All">
            <summary>
            Wait until all handles are signaled.
            </summary>
        </member>
        <member name="F:Au.Types.WHFlags.DoEvents">
            <summary>
            While waiting, dispatch Windows messages, events, hooks etc. Like <see cref="M:Au.ATime.SleepDoEvents(System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.WaitMsgCallback">
            <summary>
            Delegate type for <see cref="M:Au.AWaitFor.PostedMessage(System.Double,Au.Types.WaitMsgCallback)"/>.
            </summary>
            <param name="m">API <msdn>MSG</msdn>.</param>
        </member>
        <member name="T:Au.Types.LibWaitVariable">
            <summary>
            Used with LibWait etc instead of ref bool.
            </summary>
        </member>
        <member name="T:Au.Types.LibHandle">
            <summary>
            Manages a kernel handle.
            Must be disposed.
            Has static functions to open process handle.
            </summary>
        </member>
        <member name="M:Au.Types.LibHandle.#ctor(System.IntPtr)">
            <summary>
            Attaches a kernel handle to this new variable.
            No exception when handle is invalid.
            If handle == -1, sets 0.
            </summary>
            <param name="handle"></param>
        </member>
        <member name="P:Au.Types.LibHandle.Is0">
            <summary>
            _h == default.
            Info: _h never is -1.
            </summary>
        </member>
        <member name="M:Au.Types.LibHandle.Dispose">
            
        </member>
        <member name="M:Au.Types.LibHandle.OpenProcess(System.Int32,System.UInt32)">
            <summary>
            Opens process handle.
            Calls API OpenProcess.
            Returns default if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="processId">Process id.</param>
            <param name="desiredAccess">Desired access (Api.PROCESS_), as documented in MSDN -> OpenProcess.</param>
        </member>
        <member name="M:Au.Types.LibHandle.OpenProcess(Au.AWnd,System.UInt32)">
            <summary>
            Opens window's process handle.
            This overload is more powerful: if API OpenProcess fails, it tries API GetProcessHandleFromHwnd, which can open higher integrity level processes, but only if current process is uiAccess and desiredAccess includes only PROCESS_DUP_HANDLE, PROCESS_VM_OPERATION, PROCESS_VM_READ, PROCESS_VM_WRITE, SYNCHRONIZE.
            Returns default if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="w"></param>
            <param name="desiredAccess">Desired access (Api.PROCESS_), as documented in MSDN -> OpenProcess.</param>
        </member>
        <member name="T:Au.Types.LibWaitHandle">
            <summary>
            Kernel handle that is derived from WaitHandle.
            When don't need to wait, use <see cref="T:Au.Types.LibHandle"/>, it's more lightweight and has more creation methods.
            </summary>
        </member>
        <member name="M:Au.Types.LibWaitHandle.FromProcessId(System.Int32,System.UInt32)">
            <summary>
            Opens process handle.
            Returns null if failed.
            </summary>
            <param name="pid"></param>
            <param name="desiredAccess"></param>
        </member>
        <member name="T:Au.Types.NamespaceDoc">
            <summary>
            Types of function parameters, exceptions, etc used in the automation library.
            </summary>
        </member>
        <member name="T:Au.Types.WProp">
            <summary>
            Sets, gets, removes and lists window properties using API <msdn>SetProp</msdn> and co.
            </summary>
        </member>
        <member name="P:Au.Types.WProp.Item(System.String)">
            <summary>
            Gets a window property.
            Calls API <msdn>GetProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name.</param>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.Types.WProp.Item(System.UInt16)">
            <summary>
            Gets a window property.
            Calls API <msdn>GetProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
            <remarks>
            This overload uses atom instead of string. I's about 3 times faster. See API <msdn>GlobalAddAtom</msdn>, <msdn>GlobalDeleteAtom</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Set(System.String,Au.Types.LPARAM)">
            <summary>
            Sets a window property.
            Calls API <msdn>SetProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name.</param>
            <param name="value">Property value.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            
            Later call <see cref="M:Au.Types.WProp.Remove(System.String)"/> to remove the property. If you use many unique property names and don't remove the properties, the property name strings can fill the global atom table which is of a fixed size (about 48000) and which is used by all processes for various purposes.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Set(System.UInt16,Au.Types.LPARAM)">
            <summary>
            Sets a window property.
            Calls API <msdn>SetProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
            <param name="value">Property value.</param>
            <remarks>
            This overload uses atom instead of string. I's about 3 times faster. See API <msdn>GlobalAddAtom</msdn>, <msdn>GlobalDeleteAtom</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.Remove(System.String)">
            <summary>
            Removes a window property.
            Calls API <msdn>RemoveProp</msdn> and returns its return value.
            </summary>
            <param name="name">Property name. Other overload allows to use global atom instead, which is faster.</param>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.Types.WProp.Remove(System.UInt16)">
            <summary>
            Removes a window property.
            Calls API <msdn>RemoveProp</msdn> and returns its return value.
            </summary>
            <param name="atom">Property name atom in the global atom table.</param>
        </member>
        <member name="M:Au.Types.WProp.GetList">
            <summary>
            Gets list of window properties.
            Uses API <msdn>EnumPropsEx</msdn>.
            </summary>
            <remarks>
            Returns 0-length list if fails. Fails if invalid window or access denied ([](xref:uac)). Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.Types.WProp.ToString">
            <summary>
            Calls <see cref="M:Au.Types.WProp.GetList"/> and converts to string.
            </summary>
        </member>
        <member name="T:Au.Types.WCFlags">
            <summary>
            Flags for <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WCFlags.HiddenToo">
            <summary>Can find hidden controls.</summary>
        </member>
        <member name="F:Au.Types.WCFlags.DirectChild">
            <summary>Skip indirect descendant controls (children of children and so on).</summary>
        </member>
        <member name="T:Au.Types.WFFlags">
            <summary>
            Flags of <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WFFlags.HiddenToo">
            <summary>
            Can find invisible windows. See <see cref="P:Au.AWnd.IsVisible"/>.
            Use this carefully. Always use <i>cn</i> (class name), not just <i>name</i>, to avoid finding a wrong window with the same name.
            </summary>
        </member>
        <member name="F:Au.Types.WFFlags.CloakedToo">
            <summary>
            Can find cloaked windows. See <see cref="P:Au.AWnd.IsCloaked"/>.
            Cloaked are windows hidden not in the classic way, therefore <see cref="P:Au.AWnd.IsVisible"/> does not detect it, but <see cref="P:Au.AWnd.IsCloaked"/> detects. For example, windows on inactive Windows 10 virtual desktops, ghost windows of inactive Windows Store apps, various hidden system windows.
            Use this carefully. Always use <i>cn</i> (class name), not just <i>name</i>, to avoid finding a wrong window with the same name.
            </summary>
        </member>
        <member name="T:Au.Types.WF3">
            <summary>
            <i>program</i> of <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            Program name, process id, thread id or owner window handle.
            </summary>
        </member>
        <member name="M:Au.Types.WF3.op_Implicit(System.String)~Au.Types.WF3">
            <summary>Program name like "notepad.exe", or null.</summary>
        </member>
        <member name="M:Au.Types.WF3.Process(System.Int32)">
            <summary>Process id.</summary>
        </member>
        <member name="M:Au.Types.WF3.Thread(System.Int32)">
            <summary>Thread id.</summary>
        </member>
        <member name="M:Au.Types.WF3.Owner(Au.Types.AnyWnd)">
            <summary>Owner window.</summary>
        </member>
        <member name="M:Au.Types.WF3.GetValue(Au.AWildex@,System.Int32@,System.Int32@,Au.AWnd@)">
            <summary>
            Gets program name or process id or thread id or owner window.
            Other variables will be null/0.
            </summary>
            <exception cref="T:System.ArgumentException">The value is "" or 0 or contains \ or /.</exception>
        </member>
        <member name="P:Au.Types.WF3.IsEmpty">
            <summary>
            Returns true if nothing was assigned to this variable.
            </summary>
        </member>
        <member name="T:Au.Types.WFCache">
            <summary>
            Can be used with <see cref="M:Au.AWnd.Finder.IsMatch(Au.AWnd,Au.Types.WFCache)"/>.
            </summary>
        </member>
        <member name="P:Au.Types.WFCache.CacheName">
            <summary>
            Cache window name.
            Default: false.
            </summary>
            <remarks>
            Window name is not cached by default because can be changed. Window class name and program name are always cached because cannot be changed.
            </remarks>
        </member>
        <member name="P:Au.Types.WFCache.NoTimeout">
            <summary>
            Don't auto-clear cached properties on timeout.
            </summary>
        </member>
        <member name="M:Au.Types.WFCache.Clear(System.Boolean)">
            <summary>
            Clears all cached properties, or only name.
            </summary>
            <remarks>
            Usually don't need to call this function. It is implicitly called when the variable is used with a new window.
            </remarks>
            <param name="onlyName">Clear only name (because it may change, unlike other cached properties).</param>
        </member>
        <member name="P:Au.Types.WFCache.IgnoreVisibility">
            <summary>
            Match invisible and cloaked windows too, even if the flags are not set (see <see cref="T:Au.Types.WFFlags"/>).
            </summary>
        </member>
        <member name="T:Au.Types.WXYFlags">
            <summary>
            Flags for <see cref="M:Au.AWnd.FromXY(Au.Types.POINT,Au.Types.WXYFlags)"/> and <see cref="M:Au.AWnd.FromMouse(Au.Types.WXYFlags)"/>.
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.NeedWindow">
            <summary>
            Need top-level window. If at that point is a control, gets its top-level parent.
            Don't use together with NeedControl.
            If none of flags NeedWindow and NeedControl are specified, the function gets exactly what is at that point (control or top-level window).
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.NeedControl">
            <summary>
            Need a control (child window). Returns default(AWnd) if there is no control at that point.
            Don't use together with NeedWindow.
            If none of flags NeedWindow and NeedControl are specified, the function gets exactly what is at that point (control or top-level window).
            </summary>
        </member>
        <member name="F:Au.Types.WXYFlags.Raw">
            <summary>
            Just call API <msdn>WindowFromPoint</msdn>.
            Faster but less accurate with controls. Does not see disabled controls, does not prefer non-transparent controls.
            Not used with flag NeedWindow.
            </summary>
        </member>
        <member name="T:Au.Types.WndClassEx">
            <summary>
            Used with <see cref="M:Au.AWnd.More.RegisterWindowClass(System.String,Au.Types.Native.WNDPROC,Au.Types.WndClassEx)"/>.
            </summary>
        </member>
        <member name="T:Au.Types.TBProgressState">
            <summary>
            Used by <see cref="M:Au.AWnd.More.TaskbarButton.SetProgressState(Au.AWnd,Au.Types.TBProgressState)"/>.
            </summary>
        </member>
        <member name="T:Au.ALastError">
             <summary>
             Gets, sets or clears the last error code of Windows API. Gets error text.
             </summary>
             <remarks>
             Many Windows API functions, when failed, set an error code. Code 0 means no error. It is stored in an internal thread-specific int variable. But only if the API declaration's DllImport attribute has SetLastError = true.
             
             Some functions of this library simply call these API functions and don't throw exception when API fail. For example, most <see cref="T:Au.AWnd"/> propery-get functions.
             When failed, they return false/0/null/empty. Then you can use <see cref="P:Au.ALastError.Code"/> to get the error code or <see cref="P:Au.ALastError.Message"/> to get error text.
             
             Most of functions set error code only when failed, and don't clear the old error code when succeeded. Therefore may need to call <see cref="M:Au.ALastError.Clear"/> before.
            
             Windows API error code definitions and documentation are not included in this library. You can look for them in API function documentation on the internet.
             </remarks>
             <example>
             <code><![CDATA[
             AWnd w = AWnd.Find("Notepag");
             ALastError.Clear();
             bool enabled = w.IsEnabled; //returns true if enabled, false if disabled or failed
             if(!enabled && ALastError.Code != 0) { Print(ALastError.Message); return; } //1400, Invalid window handle
             Print(enabled);
             ]]></code>
             </example>
        </member>
        <member name="M:Au.ALastError.Clear">
            <summary>
            Calls API <msdn>SetLastError</msdn>(0), which clears the Windows API last error code of this thread.
            </summary>
            <remarks>
            Need it before calling some functions if you want to use <see cref="P:Au.ALastError.Code"/> or <see cref="P:Au.ALastError.Message"/>.
            The same as <c>ALastError.Code = 0;</c>.
            </remarks>
        </member>
        <member name="P:Au.ALastError.Code">
            <summary>
            Gets (<see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>) or sets (API <msdn>SetLastError</msdn>) the Windows API last error code of this thread.
            </summary>
        </member>
        <member name="P:Au.ALastError.Message">
            <summary>
            Gets the text message of the Windows API last error code of this thread.
            Returns null if the code is 0.
            </summary>
            <remarks>
            The string always ends with ".".
            </remarks>
        </member>
        <member name="M:Au.ALastError.MessageFor(System.Int32)">
            <summary>
            Gets the text message of a Windows API error code.
            Returns null if errorCode is 0.
            </summary>
            <remarks>
            The string always ends with ".".
            </remarks>
        </member>
        <member name="T:Au.AOpt">
            <summary>
            Options used by some functions of this library.
            </summary>
            <remarks>
            Some frequently used static functions of this library have some options (settings). For example <see cref="M:Au.AKeys.Key(System.Object[])"/> allows to change speed, text sending method, etc. Passing options as parameters in each call usually isn't what you want to do in automation scripts. Instead you can set options using static properties. This class contains several groups of options for functions of various classes. See examples.
            
            There are two sets of identical or similar options - in class <b>AOpt</b> and in class <see cref="T:Au.AOpt.Static"/>:
            - <b>AOpt</b> - thread-static options (each thread has its own instance). Functions of this library use them. You can change or change-restore them anywhere in script. Initial options are automatically copied from <b>AOpt.Static</b> when that group of options (<b>Key</b>, <b>Mouse</b>, etc) is used first time in that thread (explicitly or by library functions).
            - <b>AOpt.Static</b> - static options. Contains initial property values for <b>AOpt</b>. Normally you change them at the very start of script. Don't change later, it's not thread-safe.
            </remarks>
        </member>
        <member name="P:Au.AOpt.Key">
            <summary>
            Options for keyboard and clipboard functions (classes <see cref="T:Au.AKeys"/>, <see cref="T:Au.AClipboard"/> and functions that use them).
            </summary>
            <remarks>
            Each thread has its own <b>AOpt.Key</b> instance. It inherits options from <see cref="P:Au.AOpt.Static.Key"/>.
            Also can be used when creating <see cref="T:Au.AKeys"/> instances. See the second example.
            </remarks>
            <example>
            <code><![CDATA[
            AOpt.Key.KeySpeed = 20;
            Key("Tab Ctrl+V");
            ]]></code>
            Use an AKeys instance.
            <code><![CDATA[
            var k = new AKeys(AOpt.Key); //create new AKeys instance and copy options from AOpt.Key to it
            k.Options.KeySpeed = 100; //changes option of k but not of AOpt.Key
            k.Add("Tab Ctrl+V").Send(); //uses options of k
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AOpt.Mouse">
            <summary>
            Options for mouse functions (class <see cref="T:Au.AMouse"/> and functions that use it).
            </summary>
            <remarks>
            Each thread has its own <b>AOpt.Mouse</b> instance. It inherits options from <see cref="P:Au.AOpt.Static.Mouse"/>.
            </remarks>
            <example>
            <code><![CDATA[
            AOpt.Mouse.ClickSpeed = 100;
            AMouse.Click();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AOpt.Debug">
            <summary>
            Options for showing run-time warnings and other info that can be useful to find problems in code at run time.
            </summary>
            <remarks>
            Each thread has its own <b>AOpt.Debug</b> instance. It inherits options from <see cref="P:Au.AOpt.Static.Debug"/>.
            </remarks>
            <example>
            <code><![CDATA[
            AOpt.Debug.Verbose = false;
            PrintWarning("Example");
            PrintWarning("Example");
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AOpt.WaitFor">
            <summary>
            Options for 'wait for' functions.
            </summary>
            <remarks>
            Each thread has its own <b>AOpt.WaitFor</b> instance. There is no <b>AOpt.Static.WaitFor</b>.
            Most 'wait for' functions of this library use these options. Functions of .NET classes don't.
            </remarks>
        </member>
        <member name="M:Au.AOpt.Reset">
            <summary>
            Resets all options. Copies from <see cref="T:Au.AOpt.Static"/>.
            </summary>
        </member>
        <member name="T:Au.AOpt.Static">
            <summary>
            Default <see cref="T:Au.AOpt"/> properties of each thread.
            </summary>
            <remarks>
            You can change these options at the start of your script or in the static constructor of script's class. Don't change later.
            </remarks>
        </member>
        <member name="P:Au.AOpt.Static.Key">
            <summary>
            Default option values for <see cref="P:Au.AOpt.Key"/> of each thread.
            </summary>
            <remarks>
            Also can be used when creating <see cref="T:Au.AKeys"/> instances. See the second example.
            </remarks>
            <example>
            <code><![CDATA[
            AOpt.Static.Key.KeySpeed = 10;
            ...
            Key("Tab Ctrl+V"); //uses AOpt.Key, which is implicitly copied from AOpt.Static.Key
            ]]></code>
            Use an AKeys instance.
            <code><![CDATA[
            var k = new AKeys(AOpt.Static.Key); //create new AKeys instance and copy options from AOpt.Static.Key to it
            k.Options.KeySpeed = 100; //changes option of k but not of AOpt.Static.Key
            k.Add("Tab Ctrl+V").Send(); //uses options of k
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AOpt.Static.Mouse">
            <summary>
            Default option values for <see cref="P:Au.AOpt.Mouse"/> of each thread.
            </summary>
            <example>
            <code><![CDATA[
            AOpt.Static.Mouse.ClickSpeed = 10;
            ...
            AMouse.Click(); //uses AOpt.Mouse, which is implicitly copied from AOpt.Static.Mouse
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AOpt.Static.Debug">
            <summary>
            Default option values for <see cref="P:Au.AOpt.Debug"/> of each thread.
            </summary>
            <example>
            <code><![CDATA[
            AOpt.Static.Debug.Verbose = false;
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AOpt.Temp">
            <summary>
            Makes easy to restore current options of this thread. See example.
            </summary>
        </member>
        <member name="P:Au.AOpt.Temp.Mouse">
            <summary>
            Makes easy to restore current <see cref="P:Au.AOpt.Mouse"/> of this thread. See example.
            </summary>
            <example>
            <code><![CDATA[
            Print(AOpt.Mouse.ClickSpeed);
            using(AOpt.Temp.Mouse) {
            	AOpt.Mouse.ClickSpeed = 100;
            	Print(AOpt.Mouse.ClickSpeed);
            } //here restored automatically
            Print(AOpt.Mouse.ClickSpeed);
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AOpt.Temp.Key">
            <summary>
            Makes easy to restore current <see cref="P:Au.AOpt.Key"/> of this thread. See example.
            </summary>
            <example>
            <code><![CDATA[
            Print(AOpt.Key.KeySpeed);
            using(AOpt.Temp.Key) {
            	AOpt.Key.KeySpeed = 5;
            	Print(AOpt.Key.KeySpeed);
            } //here restored automatically
            Print(AOpt.Key.KeySpeed);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AStatic">
            <summary>
            This class contains aliases of some frequently used functions. You can call them without type name.
            </summary>
            <remarks>
            In C# source files add <c>using static Au.AStatic;</c>, and you can call these functions without type name.
            Examples:
            <c>Print</c> is the same as <c>AOutput.Write</c>;
            <c>Empty</c> is the same as <c>string.IsNullOrEmpty</c>;
            </remarks>
        </member>
        <member name="M:Au.AStatic.Print(System.String)">
            <summary>
            Calls <see cref="M:Au.AOutput.Write(System.String)"/>. It displays text + <c>"\r\n"</c> in the output pane or console.
            </summary>
            <param name="value">
            Text.
            If "" or null, writes empty line. To write "null" if null, use code <c>Print((object)s);</c>.
            </param>
            <remarks>
            Can display links, colors, images, etc. More info: [](xref:print_tags).
            </remarks>
        </member>
        <member name="M:Au.AStatic.Print(System.Object)">
            <summary>
            Writes value of any type to the output.
            </summary>
            <param name="value">Value of any type. Can be null.</param>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.AOutput.Write(System.String)"/>.
            If the type is unsigned integer (uint, ulong, ushort, byte), writes in hexadecimal format with prefix "0x".
            If null, prints "null".
            
            This overload is used for all types except: strings, arrays, generic collections. They have own overloads; to use this function need to cast to object.
            Also not used for ref struct types, because they cannot be boxed; use <c>Print(x.ToString());</c>.
            </remarks>
        </member>
        <member name="M:Au.AStatic.LibPrintObjectToString(System.Object)">
            <summary>
            Converts object to string like <see cref="M:Au.AStatic.Print(System.Object)"/> does.
            </summary>
        </member>
        <member name="M:Au.AStatic.Print``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes array, List, Dictionary or other generic collection to the output, as a list of items separated by "\r\n".
            </summary>
            <param name="value">Array or generic collection of any type. Can be null.</param>
            <remarks>
            Calls <see cref="M:Au.AOutput.Write(System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.AStatic.Print(System.Object,System.Object,System.Object[])">
            <summary>
            Writes multiple arguments of any type to the output, using separator ", ".
            </summary>
            <remarks>
            Calls <see cref="M:System.Object.ToString"/> and <see cref="M:Au.AOutput.Write(System.String)"/>.
            If a value is null, writes "null".
            If a value is unsigned integer (uint, ulong, ushort, byte), writes in hexadecimal format with prefix "0x".
            </remarks>
        </member>
        <member name="M:Au.AStatic.PrintWarning(System.String,System.Int32,System.String)">
            <summary>
            Writes warning text to the output.
            By default appends the stack trace.
            </summary>
            <param name="text">Warning text.</param>
            <param name="showStackFromThisFrame">If &gt;= 0, appends the stack trace, skipping this number of frames. Default 0.</param>
            <param name="prefix">Text before <i>text</i>. Default <c>"&lt;&gt;Warning: "</c>.</param>
            <remarks>
            Calls <see cref="M:Au.AOutput.Write(System.String)"/>.
            Does not show more that 1 warning/second, unless <b>AOpt.Debug.</b><see cref="P:Au.Types.OptDebug.Verbose"/> == true.
            To disable some warnings, use <b>AOpt.Debug.</b><see cref="M:Au.Types.OptDebug.DisableWarnings(System.String[])"/>.
            </remarks>
        </member>
        <member name="M:Au.AStatic.Empty(System.String)">
            <summary>
            Returns true if the string is null or "".
            The same as string.IsNullOrEmpty.
            </summary>
        </member>
        <member name="M:Au.AStatic.Empty(System.Collections.ICollection)">
            <summary>
            Returns true if the collection (array, List, etc) is null or empty.
            </summary>
        </member>
        <member name="M:Au.AStatic.Paste(System.String)">
            <summary>
            Calls <see cref="M:Au.AClipboard.PasteText(System.String,Au.Types.OptKey)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.AStatic.CopyText">
            <summary>
            Calls <see cref="M:Au.AClipboard.CopyText(System.Boolean,Au.Types.OptKey)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.AStatic.Key(System.Object[])">
            <summary>
            Sends virtual keystrokes to the active window. Also can send text, wait, etc.
            Calls <see cref="M:Au.AKeys.Key(System.Object[])"/>.
            </summary>
            <exception cref="T:System.ArgumentException">An argument is of an unsupported type or has an invalid value, for example an unknown key name.</exception>
        </member>
        <member name="M:Au.AStatic.Text(System.String)">
            <summary>
            Sends text to the active window, using virtual keystrokes or the clipboard.
            Calls <see cref="M:Au.AKeys.Text(System.String)"/>.
            </summary>
        </member>
        <member name="T:Au.AExtAu">
            <summary>
            Extension methods for types of this library.
            </summary>
        </member>
        <member name="M:Au.AExtAu.OrThrow(Au.AWnd)">
            <summary>
            If this is default(AWnd), throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = AWnd.Find("Example").OrThrow();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AExtAu.OrThrow(Au.AAcc)">
            <summary>
            If this is null, throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = AWnd.Find("Example").OrThrow();
            
            var a1 = AAcc.Find(w, "web:LINK", "Example").OrThrow();
            
            var a2 = (AAcc.Find(w, ...)?.Find(...)).OrThrow();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AExtAu.OrThrow(Au.AWinImage)">
            <summary>
            If this is null, throws <see cref="T:Au.Types.NotFoundException"/>, else returns this.
            </summary>
            <exception cref="T:Au.Types.NotFoundException"></exception>
            <example>
            <code><![CDATA[
            var w = AWnd.Find("Example").OrThrow();
            var wi = AWinImage.Find(w, ...).OrThrow();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AExtAu.MouseMove(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y relative to this window.
            Calls <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">Window not found (this variable is 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AExtAu.MouseClick(Au.AWnd,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y relative to this window.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <exception cref="T:Au.Types.NotFoundException">Window not found (this variable is 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AExtAu.MouseMove(Au.AAcc,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the cursor (mouse pointer) to this accessible object.
            Calls <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="y">Y coordinate in the bounding rectangle of this object. Default - center.</param>
            <exception cref="T:Au.Types.NotFoundException">Accessible object not found (this variable is null).</exception>
            <exception cref="T:Au.Types.AuException">Failed to get object rectangle (<see cref="M:Au.AAcc.GetRect(Au.Types.RECT@,Au.AWnd)"/>) or container window (<see cref="P:Au.AAcc.WndContainer"/>).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AExtAu.MouseClick(Au.AAcc,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)">
            <summary>
            Clicks this accessible object.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="y">Y coordinate in the bounding rectangle of this object. Default - center.</param>
            <param name="button">Which button and how to use it.</param>
            <exception cref="T:Au.Types.NotFoundException">Accessible object not found (this variable is null).</exception>
            <exception cref="T:Au.Types.AuException">Failed to get object rectangle (<see cref="M:Au.AAcc.GetRect(Au.Types.RECT@,Au.AWnd)"/>) or container window (<see cref="P:Au.AAcc.WndContainer"/>).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AExtAu.MouseMove(Au.AWinImage,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the mouse to the found image.
            Calls <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the found image. Default - center.</param>
            <param name="y">Y coordinate in the found image. Default - center.</param>
            <exception cref="T:Au.Types.NotFoundException">Image not found (this variable is null).</exception>
            <exception cref="T:System.InvalidOperationException">area is Bitmap.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AExtAu.MouseClick(Au.AWinImage,Au.Types.Coord,Au.Types.Coord,Au.Types.MButton)">
            <summary>
            Clicks the found image.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.
            </summary>
            <param name="t"></param>
            <param name="x">X coordinate in the found image. Default - center.</param>
            <param name="y">Y coordinate in the found image. Default - center.</param>
            <param name="button">Which button and how to use it.</param>
            <exception cref="T:Au.Types.NotFoundException">Image not found (this variable is null).</exception>
            <exception cref="T:System.InvalidOperationException">area is Bitmap.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="T:Au.AExtensions">
            <summary>
            Adds extension methods for some .NET classes.
            </summary>
        </member>
        <member name="M:Au.AExtensions.ToStringWithoutStack(System.Exception)">
            <summary>
            Returns string containing exception type name and message.
            </summary>
        </member>
        <member name="M:Au.AExtensions.ToStringInvariant(System.Double,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Double.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.AExtensions.ToStringInvariant(System.Single,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Single.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.AExtensions.ToStringInvariant(System.Decimal,System.String)">
            <summary>
            Converts double to string.
            Uses invariant culture, therefore decimal point is always '.', not ',' etc.
            Calls <see cref="M:System.Decimal.ToString(System.String,System.IFormatProvider)"/>.
            </summary>
        </member>
        <member name="M:Au.AExtensions.IsEmptyRect(System.Drawing.Rectangle)">
            <summary>
            Returns true if t.Width &lt;= 0 || t.Height &lt;= 0.
            This extension method has been added because Rectangle.IsEmpty returns true only when all fields are 0, which is not very useful.
            </summary>
        </member>
        <member name="M:Au.AExtensions.GetStartEnd(System.Range,System.Int32)">
            <summary>
            Calls <see cref="M:System.Range.GetOffsetAndLength(System.Int32)"/> and returns start and end instead of start and length.
            </summary>
            <param name="t"></param>
            <param name="length"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.AExtensions.Has``1(``0,``0)">
            <summary>
            Returns true if this enum variable has all flag bits specified in <i>flag</i>.
            </summary>
            <param name="t"></param>
            <param name="flag">One or more flags.</param>
            <remarks>
            The same as code <c>(t &amp; flag) == flag</c> or <b>Enum.HasFlag</b>.
            </remarks>
        </member>
        <member name="M:Au.AExtensions.HasAny``1(``0,``0)">
            <summary>
            Returns true if this enum variable has one or more flag bits specified in <i>flags</i>.
            </summary>
            <param name="t"></param>
            <param name="flags">One or more flags.</param>
        </member>
        <member name="M:Au.AExtensions.SetFlag``1(``0@,``0,System.Boolean)">
            <summary>
            Adds or removes a flag.
            </summary>
            <param name="t"></param>
            <param name="flag">One or more flags to add or remove.</param>
            <param name="add">If true, adds flag, else removes flag.</param>
        </member>
        <member name="M:Au.AExtensions.RemoveAt``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a copy of this array with one or more removed elements.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="index"></param>
            <param name="count"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.AExtensions.InsertAt``1(``0[],System.Int32,``0)">
            <summary>
            Creates a copy of this array with one inserted element.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="index"></param>
            <param name="value"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.AExtensions.InsertAt``1(``0[],System.Int32,``0[])">
            <summary>
            Creates a copy of this array with several inserted elements.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="index"></param>
            <param name="values"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.AExtensions.RemoveWhere``2(System.Collections.Generic.Dictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>
            Removes items based on a predicate. For example, all items that have certain value.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="t"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:Au.AExtensions.AppendSentence(System.Text.StringBuilder,System.String,System.Boolean)">
            <summary>
            Appends string as new correctly formatted sentence.
            Returns this.
            </summary>
            <param name="t"></param>
            <param name="s"></param>
            <param name="noUcase">Don't make the first character uppercase.</param>
            <remarks>
            If s is null or "", does nothing.
            If this is not empty, appends space.
            If s starts with a lowercase character, makes it uppercase, unless this ends with a character other than '.'.
            Appends '.' if s does not end with '.', ';', ':', ',', '!' or '?'.
            </remarks>
        </member>
        <member name="M:Au.AExtensions.GetIndex(System.Windows.Forms.Screen)">
            <summary>
            Gets screen index that can be used with <see cref="T:Au.AScreen"/> and functions that use it.
            Primary screen is 0. Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            </summary>
            <param name="t"></param>
            <exception cref="T:Au.Types.AuException">Failed (probably the Screen object is invalid).</exception>
        </member>
        <member name="T:Au.ADialog">
            <summary>
            Standard dialogs to show information or get user input.
            </summary>
            <remarks>
            You can use static functions (less code) or create class instances (more options).
            More info: <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            
            Uses task dialog API <msdn>TaskDialogIndirect</msdn>.
            
            Cannot be used in services. Instead use <b>MessageBox.Show</b> with option ServiceNotification or DefaultDesktopOnly, or API <msdn>MessageBox</msdn> with corresponding flags.
            </remarks>
            <example>
            This example creates a class instance, sets properties, shows dialog, uses events, uses result.
            <code><![CDATA[
            var d = new ADialog(); //info: another constructor has the same parameters as ShowEx
            d.SetText("Main text.", "More text.\nSupports &lt;A HREF=\"link data\"&gt;links&lt;/A&gt; if you subscribe to HyperlinkClicked event.");
            d.SetButtons("1 OK|2 Cancel|3 Custom|4 Custom2");
            d.SetIcon(DIcon.Warning);
            d.SetExpandedText("Expanded info\nand more info.", true);
            d.FlagCanBeMinimized = true;
            d.SetRadioButtons("1 r1|2 r2");
            d.SetCheckbox("Check");
            d.SetTimeout(30, "OK");
            d.HyperlinkClicked += e =&gt; { ADialog.Show("link clicked", e.LinkHref, owner: e.hwnd); };
            d.ButtonClicked += e =&gt; { Print(e.Button); if(e.Button == 4) e.DoNotCloseDialog = true; };
            d.FlagShowProgressBar = true; d.Timer += e =&gt; { e.dialog.Send.Progress(e.TimerTimeMS / 100); };
            var r = d.ShowDialog();
            Print(r);
            switch(r.Button) { case 1: Print("OK"); break; case DResult.Timeout: Print("timeout"); break; }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.ADialog.Options">
            <summary>
            Default options used by <see cref="T:Au.ADialog"/> class functions.
            </summary>
        </member>
        <member name="P:Au.ADialog.Options.DefaultTitle">
            <summary>
            Default title bar text.
            Default value - <see cref="P:Au.ATask.Name"/>. In exe it is exe file name like "Example.exe".
            </summary>
        </member>
        <member name="P:Au.ADialog.Options.RtlLayout">
            <summary>
            Right-to-left layout.
            </summary>
            <seealso cref="P:Au.ADialog.FlagRtlLayout"/>
        </member>
        <member name="P:Au.ADialog.Options.TopmostIfNoOwnerWindow">
            <summary>
            If there is no owner window, let the dialog be always on top of most other windows.
            </summary>
            <seealso cref="P:Au.ADialog.FlagTopmost"/>
        </member>
        <member name="P:Au.ADialog.Options.DefaultScreen">
            <summary>
            Show dialogs on this screen when screen is not explicitly specified (<see cref="P:Au.ADialog.Screen"/>) and there is no owner window.
            If screen index is invalid, the 'show' method shows warning, no exception.
            </summary>
        </member>
        <member name="P:Au.ADialog.Options.UseAppIcon">
            <summary>
            If icon not specified, use <see cref="F:Au.Types.DIcon.App"/>.
            </summary>
        </member>
        <member name="P:Au.ADialog.Options.AutoOwnerWindow">
            <summary>
            If owner window not specified, use the active window of current thread as owner window (disable it, etc).
            </summary>
            <seealso cref="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.ADialog.#ctor">
            
        </member>
        <member name="M:Au.ADialog.#ctor(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Initializes a new <see cref="T:Au.ADialog"/> instance and sets main properties.
            Parameters etc are of <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
        </member>
        <member name="M:Au.ADialog.SetTitleBarText(System.String)">
            <summary>
            Changes title bar text.
            If you don't call this method or title is null or "", dialogs will use <see cref="P:Au.ADialog.Options.DefaultTitle"/>.
            </summary>
        </member>
        <member name="M:Au.ADialog.SetText(System.String,System.String)">
            <summary>
            Sets text.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
        </member>
        <member name="M:Au.ADialog.SetIcon(Au.Types.DIcon)">
            <summary>
            Sets common icon.
            </summary>
            <param name="icon"></param>
        </member>
        <member name="M:Au.ADialog.SetIcon(System.Drawing.Icon)">
            <summary>
            Sets custom icon.
            </summary>
            <param name="icon">
            Icon of size 32 or 16.
            Don't dispose it until the dialog is closed.
            </param>
        </member>
        <member name="M:Au.ADialog._Buttons.MarshalButtons(Au.ADialog.TASKDIALOGCONFIG@)">
            <summary>
            Sets c.pButtons, c.cButtons, c.pRadioButtons and c.cRadioButtons.
            Later call MarshalFreeButtons.
            </summary>
        </member>
        <member name="M:Au.ADialog._Buttons.MarshalFreeButtons(Au.ADialog.TASKDIALOGCONFIG@)">
            <summary>
            Frees memory allocated by MarshalButtons and sets the c members to null/0.
            </summary>
        </member>
        <member name="M:Au.ADialog.SetButtons(System.String,System.Boolean,Au.Types.DStringList)">
            <summary>
            Sets common and/or custom buttons and custom buttons style.
            </summary>
            <param name="buttons">
            Common and/or custom buttons, like with <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.
            These ids should be negative if you use <i>customButtons</i> too, because ids of <i>customButtons</i> are 1, 2, ... .
            </param>
            <param name="asCommandLinks">Custom buttons style. If false - row of classic buttons. If true - column of command-link buttons that can have multiline text.</param>
            <param name="customButtons">
            Additional custom buttons. All will be custom, even if named "OK" etc.
            List of labels without ids. Can be string like "One|Two|..." or string[] or List&lt;string&gt;.
            Button ids will be 1, 2, ... .
            <see cref="P:Au.ADialog.DefaultButton"/> will be 1. You can change it later.
            </param>
        </member>
        <member name="P:Au.ADialog.DefaultButton">
            <summary>
            Specifies which button responds to the Enter key.
            If 0 or not set, auto-selects.
            </summary>
            <value>Button id.</value>
        </member>
        <member name="M:Au.ADialog.SetRadioButtons(System.String,System.Int32)">
            <summary>
            Adds radio buttons.
            To get selected radio button id after closing the dialog, use the RadioButton property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.ADialog.ShowDialog"/> or the <see cref="P:Au.ADialog.Result"/> property.
            </summary>
            <param name="buttons">A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="defaultId">Check the radio button that has this id. If omitted or 0, checks the first. If negative, does not check.</param>
        </member>
        <member name="M:Au.ADialog.SetCheckbox(System.String,System.Boolean)">
            <summary>
            Adds check box (if text is not null/empty).
            To get check box state after closing the dialog, use the IsChecked property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.ADialog.ShowDialog"/> or the <see cref="P:Au.ADialog.Result"/> property.
            </summary>
        </member>
        <member name="M:Au.ADialog.SetExpandedText(System.String,System.Boolean)">
            <summary>
            Adds text that the user can show and hide.
            </summary>
            <param name="text">Text.</param>
            <param name="showInFooter">Show the text at the bottom of the dialog.</param>
        </member>
        <member name="M:Au.ADialog.SetExpandControl(System.Boolean,System.String,System.String)">
            <summary>
            Set properties of the control that shows and hides text added by <see cref="M:Au.ADialog.SetExpandedText(System.String,System.Boolean)"/>.
            </summary>
            <param name="defaultExpanded"></param>
            <param name="collapsedText"></param>
            <param name="expandedText"></param>
        </member>
        <member name="M:Au.ADialog.SetFooterText(System.String)">
            <summary>
            Adds text and common icon at the bottom of the dialog.
            </summary>
            <param name="text">Text, optionally preceded by an icon character and |, like "i|Text". Icons: x error, ! warning, i info, v shield, a app.</param>
        </member>
        <member name="M:Au.ADialog.SetFooterText(System.String,Au.Types.DIcon)">
            <summary>
            Adds text and common icon at the bottom of the dialog.
            </summary>
            <param name="text">Text.</param>
            <param name="icon"></param>
        </member>
        <member name="M:Au.ADialog.SetFooterText(System.String,System.Drawing.Icon)">
            <summary>
            Adds text and custom icon at the bottom of the dialog.
            </summary>
            <param name="text">Text.</param>
            <param name="icon">Icon of size 16. Read more: <see cref="M:Au.ADialog.SetIcon(System.Drawing.Icon)"/>.</param>
        </member>
        <member name="M:Au.ADialog.SetEditControl(Au.Types.DEdit,System.Object)">
            <summary>
            Adds Edit or Combo control (if editType is not DEdit.None (0)).
            To get its text after closing the dialog, use the EditText property of the <see cref="T:Au.Types.DResult"/> variable returned by <see cref="M:Au.ADialog.ShowDialog"/> or the <see cref="P:Au.ADialog.Result"/> property.
            </summary>
            <param name="editType">Control type/style.</param>
            <param name="editText">Initial text. If editType is DEdit.Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <remarks>
            The API TaskDialogIndirect does not have an option to add an edit control. This class itself creates it.
            Does not support progress bar.
            </remarks>
        </member>
        <member name="P:Au.ADialog.Width">
            <summary>
            Sets the width of the dialog's client area.
            The actual width will depend on DPI (the Windows "text size" setting).
            If less than default width, will be used default width.
            </summary>
            <seealso cref="F:Au.Types.DFlags.Wider"/>
        </member>
        <member name="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)">
            <summary>
            Sets owner window.
            The owner window will be disabled, and this dialog will be on top of it.
            This window will be in owner's screen, if screen was not explicitly specified with the <see cref="P:Au.ADialog.Screen"/> property. <see cref="P:Au.ADialog.Options.DefaultScreen"/> is ignored.
            </summary>
            <param name="owner">Owner window, or one of its child/descendant controls. Can be Control (eg Form) or AWnd (window handle). Can be null.</param>
            <param name="ownerCenter">Show the dialog in the center of the owner window. <see cref="M:Au.ADialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)"/> and <see cref="P:Au.ADialog.Screen"/> are ignored.</param>
            <param name="doNotDisable">Don't disable the owner window. If false, disables if it belongs to this thread.</param>
            <seealso cref="P:Au.ADialog.Options.AutoOwnerWindow"/>
        </member>
        <member name="M:Au.ADialog.SetXY(Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Sets dialog position in screen.
            </summary>
            <param name="x">X position in <see cref="P:Au.ADialog.Screen"/>. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.ADialog.Screen"/>. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="rawXY">x y are relative to the primary screen (ignore <see cref="P:Au.ADialog.Screen"/> etc). Don't ensure that entire window is in screen.</param>
        </member>
        <member name="P:Au.ADialog.Screen">
            <summary>
            Sets the screen (display monitor) where to show the dialog in multi-screen environment.
            If null or not set, will be used owner window's screen or <see cref="P:Au.ADialog.Options.DefaultScreen"/>.
            If screen index is invalid, the 'show' method shows warning, no exception.
            More info: <see cref="T:Au.AScreen"/>, <see cref="M:Au.AWnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.AScreen,System.Boolean,System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.ADialog.SetTimeout(System.Int32,System.String,System.Boolean)">
            <summary>
            Let the dialog close itself after closeAfterS seconds.
            On timeout ShowDialog returns DResult.Timeout.
            Example: <c>d.SetTimeout(30, "OK");</c>
            </summary>
        </member>
        <member name="P:Au.ADialog.FlagXCancel">
            <summary>
            Allow to cancel even if there is no Cancel button.
            It adds X (Close) button to the title bar, and also allows to close the dialog with the Esc key.
            When the dialog is closed with the X button or Esc, the returned result button id is 0 if there is no Cancel button; else the same as when clicked the Cancel button.
            The same as <see cref="F:Au.Types.DFlags.XCancel"/>.
            </summary>
        </member>
        <member name="P:Au.ADialog.FlagRtlLayout">
            <summary>
            Right-to left layout.
            Default is ADialog.Options.RtlLayout.
            </summary>
        </member>
        <member name="P:Au.ADialog.FlagCanBeMinimized">
            <summary>
            Add 'Minimize' button to the title bar.
            </summary>
        </member>
        <member name="P:Au.ADialog.FlagShowProgressBar">
            <summary>
            Show progress bar.
            </summary>
        </member>
        <member name="P:Au.ADialog.FlagShowMarqueeProgressBar">
            <summary>
            Show progress bar that just plays an animation but does not indicate which part of the work is already done.
            </summary>
        </member>
        <member name="P:Au.ADialog.FlagTopmost">
            <summary>
            Makes the dialog window topmost or non-topmost.
            If true, will set topmost style when creating the dialog. If false, will not set.
            If null (default), the dialog will be topmost if both these are true: no owner window, ADialog.Options.TopmostIfNoOwnerWindow is true.
            </summary>
        </member>
        <member name="P:Au.ADialog.FlagEndThread">
            <summary>
            Call <see cref="M:System.Threading.Thread.Abort"/> if selected OK button when there are no other buttons. Also when selected Cancel, No, and on timeout.
            </summary>
        </member>
        <member name="M:Au.ADialog.ShowDialog">
            <summary>
            Shows the dialog.
            Returns selected button id and other results packed in a <see cref="T:Au.Types.DResult"/> variable.
            Call this method after setting text and other properties.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="E:Au.ADialog.Created">
            <summary>
            ADialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.ADialog.Destroyed">
            <summary>
            ADialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.ADialog.Timer">
            <summary>
            ADialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.ADialog.ButtonClicked">
            <summary>
            ADialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.ADialog.HyperlinkClicked">
            <summary>
            ADialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.ADialog.HelpF1">
            <summary>
            ADialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="E:Au.ADialog.OtherEvents">
            <summary>
            ADialog events.
            Occurs when the internal <msdn>TaskDialogCallbackProc</msdn> function is called by the task dialog API.
            </summary>
        </member>
        <member name="M:Au.ADialog.ShowDialogNoWait">
            <summary>
            Shows the dialog in new thread and returns without waiting until it is closed.
            </summary>
            <remarks>
            Calls <see cref="M:Au.ADialog.ThreadWaitForOpen"/>, therefore the dialog is already open when this function returns.
            More info: <see cref="M:Au.ADialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>
            </remarks>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="P:Au.ADialog.Result">
            <summary>
            Gets selected button id and other results packed in a DResult variable.
            It is the same variable as the ShowDialog return value.
            If the result is still unavailable (eg the dialog still not closed):
            	If called from the same thread that called ShowDialog, returns null.
            	If called from another thread, waits until the dialog is closed and the return value is available.
            	Note that ShowDialogNoWait calls ShowDialog in another thread.
            </summary>
        </member>
        <member name="M:Au.ADialog.ThreadWaitForOpen">
            <summary>
            Can be used by other threads to wait until the dialog is open.
            If returns true, the dialog is open and you can send messages to it.
            If returns false, the dialog is already closed or failed to show.
            </summary>
        </member>
        <member name="M:Au.ADialog.ThreadWaitForClosed">
            <summary>
            Can be used by other threads to wait until the dialog is closed.
            </summary>
        </member>
        <member name="P:Au.ADialog.IsOpen">
            <summary>
            Returns true if the dialog is open and your code can send messages to it.
            </summary>
        </member>
        <member name="P:Au.ADialog.DialogWindow">
            <summary>
            Gets dialog window handle as AWnd.
            Returns default(AWnd) if the dialog is not open.
            </summary>
        </member>
        <member name="P:Au.ADialog.Send">
            <summary>
            Allows to modify dialog controls while it is open, and close the dialog.
            </summary>
            <remarks>
            Example: <c>d.Send.Close();</c> .
            Example: <c>d.Send.ChangeText2("new text", false);</c> .
            Example: <c>d.Send.Message(Native.TDM.CLICK_VERIFICATION, 1);</c> .
            
            Can be used only while the dialog is open. Before showing the dialog returns null. After closing the dialog the returned variable is deactivated; its method calls are ignored.
            Can be used in dialog event handlers. Also can be used in another thread, for example with <see cref="M:Au.ADialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> and <see cref="M:Au.ADialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
        </member>
        <member name="P:Au.ADialog.EditControl">
            <summary>
            Gets edit control handle as AWnd.
            </summary>
        </member>
        <member name="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog.
            Returns selected button id and other results packed in a <see cref="T:Au.Types.DResult"/> variable.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="buttons">See <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>. Examples: "OK|Cancel", "1 OK|2 Cancel|5 Save|4 Don't Save".</param>
            <param name="flags"></param>
            <param name="icon"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.ADialog.Options.DefaultTitle"/>.</param>
            <param name="radioButtons">Adds radio buttons. A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="checkBox">If not null/"", shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="defaultButton">id of button that responds to the Enter key.</param>
            <param name="x">X position in <see cref="P:Au.ADialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.ADialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time (seconds) and set result's Button property = <see cref="F:Au.Types.DResult.Timeout"/>.</param>
            <param name="onLinkClick">
            A link-clicked event handler function, eg lambda. Enables hyperlinks in small-font text.
            Example:
            <code><![CDATA[
            ADialog.ShowEx("", "Text <a href=\"example\">link</a>.", onLinkClick: e => { Print(e.LinkHref); });
            ]]></code>
            </param>
            <remarks>
            The returned <see cref="T:Au.Types.DResult"/> variable has these properties: selected button id, selected radio button id, check box state.
            Tip: DResult supports implicit cast to int. You can use code <c>switch(ADialog.ShowEx(...))</c> instead of <c>switch(ADialog.ShowEx(...).Button)</c> .
            Tip: Use named arguments. Example: <c>ADialog.ShowEx("Text.", icon: DIcon.Info, title: "Title")</c> .
            This function allows you to use most of the dialog features, but not all. Alternatively you can create an ADialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.ADialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            var r = ADialog.ShowEx("Main text", "More text.", "1 OK|2 Cancel", expandedText: "Expanded text", radioButtons: "1 One|2 Two|3 Three", checkBox: "Check", secondsTimeout: 30);
            Print(r);
            switch(r) {
            case 1: Print("OK"); break;
            case DResult.Timeout: Print("timeout"); break;
            default: Print("Cancel"); break;
            }
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog.
            Returns selected button id.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="buttons">
            Button ids and labels, like "1 OK|2 Cancel|5 Save|4 Don't Save".
            Missing ids are auto-generated, for example "OK|Cancel|100 Custom1|Custom2" is the same as "1 OK|2 Cancel|100 Custom1|101 Custom2".
            The first in the list button is <i>default</i>, ie responds to the Enter key. For example, "2 No|1 Yes" adds Yes and No buttons and makes No default.
            Trims newlines around ids and labels. For example, "\r\n1 One\r\n|\r\n2\r\nTwo\r\n\r\n" is the same as "1 One|2 Two".
            
            To create keyboard shortcuts, use &amp; character in custom button labels. Use &amp;&amp; for literal &amp;. Example: "1 &amp;Tuesday[]2 T&amp;hursday[]3 Saturday &amp;&amp; Sunday".
            
            There are 6 <i>common buttons</i>: OK, Yes, No, Retry, Cancel, Close. Buttons that have other labels are <i>custom buttons</i>.
            How common buttons are different:
            	1. DFlags.CommandLinks does not change their style.
            	2. They have keyboard shortcuts that cannot be changed. Inserting &amp; in a label makes it a custom button.
            	3. Button Cancel can be selected with the Esc key. It also adds X (Close) button in title bar, which selects Cancel.
            	4. Always displayed in standard order (eg Yes No, never No Yes). But you can for example use "2 No|1 Yes" to set default button = No.
            	5. The displayed button label is localized, ie different when the Windows UI language is not English.
            
            If omitted, null or "", the dialog will have OK button, id 1.
            You can use <see cref="F:Au.Types.DFlags.CommandLinks"/> in flags to change the style of custom buttons.
            See also: <see cref="M:Au.ADialog.SetButtons(System.String,System.Boolean,Au.Types.DStringList)"/>.
            </param>
            <param name="flags"></param>
            <param name="icon"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <remarks>
            Calls <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            Tip: Use named arguments. Example: <c>ADialog.Show("Text.", icon: DIcon.Info)</c> .
            </remarks>
            <seealso cref="M:Au.ADialog.ShowInfo(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.ADialog.ShowWarning(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.ADialog.ShowError(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.ADialog.ShowOKCancel(System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.ADialog.ShowYesNo(System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>
            <seealso cref="M:Au.ADebug.Dialog(System.Object,System.String,System.Int32,System.String)"/>
            <example>
            <code><![CDATA[
            if(ADialog.Show("Show another example?", null, "1 OK|2 Cancel", DIcon.Info) != 1) return;
            Print("OK");
            
            switch(ADialog.Show("Save changes?", "More info.", "1 Save|2 Don't Save|Cancel")) {
            case 1: Print("save"); break;
            case 2: Print("don't"); break;
            default: Print("cancel"); break;
            }
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowInfo(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Info icon.
            Calls <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowWarning(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Warning icon.
            Calls <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowError(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with DIcon.Error icon.
            Calls <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowOKCancel(System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with OK and Cancel buttons.
            Returns true if selected OK.
            Calls <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowYesNo(System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)">
            <summary>
            Shows dialog with Yes and No buttons.
            Returns true if selected Yes.
            Calls <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with a text edit field, buttons OK and Cancel, optionally check box, radio buttons and custom buttons.
            Returns results packed in a DResult variable: selected button id (1 for OK, 2 for Cancel), text and check box state.
            </summary>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type. It can be simple text (DEdit.Text, default), multiline, number, password or combo box.</param>
            <param name="editText">Initial edit field text. If editType is Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.ADialog.Options.DefaultTitle"/>.</param>
            <param name="checkBox">If not empty, shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="radioButtons">Adds radio buttons. A list of strings "id text" separated by |, like "1 One|2 Two|3 Three".</param>
            <param name="x">X position in <see cref="P:Au.ADialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.ADialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time, number of seconds.</param>
            <param name="onLinkClick">Enables hyperlinks in small-font text. A link-clicked event handler function, like with <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.</param>
            <param name="buttons">You can use this to add more buttons. A list of strings "id text" separated by |, like "1 OK|2 Cancel|10 Browse...". See <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.</param>
            <param name="onButtonClick">
            A button-clicked event handler function, eg lambda.
            Examples:
            <code><![CDATA[
            ADialog.ShowTextInputEx("Example", flags: DFlags.CommandLinks, buttons: "OK|Cancel|10 Browse\nSets edit control text.",
            	onButtonClick: e => { if(e.Button == 10) { e.EditText = "text"; e.DoNotCloseDialog = true; } });
            
            ADialog.ShowTextInputEx("Example", "Try to click OK while text is empty.", onButtonClick: e =>
            {
            	if(e.Button == 1 && Empty(e.EditText)) {
            		ADialog.Show("Text cannot be empty.", owner: e.hwnd);
            		e.dialog.EditControl.FocusControlOfThisThread();
            		e.DoNotCloseDialog = true;
            	}
            });
            ]]></code>
            </param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create an ADialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.ADialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            var r = ADialog.ShowTextInputEx("Example", "Comments.", checkBox: "Check");
            if(r.Button != 1) return;
            Print(r.EditText);
            Print(r.IsChecked);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowTextInput(System.String@,System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd)">
            <summary>
            Shows dialog with a text edit field and buttons OK and Cancel, and gets that text.
            Returns true if selected OK, false if Cancel.
            </summary>
            <param name="s">Variable that receives the text.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type.</param>
            <param name="editText">Initial edit field text. If editType is DEdit.Combo, it can be a string array, List or IEnumerable; the first item sets combo-box editable text, other items - combo box drop-down list items.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.ADialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            string s;
            if(!ADialog.ShowTextInput(out s, "Example")) return;
            Print(s);
            
            //or you can declare the variable like this
            if(!ADialog.ShowTextInput(out string s2, "Example")) return;
            Print(s2);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowNumberInput(System.Int32@,System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd)">
            <summary>
            Shows dialog with a number edit field and buttons OK and Cancel, and gets that number.
            Returns true if selected OK, false if Cancel.
            </summary>
            <param name="i">Variable that receives the number.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Read-only text below main instruction, above the edit field.</param>
            <param name="editType">Edit field type.</param>
            <param name="editText">Initial edit field text.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.ADialog.ShowTextInputEx(System.String,System.String,Au.Types.DEdit,System.Object,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs},System.String,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            int i;
            if(!ADialog.ShowNumberInput(out i, "Example")) return;
            Print(i);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowListEx(Au.Types.DStringList,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with a list of command-link buttons.
            Returns results packed in a <see cref="T:Au.Types.DResult"/> variable. Its Button property is id of the selected button, which is its 1-based index in the list; it is 0 if clicked the X (close window) button or pressed Esc.
            The return value can be assigned to an int variable or used in switch; then it is the id (1-based index or 0).
            </summary>
            <param name="list">List items (buttons). Can be string like "One|Two|Three" or string[] or List&lt;string&gt;. See <see cref="M:Au.ADialog.SetButtons(System.String,System.Boolean,Au.Types.DStringList)"/>.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <param name="expandedText">Text that the user can show and hide.</param>
            <param name="footerText">Text at the bottom of the dialog. Icon can be specified like "i|Text", where i is: x error, ! warning, i info, v shield, a app.</param>
            <param name="title">Title bar text. If omitted, null or "", uses <see cref="P:Au.ADialog.Options.DefaultTitle"/>.</param>
            <param name="checkBox">If not empty, shows a check box with this text. To make it checked, append "|true", "|check" or "|checked".</param>
            <param name="defaultButton">id (1-based index) of button that responds to the Enter key.</param>
            <param name="x">X position in <see cref="P:Au.ADialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y position in <see cref="P:Au.ADialog.Screen"/>. If default - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="secondsTimeout">If not 0, auto-close the dialog after this time, number of seconds.</param>
            <param name="onLinkClick">Enables hyperlinks in small-font text. A link-clicked event handler function, like with <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.</param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create an ADialog class instance, set properties and call ShowDialog. Example in <see cref="T:Au.ADialog"/> class help.
            </remarks>
            <example>
            <code><![CDATA[
            int r = ADialog.ShowListEx("One|Two|Three", "Example", y: -1, secondsTimeout: 15);
            if(r <= 0) return; //X/Esc or timeout
            Print(r);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowList(Au.Types.DStringList,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd)">
            <summary>
            Shows dialog with a list of command-link buttons.
            Returns 1-based index of the selected button. Returns 0 if clicked the X (close window) button or pressed Esc.
            </summary>
            <param name="list">List items (buttons). Can be string like "One|Two|Three" or string[] or List&lt;string&gt;. See <see cref="M:Au.ADialog.SetButtons(System.String,System.Boolean,Au.Types.DStringList)"/>.</param>
            <param name="text1">Main instruction. Bigger font.</param>
            <param name="text2">Text below main instruction.</param>
            <param name="flags"></param>
            <param name="owner">Owner window or null. See <see cref="M:Au.ADialog.SetOwnerWindow(Au.Types.AnyWnd,System.Boolean,System.Boolean)"/>.</param>
            <remarks>
            Calls <see cref="M:Au.ADialog.ShowListEx(Au.Types.DStringList,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            int r = ADialog.ShowList("One|Two|Three", "Example");
            if(r == 0) return; //X/Esc
            Print(r);
            ]]></code>
            </example>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog with progress bar.
            Creates dialog in new thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.ADialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.ADialog.IsOpen"/>, <see cref="M:Au.ADialog.ThreadWaitForClosed"/>, <see cref="P:Au.ADialog.Result"/> (when closed), <see cref="P:Au.ADialog.DialogWindow"/>, <see cref="P:Au.ADialog.Send"/>; through the Send property you can set progress, modify controls and close the dialog (see example).
            Most parameters are the same as with <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <param name="marquee">Let the progress bar animate without indicating a percent of work done.</param>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create an ADialog class instance, set properties and call <see cref="M:Au.ADialog.ShowDialogNoWait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var pd = ADialog.ShowProgressEx(false, "Working", buttons: "1 Stop", y: -1);
            for(int i = 1; i <= 100; i++) {
            	if(!pd.IsOpen) { Print(pd.Result); break; } //if the user closed the dialog
            	pd.Send.Progress(i); //don't need this if marquee
            	Thread.Sleep(50); //do something in the loop
            }
            pd.Send.Close();
            ]]></code>
            </example>
            <exception cref="T:Au.Types.AuException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowProgress(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Shows dialog with progress bar.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.ADialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.ADialog.IsOpen"/>, <see cref="M:Au.ADialog.ThreadWaitForClosed"/>, <see cref="P:Au.ADialog.Result"/> (when closed), <see cref="P:Au.ADialog.DialogWindow"/>, <see cref="P:Au.ADialog.Send"/>; through the Send property you can set progress, modify controls and close the dialog (see example).
            All parameters except marquee are the same as with <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <param name="marquee">Let the progress bar animate without indicating a percent of work done.</param>
            <remarks>
            Calls <see cref="M:Au.ADialog.ShowProgressEx(System.Boolean,System.String,System.String,System.String,Au.Types.DFlags,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var pd = ADialog.ShowProgress(false, "Working");
            for(int i = 1; i <= 100; i++) {
            	if(!pd.IsOpen) { Print(pd.Result); break; } //if the user closed the dialog
            	pd.Send.Progress(i); //don't need this if marquee
            	Thread.Sleep(50); //do something in the loop
            }
            pd.Send.Close();
            ]]></code>
            </example>
            <exception cref="T:Au.Types.AuException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})">
            <summary>
            Shows dialog like <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> but does not wait.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.ADialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.ADialog.IsOpen"/>, <see cref="M:Au.ADialog.ThreadWaitForClosed"/>, <see cref="P:Au.ADialog.Result"/> (when closed), <see cref="P:Au.ADialog.DialogWindow"/>, <see cref="P:Au.ADialog.Send"/>; through the Send property you can modify controls and close the dialog (see example).
            Parameters are the same as with <see cref="M:Au.ADialog.ShowEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </summary>
            <remarks>
            This function allows you to use most of the dialog features, but not all. Alternatively you can create an ADialog class instance, set properties and call <see cref="M:Au.ADialog.ShowDialogNoWait"/>.
            </remarks>
            <example>
            <code><![CDATA[
            ADialog.ShowNoWait("Simple example");
            
            var d = ADialog.ShowNoWaitEx("Another example", "text", "1 OK|2 Cancel", y: -1, secondsTimeout: 30);
            2.s(); //do something while the dialog is open
            d.Send.ChangeText2("new text", false);
            2.s(); //do something while the dialog is open
            d.ThreadWaitClosed(); Print(d.Result); //wait until the dialog is closed and get result. Optional, just an example.
            ]]></code>
            </example>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="M:Au.ADialog.ShowNoWait(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd)">
            <summary>
            Shows dialog like <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/> but does not wait.
            Creates dialog in other thread and returns without waiting until it is closed.
            Returns <see cref="T:Au.ADialog"/> variable that can be used to communicate with the dialog using these methods and properties: <see cref="P:Au.ADialog.IsOpen"/>, <see cref="M:Au.ADialog.ThreadWaitForClosed"/>, <see cref="P:Au.ADialog.Result"/> (when closed), <see cref="P:Au.ADialog.DialogWindow"/>, <see cref="P:Au.ADialog.Send"/>. Through the <b>Send</b> property you can modify controls and close the dialog. Example in <see cref="M:Au.ADialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/> topic.
            Parameters are the same as with <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/>.
            </summary>
            <remarks>
            Calls <see cref="M:Au.ADialog.ShowNoWaitEx(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String,System.String,System.String,System.String,System.String,System.Int32,Au.Types.Coord,Au.Types.Coord,System.Int32,System.Action{Au.Types.DEventArgs})"/>.
            </remarks>
            <exception cref="T:System.AggregateException">Failed to show dialog.</exception>
        </member>
        <member name="T:Au.AMenu">
            <summary>
            Popup menu based on <see cref="T:System.Windows.Forms.ContextMenuStrip"/>. Can be used everywhere, not only in forms.
            </summary>
            <example>
            <code><![CDATA[
            var m = new AMenu();
            m["One"] = o => Print(o);
            m["Two", icon: AFolders.System + "shell32.dll,15"] = o => { Print(o); ADialog.Show(o.ToString()); };
            m.LastItem.ToolTipText = "tooltip";
            using(m.Submenu("Submenu")) {
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            }
            m.ExtractIconPathFromCode = true;
            m["notepad"] = o => AExec.TryRun(AFolders.System + "notepad.exe");
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AMenu.CMS">
            <summary>
            Gets <see cref="T:System.Windows.Forms.ContextMenuStrip"/> that is used to show the main drop-down menu.
            You can use all its properties, methods and events. You can assign it to a control or toolstrip's drop-down button etc.
            </summary>
        </member>
        <member name="P:Au.AMenu.MainToolStrip">
            <summary>Infrastructure.</summary>
        </member>
        <member name="M:Au.AMenu.#ctor">
            
        </member>
        <member name="M:Au.AMenu.Dispose">
            
        </member>
        <member name="P:Au.AMenu.IsDisposed">
            
        </member>
        <member name="P:Au.AMenu.Item(System.String,System.Object)">
            <summary>
            Adds new item.
            The same as <see cref="M:Au.AMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>.
            </summary>
            <example>
            <code><![CDATA[
            var m = new AMenu();
            m["One"] = o => Print(o);
            m["Two", @"icon file path"] = o => { Print(o); ADialog.Show(o.ToString()); };
            m.LastItem.ToolTipText = "tooltip";
            m["Three"] = o => { Print(o.MenuItem.Checked); };
            m.LastMenuItem.Checked = true;
            m.ExtractIconPathFromCode = true;
            m["notepad"] = o => AExec.TryRun(AFolders.System + "notepad.exe");
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)">
            <summary>
            Adds new item as <see cref="T:System.Windows.Forms.ToolStripMenuItem"/>.
            </summary>
            <param name="text">Text. If contains a tab character, like "Open\tCtrl+O", displays text after it as shortcut keys (right-aligned).</param>
            <param name="onClick">Callback function. Called when clicked the menu item.</param>
            <param name="icon">Can be:
            - string - path of .ico or any other file or folder or non-file object. See <see cref="M:Au.AIcon.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>. If not full path, searches in <see cref="P:Au.AFolders.ThisAppImages"/>; see also <see cref="P:Au.Types.AMTBase.IconFlags"/>.
            - string - image name (key) in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageKey"/>).
            - int - image index in the ImageList (<see cref="P:System.Windows.Forms.ToolStripItem.ImageIndex"/>).
            - Icon, Image, FolderPath.
            - null (default) - no icon. If <see cref="P:Au.Types.AMTBase.ExtractIconPathFromCode"/> == true, extracts icon path from <i>onClick</i> code like <c>AExec.TryRun(@"c:\path\file.exe")</c> or <c>AExec.TryRun(AFolders.System + "file.exe")</c>.
            - "" - no icon.
            </param>
            <remarks>
            Sets menu item text, icon and <b>Click</b> event handler. Other properties can be specified later. See example.
            
            Code <c>m.Add("text", o => Print(o));</c> is the same as <c>m["text"] = o => Print(o);</c>. See <see cref="P:Au.AMenu.Item(System.String,System.Object)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var m = new AMenu();
            m.Add("One", o => Print(o), icon: AFolders.System + "shell32.dll,9");
            var mi = m.Add("Two", o => { Print(o.MenuItem.Checked); ADialog.Show(o.ToString()); });
            mi.Checked = true;
            m.ExtractIconPathFromCode = true;
            m.Add("notepad", o => AExec.TryRun(AFolders.System + "notepad.exe"));
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AMenu.Add(System.Windows.Forms.ToolStripItem,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds item of any supported type, for example ToolStripLabel, ToolStripTextBox, ToolStripComboBox, ToolStripProgressBar, ToolStripButton.
            Supports types derived from ToolStripItem.
            </summary>
            <param name="item">An already created item of any supported type.</param>
            <param name="icon"></param>
            <param name="onClick">Callback function. Called when the item clicked. Not useful for most item types.</param>
        </member>
        <member name="M:Au.AMenu.Separator">
            <summary>
            Adds separator.
            </summary>
        </member>
        <member name="M:Au.AMenu.Submenu(System.String,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds new item (<see cref="T:System.Windows.Forms.ToolStripMenuItem"/>) that will open a submenu.
            Then the add-item functions will add items to the submenu.
            Can be used in 2 ways:
            1. <c>using(m.Submenu(...)) { add items; }</c>. See example.
            2. <c>m.Submenu(...); add items; m.EndSubmenu();</c>. See <see cref="M:Au.AMenu.EndSubmenu"/>.
            </summary>
            <param name="text">Text.</param>
            <param name="icon">See <see cref="M:Au.AMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>.</param>
            <param name="onClick">Callback function. Called when the item clicked. Rarely used.</param>
            <remarks>
            Submenus inherit these properties of the main menu, set before adding submenus (see example):
            <b>BackgroundImage</b>, <b>BackgroundImageLayout</b>, <b>Cursor</b>, <b>Font</b>, <b>ForeColor</b>, <b>ImageList</b>, <b>ImageScalingSize</b>, <b>Renderer</b>, <b>ShowCheckMargin</b>, <b>ShowImageMargin</b>.
            </remarks>
            <example>
            <code><![CDATA[
            var m = new AMenu();
            m.CMS.BackColor = Color.PaleGoldenrod;
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            using(m.Submenu("Submenu")) {
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	using(m.Submenu("Submenu")) {
            		m["Five"] = o => Print(o);
            		m["Six"] = o => Print(o);
            	}
            	m["Seven"] = o => Print(o);
            }
            m["Eight"] = o => Print(o);
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AMenu.EndSubmenu">
            <summary>
            Call this to end adding items to the current submenu if <see cref="M:Au.AMenu.Submenu(System.String,System.Object,System.Action{Au.Types.MTClickArgs})"/> was called without 'using' and without a callback function that adds submenu items.
            </summary>
            <example>
            <code><![CDATA[
            var m = new AMenu();
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            m.Submenu("Submenu");
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	m.EndSubmenu();
            m["Five"] = o => Print(o);
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AMenu.Submenu(System.String,System.Action{Au.AMenu},System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds new item (<see cref="T:System.Windows.Forms.ToolStripMenuItem"/>) that will open a submenu.
            When showing the submenu first time, your callback function will be called and can add submenu items.
            </summary>
            <param name="text">Text.</param>
            <param name="onOpening">Callback function that should add submenu items.</param>
            <param name="icon">See <see cref="M:Au.AMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>.</param>
            <param name="onClick">Callback function. Called when the item clicked. Rarely used.</param>
            <example>
            <code><![CDATA[
            var m = new AMenu();
            m["One"] = o => Print(o);
            m["Two"] = o => Print(o);
            m.Submenu("Submenu 1", m1 =>
            {
            	Print("adding items of " + m.CurrentAddMenu.OwnerItem);
            	m["Three"] = o => Print(o);
            	m["Four"] = o => Print(o);
            	m.Submenu("Submenu 2", m2 =>
            	{
            		Print("adding items of " + m.CurrentAddMenu.OwnerItem);
            		m["Five"] = o => Print(o);
            		m["Six"] = o => Print(o);
            	});
            	m["Seven"] = o => Print(o);
            });
            m["Eight"] = o => Print(o);
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AMenu.CurrentAddMenu">
            <summary>
            Gets <see cref="T:System.Windows.Forms.ToolStripDropDownMenu"/> of the main menu or submenu where new items currently are added.
            </summary>
        </member>
        <member name="P:Au.AMenu.LastMenuItem">
            <summary>
            Gets the last added item as <see cref="T:System.Windows.Forms.ToolStripMenuItem"/>.
            Returns null if it is not a <b>ToolStripMenuItem</b>, for example a button or separator.
            </summary>
            <remarks>
            You can instead use <see cref="P:Au.Types.AMTBase.LastItem"/>, which gets <see cref="T:System.Windows.Forms.ToolStripItem"/>, which is the base class of all supported item types.
            </remarks>
        </member>
        <member name="M:Au.AMenu.Show(System.Boolean)">
            <summary>
            Shows the menu at the mouse cursor position.
            </summary>
            <param name="byCaret">Show at the text cursor (caret) position, if available.</param>
        </member>
        <member name="M:Au.AMenu.Show(System.Int32,System.Int32,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu at the specified position.
            </summary>
            <param name="x">X position in screen.</param>
            <param name="y">Y position in screen.</param>
            <param name="direction">Menu drop direction.</param>
        </member>
        <member name="M:Au.AMenu.Show(System.Windows.Forms.Control,System.Int32,System.Int32,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu on a form or control.
            </summary>
            <param name="owner">A control or form that will own the menu.</param>
            <param name="x">X position in control's client area.</param>
            <param name="y">Y position in control's client area.</param>
            <param name="direction">Menu drop direction.</param>
            <remarks>
            Alternatively you can assign the context menu to a control or toolstrip's drop-down button etc, then don't need to call <b>Show</b>. Use the <see cref="P:Au.AMenu.CMS"/> property, which gets <see cref="T:System.Windows.Forms.ContextMenuStrip"/>.
            </remarks>
        </member>
        <member name="M:Au.AMenu.Show(System.Windows.Forms.Control,System.Windows.Forms.ToolStripDropDownDirection)">
            <summary>
            Shows the menu at the mouse cursor position.
            </summary>
            <param name="owner">A control or form that will own the menu.</param>
            <param name="direction">Menu drop direction.</param>
            <remarks>
            Alternatively you can assign the context menu to a control or toolstrip's drop-down button etc, then don't need to call <b>Show</b>. Use the <see cref="P:Au.AMenu.CMS"/> property, which gets <see cref="T:System.Windows.Forms.ContextMenuStrip"/>.
            </remarks>
        </member>
        <member name="P:Au.AMenu.MultiShow">
            <summary>
            If false, disposes the menu when it is closed.
            If true, does not dispose. Then you can call <b>Show</b> again and again.
            Default is false, but is automatically set to true when showing the menu not with <b>Show</b>, eg when assigned to a control.
            </summary>
            <seealso cref="P:Au.AMenu.DefaultMultiShow"/>
        </member>
        <member name="P:Au.AMenu.DefaultMultiShow">
            <summary>
            Default <see cref="P:Au.AMenu.MultiShow"/> value for new <b>AMenu</b> instances.
            </summary>
        </member>
        <member name="P:Au.AMenu.ModalAlways">
            <summary>
            If true, <b>Show</b> always waits until the menu is closed.
            If false, does not wait if the thread has a .NET message loop (<see cref="M:Au.AThread.HasMessageLoop(System.Boolean@)"/>).
            </summary>
        </member>
        <member name="P:Au.AMenu.ActivateMenuWindow">
            <summary>
            Activate the menu window.
            It enables selecting menu items with the keyboard (arrows, Tab, Enter, etc).
            If false, only Esc works, it closes the menu.
            If the menu is owned by a control or toolbar button, keyboard navigation works in any case, don't need this property to enable it.
            </summary>
            <seealso cref="P:Au.AMenu.DefaultActivateMenuWindow"/>
        </member>
        <member name="P:Au.AMenu.DefaultActivateMenuWindow">
            <summary>
            Default <see cref="P:Au.AMenu.ActivateMenuWindow"/> value for new <b>AMenu</b> instances.
            </summary>
        </member>
        <member name="P:Au.AMenu.MouseClosingDistance">
            <summary>
            Close the menu when the mouse cursor moves away from it to this distance, pixels.
            At first the mouse must be or move at less than half of the distance.
            Default is equal to AMenu.DefaultMouseClosingDistance, default 200.
            </summary>
            <seealso cref="P:Au.AMenu.DefaultMouseClosingDistance"/>
        </member>
        <member name="P:Au.AMenu.DefaultMouseClosingDistance">
            <summary>
            Default MouseClosingDistance value of AMenu instances.
            A AMenu instance inherits this at the moment it is created.
            </summary>
        </member>
        <member name="M:Au.AMenu.Close">
            <summary>
            Closes the menu and its submenus.
            </summary>
        </member>
        <member name="T:Au.AToolbar">
            <summary>
            TODO
            </summary>
        </member>
        <member name="P:Au.AToolbar.Ex">
            <summary>
            Gets ToolStrip.
            </summary>
        </member>
        <member name="P:Au.AToolbar.MainToolStrip">
            <summary>Infrastructure.</summary>
        </member>
        <member name="P:Au.AToolbar.Item(System.String,System.Object)">
            <summary>
            Adds new button.
            The same as <see cref="M:Au.AToolbar.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>.
            </summary>
            <example>
            <code><![CDATA[
            var t = new AToolbar();
            t["One"] = o => Print(o);
            t["Two", @"icon file path"] = o => { Print(o); ADialog.Show(o.ToString()); };
            t.LastItem.ToolTipText = "tooltip";
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AToolbar.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)">
            <summary>
            Adds new button as <see cref="T:System.Windows.Forms.ToolStripButton"/>.
            </summary>
            <param name="text">Text.</param>
            <param name="onClick">Callback function. Called when the button clicked.</param>
            <param name="icon">See <see cref="M:Au.AMenu.Add(System.String,System.Action{Au.Types.MTClickArgs},System.Object)"/>.</param>
            <remarks>
            Sets button text, icon and Click event handler. Other properties can be specified later. See example.
            
            Code <c>t.Add("text", o => Print(o));</c> is the same as <c>t["text"] = o => Print(o);</c>. See <see cref="P:Au.AToolbar.Item(System.String,System.Object)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var m = new AToolbar();
            t.Add("One", o => Print(o), @"icon file path");
            t.LastItem.ToolTipText = "tooltip";
            t.Add("Two", o => { Print(o.MenuItem.Checked); });
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AToolbar.Add(System.Windows.Forms.ToolStripItem,System.Object,System.Action{Au.Types.MTClickArgs})">
            <summary>
            Adds item of any supported type, for example ToolStripLabel, ToolStripTextBox, ToolStripComboBox, ToolStripProgressBar.
            Supports types derived from ToolStripItem.
            </summary>
            <param name="item">An already created item of any supported type.</param>
            <param name="icon"></param>
            <param name="onClick">Callback function. Called when the item clicked. Not useful for most item types.</param>
        </member>
        <member name="M:Au.AToolbar.Separator">
            <summary>
            Adds separator.
            </summary>
        </member>
        <member name="P:Au.AToolbar.LastButton">
            <summary>
            Gets the last added item as ToolStripButton.
            Returns null if it is not a ToolStripButton.
            The item can be added with m.Add(...) and m[...]=.
            </summary>
            <remarks>
            You can instead use LastItem, which gets ToolStripItem, which is the base class of all supported item types; cast it to a derived type if need.
            </remarks>
        </member>
        <member name="P:Au.AToolbar.MainWnd">
            <summary>
            Gets the main toolbar window.
            </summary>
        </member>
        <member name="T:Au.AExtForms">
            <summary>
            Adds extension methods for some System.Windows.Forms classes.
            </summary>
        </member>
        <member name="M:Au.AExtForms.CreateHandleNow(System.Windows.Forms.Control)">
            <summary>
            If control handle still not created, creates. Does not create child control handles.
            Like <see cref="M:System.Windows.Forms.Control.CreateHandle"/>, which is protected.
            Unlike <see cref="M:System.Windows.Forms.Control.CreateControl"/>, creates handle even if invisible.
            </summary>
        </member>
        <member name="M:Au.AExtForms.CreateControlNow(System.Windows.Forms.Control)">
            <summary>
            Creates handle of this control/form and descendant controls.
            Unlike Control.CreateHandle, works when invisible.
            </summary>
        </member>
        <member name="M:Au.AExtForms.MouseClientXY(System.Windows.Forms.Control)">
            <summary>
            Gets mouse cursor position in client area coordinates.
            Returns default(POINT) if handle not created.
            </summary>
        </member>
        <member name="M:Au.AExtForms.MouseWindowXY(System.Windows.Forms.Control)">
            <summary>
            Gets mouse cursor position in window coordinates.
            </summary>
        </member>
        <member name="M:Au.AExtForms.SetCueBanner(System.Windows.Forms.TextBox,System.String,System.Boolean)">
            <summary>
            Sets the textual cue, or tip, that is displayed by the control when it does not have text.
            Sends API <msdn>EM_SETCUEBANNER</msdn>.
            Does nothing if Multiline.
            </summary>
        </member>
        <member name="M:Au.AExtForms.SetCueBanner(System.Windows.Forms.ComboBox,System.String)">
            <summary>
            Sets the textual cue, or tip, that is displayed by the edit control when it does not have text.
            Sends API <msdn>CB_SETCUEBANNER</msdn>.
            </summary>
        </member>
        <member name="T:Au.AExtXml">
            <summary>
            Adds extension methods and some static functions for <see cref="T:System.Xml.Linq.XElement"/> and <see cref="T:System.Xml.Linq.XDocument"/>.
            </summary>
        </member>
        <member name="M:Au.AExtXml.Attr(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, returns null.
            If the attribute value is empty, returns "".
            </summary>
        </member>
        <member name="M:Au.AExtXml.Attr(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.String)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty, returns "".
            </summary>
        </member>
        <member name="M:Au.AExtXml.Attr(System.Xml.Linq.XElement,System.String@,System.Xml.Linq.XName)">
            <summary>
            Gets XML attribute value.
            If the attribute does not exist, sets value=null and returns false.
            </summary>
        </member>
        <member name="M:Au.AExtXml.Attr(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Int32)">
            <summary>
            Gets attribute value converted to int number.
            If the attribute does not exist, returns defaultValue.
            If the attribute value is empty or does not begin with a valid number, returns 0.
            </summary>
        </member>
        <member name="M:Au.AExtXml.Attr(System.Xml.Linq.XElement,System.Int32@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to int number.
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or does not begin with a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.AExtXml.Attr(System.Xml.Linq.XElement,System.Int64@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to long number.
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or does not begin with a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.AExtXml.Attr(System.Xml.Linq.XElement,System.Single@,System.Xml.Linq.XName)">
            <summary>
            Gets attribute value converted to float number.
            If the attribute does not exist, sets value=0 and returns false.
            If the attribute value is empty or is not a valid number, sets value=0 and returns true.
            </summary>
        </member>
        <member name="M:Au.AExtXml.HasAttr(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Returns true if this element has the specified attribute.
            </summary>
        </member>
        <member name="M:Au.AExtXml.Desc(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the first found descendant element.
            Returns null if not found.
            </summary>
        </member>
        <member name="M:Au.AExtXml.Desc(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Finds the first descendant element that has the specified attribute or value.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name. If null, uses the Value property of the element.</param>
            <param name="attributeValue">Attribute value (or Value). If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.AExtXml.Descs(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Finds all descendant elements that have the specified attribute or value.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name. If null, uses the Value property of the element.</param>
            <param name="attributeValue">Attribute value (or Value). If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.AExtXml.Elem(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets the first found direct child element that has the specified attribute or value.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name. If null, uses the Value property of the element.</param>
            <param name="attributeValue">Attribute value (or Value). If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.AExtXml.Elems(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets all direct child elements that have the specified attribute or value.
            Returns null if not found.
            </summary>
            <param name="t"></param>
            <param name="name">Element name. If null, can be any name.</param>
            <param name="attributeName">Attribute name. If null, uses the Value property of the element.</param>
            <param name="attributeValue">Attribute value (or Value). If null, can be any value.</param>
            <param name="ignoreCase">Case-insensitive attributeValue.</param>
        </member>
        <member name="M:Au.AExtXml.ElemOrAdd(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the first found direct child element. If not found, adds new empty child element.
            Returns the found or added element.
            </summary>
        </member>
        <member name="M:Au.AExtXml.ElemOrAdd(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)">
            <summary>
            Gets the first found direct child element that has the specified attribute. If not found, adds new child element with the attribute.
            Returns the found or added element.
            More info: <see cref="M:Au.AExtXml.Elem(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Au.AExtXml.PrevElem(System.Xml.Linq.XElement)">
            <summary>
            Gets previous sibling element.
            Returns null if no element.
            </summary>
        </member>
        <member name="M:Au.AExtXml.NextElem(System.Xml.Linq.XElement)">
            <summary>
            Gets next sibling element.
            Returns null if no element.
            </summary>
        </member>
        <member name="M:Au.AExtXml.LoadElem(System.String,System.Xml.Linq.LoadOptions)">
            <summary>
            Loads XML file in a safer way.
            Uses <see cref="M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)"/> and <see cref="M:Au.AFile.WaitIfLocked(System.Action,System.Int32)"/>.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.</param>
            <param name="options"></param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.Linq.XElement.Load(System.IO.Stream)"/>.</exception>
            <remarks>
            Unlike <see cref="M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)"/>, does not replace <c>\r\n</c> with <c>\n</c>.
            </remarks>
        </member>
        <member name="M:Au.AExtXml.SaveElem(System.Xml.Linq.XElement,System.String,System.Boolean,System.Nullable{System.Xml.Linq.SaveOptions})">
            <summary>
            Saves XML to a file in a safer way.
            Uses <see cref="M:System.Xml.Linq.XElement.Save(System.String,System.Xml.Linq.SaveOptions)"/> and <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.Linq.XElement.Save(System.IO.Stream)"/> and <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="M:Au.AExtXml.LoadDoc(System.String,System.Xml.Linq.LoadOptions)">
            <summary>
            Loads XML file in a safer way.
            Uses <see cref="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)"/> and <see cref="M:Au.AFile.WaitIfLocked(System.Action,System.Int32)"/>.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.</param>
            <param name="options"></param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.Linq.XDocument.Load(System.IO.Stream)"/>.</exception>
            <remarks>
            Unlike <see cref="M:System.Xml.Linq.XDocument.Load(System.String,System.Xml.Linq.LoadOptions)"/>, does not replace <c>\r\n</c> with <c>\n</c>.
            </remarks>
        </member>
        <member name="M:Au.AExtXml.SaveDoc(System.Xml.Linq.XDocument,System.String,System.Boolean,System.Nullable{System.Xml.Linq.SaveOptions})">
            <summary>
            Saves XML to a file in a safer way.
            Uses <see cref="M:System.Xml.Linq.XDocument.Save(System.String)"/> and <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.Linq.XDocument.Save(System.IO.Stream)"/> and <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="T:Au.AExec">
            <summary>
            This class contains static functions to execute or open programs, other files, folders, web pages, etc.
            </summary>
        </member>
        <member name="M:Au.AExec.Run(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)">
            <summary>
            Runs/opens a program, document, directory (folder), URL, new email, Control Panel item etc.
            The returned <see cref="T:Au.Types.RResult"/> variable contains some process info - process id etc.
            </summary>
            <param name="file">
            What to run. Can be:
            Full path of a file or directory. Examples: <c>@"C:\file.txt"</c>, <c>AFolders.System + "notepad.exe"</c>, <c>@"%AFolders.System%\notepad.exe"</c>.
            Filename of a file or directory, like <c>"notepad.exe"</c>. The function calls <see cref="M:Au.AFile.SearchPath(System.String,System.String[])"/>.
            Path relative to <see cref="P:Au.AFolders.ThisApp"/>. Examples: <c>"x.exe"</c>, <c>@"subfolder\x.exe"</c>, <c>@".\subfolder\x.exe"</c>, <c>@"..\another folder\x.exe"</c>.
            URL. Examples: <c>"http://a.b.c/d"</c>, <c>"file:///path"</c>.
            Email, like <c>"mailto:a@b.c"</c>. Subject, body etc also can be specified, and Google knows how.
            Shell object's ITEMIDLIST like <c>":: ITEMIDLIST"</c>. See <see cref="M:Au.APidl.ToBase64String"/>, <see cref="T:Au.AFolders.Virtual"/>. Can be used to open virtual folders and items like Control Panel.
            Shell object's parsing name, like <c>@"::{CLSID}"</c>. See <see cref="M:Au.APidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)"/>, <see cref="T:Au.AFolders.VirtualPidl"/>. Can be used to open virtual folders and items like Control Panel.
            To run a Windows Store App, use <c>@"shell:AppsFolder\WinStoreAppId"</c> format. Examples: <c>@"shell:AppsFolder\Microsoft.WindowsCalculator_8wekyb3d8bbwe!App"</c>, <c>@"shell:AppsFolder\windows.immersivecontrolpanel_cw5n1h2txyewy!microsoft.windows.immersivecontrolpanel"</c>. To discover the string use <see cref="M:Au.AWnd.More.GetWindowsStoreAppId(Au.AWnd,System.Boolean,System.Boolean)"/> or Google.
            Supports environment variables, like <c>@"%TMP%\file.txt"</c>. See <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            </param>
            <param name="args">
            Command line arguments.
            This function expands environment variables if starts with <c>"%"</c> or <c>"\"%"</c>.
            </param>
            <param name="flags"></param>
            <param name="more">
            Allows to specify more parameters: current directory, verb, window state, etc.
            If string, it sets initial current directory for the new process. Use "" to get it from <i>file</i>. More info: <see cref="F:Au.Types.RMore.CurrentDirectory"/>.
            </param>
            <exception cref="T:System.ArgumentException">Used more.Verb and flag Admin.</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example, the file does not exist.</exception>
            <remarks>
            It works like when you double-click a file icon. It may start new process or not. For example it may just activate window if the program is already running.
            Uses API <msdn>ShellExecuteEx</msdn>.
            Similar to <see cref="M:System.Diagnostics.Process.Start(System.String,System.String)"/>.
            </remarks>
            <seealso cref="M:Au.AWnd.FindOrRun(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object,System.Action,System.Double,System.Boolean)"/>
            <example>
            Run notepad and wait for its window.
            <code><![CDATA[
            AExec.Run("notepad.exe");
            AWnd w = AWnd.Wait(10, true, "*- Notepad", "Notepad");
            ]]></code>
            Run notepad or activate its window.
            <code><![CDATA[
            AWnd w = AWnd.FindOrRun("*- Notepad", run: () => AExec.Run("notepad.exe"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AExec.TryRun(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)">
            <summary>
            Calls <see cref="M:Au.AExec.Run(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)"/> and handles exceptions. All parameters are the same.
            If <b>Run</b> throws exception, prints it as warning and returns null.
            </summary>
            <remarks>
            This is useful when you don't care whether <b>Run</b> succeeded and don't want to use try/catch.
            Handles only exception of type AuException. It is thrown when fails, usually when the file does not exist.
            </remarks>
            <seealso cref="M:Au.AStatic.PrintWarning(System.String,System.Int32,System.String)"/>
            <seealso cref="M:Au.Types.OptDebug.DisableWarnings(System.String[])"/>
            <seealso cref="M:Au.AWnd.FindOrRun(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object,System.Action,System.Double,System.Boolean)"/>
        </member>
        <member name="M:Au.AExec.RunConsole(System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program, waits until its process ends, and gets its output text.
            This overload prints text lines in real time.
            </summary>
            <param name="exe">
            Path or name of an .exe or .bat file. Can be:
            Full path. Examples: <c>@"C:\folder\x.exe"</c>, <c>AFolders.System + "x.exe"</c>, <c>@"%AFolders.System%\x.exe"</c>.
            Filename, like <c>"x.exe"</c>. This function calls <see cref="M:Au.AFile.SearchPath(System.String,System.String[])"/>.
            Path relative to <see cref="P:Au.AFolders.ThisApp"/>. Examples: <c>"x.exe"</c>, <c>@"subfolder\x.exe"</c>, <c>@".\subfolder\x.exe"</c>, <c>@"..\another folder\x.exe"</c>.
            Supports environment variables, like <c>@"%TMP%\x.bat"</c>. See <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            </param>
            <param name="args">null or command line arguments.</param>
            <param name="curDir">
            Initial current directory of the new process.
            - If null, uses <c>Directory.GetCurrentDirectory()</c>.
            - Else if "", calls <c>APath.GetDirectoryPath(exe)</c>.
            - Else calls <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            </param>
            <param name="encoding">
            Console's text encoding.
            If null (default), uses the default console text encoding (API <msdn>GetOEMCP</msdn>); it is not Unicode. Programs that display Unicode text use <see cref="P:System.Text.Encoding.UTF8"/>.
            </param>
            <returns>The process exit code. Usually a non-0 value means error.</returns>
            <exception cref="T:Au.Types.AuException">Failed, for example file not found.</exception>
            <remarks>
            The console window is hidden. The text that would be displayed in it is redirected to this function.
            
            Console programs have two output text streams - standard output and standard error. This function gets both.
            Alternatively use <see cref="M:System.Diagnostics.Process.Start"/>. It gets the output and error streams separately, and some lines may be received in incorrect order in time.
            </remarks>
            <example>
            <code><![CDATA[
            string v = "example";
            int r1 = AExec.RunConsole(@"Q:\Test\console1.exe", $@"/an ""{v}"" /etc");
            
            int r2 = AExec.RunConsole(s => Print(s), @"Q:\Test\console2.exe");
            
            int r3 = AExec.RunConsole(out var text, @"Q:\Test\console3.exe", encoding: Encoding.UTF8);
            Print(text);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AExec.RunConsole(System.Action{System.String},System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program, waits until its process ends, and gets its output text.
            This overload uses a callback function that receives text lines in real time.
            </summary>
            <param name="output">A callback function that receives the output text. It receives single full line at a time, without line break characters.</param>
            <param name="exe"></param>
            <param name="args"></param>
            <param name="curDir"></param>
            <param name="encoding"></param>
            <exception cref="T:Au.Types.AuException">Failed, for example file not found.</exception>
        </member>
        <member name="M:Au.AExec.RunConsole(System.String@,System.String,System.String,System.String,System.Text.Encoding)">
            <summary>
            Runs a console program, waits until its process ends, and gets its output text when it ends.
            </summary>
            <param name="output">A variable that receives the output text.</param>
            <param name="exe"></param>
            <param name="args"></param>
            <param name="curDir"></param>
            <param name="encoding"></param>
            <exception cref="T:Au.Types.AuException">Failed, for example file not found.</exception>
        </member>
        <member name="M:Au.AExec.SelectInExplorer(System.String)">
            <summary>
            Opens parent folder in Explorer and selects the specified file.
            Returns null if fails, for example if the file does not exist.
            </summary>
            <param name="path">
            Full path of a file or directory or other shell object.
            Supports <c>@"%environmentVariable%\..."</c> (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>) and <c>"::..."</c> (see <see cref="M:Au.APidl.ToBase64String"/>).
            </param>
        </member>
        <member name="T:Au.AFile">
            <summary>
            File system functions.
            </summary>
            <remarks>
            Works with files and directories. Disk drives like <c>@"C:\"</c> or <c>"C:"</c> are directories too.
            Extends .NET file system classes such as <see cref="T:System.IO.File"/> and <see cref="T:System.IO.Directory"/>.
            Many functions of this class can be used instead of existing similar .NET functions that are slow, limited or unreliable.
            Most functions support only full path. Most of them throw <b>ArgumentException</b> if passed a filename or relative path, ie in "current directory". Using current directory is unsafe.
            Most functions support extended-length paths (longer than 259). Such local paths should have <c>@"\\?\"</c> prefix, like <c>@"\\?\C:\..."</c>. Such network path should be like <c>@"\\?\UNC\server\share\..."</c>. See <see cref="M:Au.APath.PrefixLongPath(System.String)"/>, <see cref="M:Au.APath.PrefixLongPathIfNeed(System.String)"/>. Many functions support long paths even without prefix.
            </remarks>
        </member>
        <member name="M:Au.AFile._DisableDeviceNotReadyMessageBox">
            <summary>
            Adds SEM_FAILCRITICALERRORS to the error mode of this process, as MSDN recommends. Once in process.
            It is to avoid unnecessary message boxes when an API tries to access an ejected CD/DVD etc.
            </summary>
        </member>
        <member name="M:Au.AFile.GetProperties(System.String,Au.Types.FileProperties@,Au.Types.FAFlags)">
            <summary>
            Gets file or directory attributes, size and times.
            Returns false if the file/directory does not exist.
            Calls API <msdn>GetFileAttributesEx</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If flag UseRawPath not used, supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>).</param>
            <param name="properties">Receives properties.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Not full path (when not used flag UseRawPath).</exception>
            <exception cref="T:Au.Types.AuException">The file/directory exist but failed to get its properties. Not thrown if used flag DoNotThrow.</exception>
            <remarks>
            For symbolic links etc, gets properties of the link, not of its target.
            You can also get most of these properties with <see cref="M:Au.AFile.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/>.
            </remarks>
        </member>
        <member name="M:Au.AFile.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)">
            <summary>
            Gets file or directory attributes.
            Returns false if the file/directory does not exist.
            Calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If flag UseRawPath not used, supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>).</param>
            <param name="attributes">Receives attributes, or 0 if failed.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Not full path (when not used flag UseRawPath).</exception>
            <exception cref="T:Au.Types.AuException">Failed. Not thrown if used flag DoNotThrow.</exception>
            <remarks>
            For symbolic links etc, gets properties of the link, not of its target.
            </remarks>
        </member>
        <member name="M:Au.AFile._GetAttributes(System.String,System.IO.FileAttributes@,System.Boolean)">
            <summary>
            Gets attributes.
            Returns false if INVALID_FILE_ATTRIBUTES or if relative path. No exceptions.
            </summary>
        </member>
        <member name="M:Au.AFile.ExistsAs(System.String,System.Boolean)">
            <summary>
            Gets file system entry type - file, directory, and whether it exists.
            Returns NotFound (0) if does not exist or if fails to get attributes.
            Calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>. If you need exception when fails, instead call <see cref="M:Au.AFile.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            </remarks>
        </member>
        <member name="M:Au.AFile.ExistsAs2(System.String,System.Boolean)">
            <summary>
            Gets file system entry type - file, directory, symbolic link, whether it exists and is accessible.
            Returns NotFound (0) if does not exist. Returns AccessDenied (&lt; 0) if exists but this process cannot access it and get attributes.
            Calls API <msdn>GetFileAttributes</msdn>.
            The same as <see cref="M:Au.AFile.ExistsAs(System.String,System.Boolean)"/> but provides more complete result. In most cases you can use ExistsAs, it's simpler.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>. If you need exception when fails, instead call <see cref="M:Au.AFile.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attributes Directory and ReparsePoint.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            </remarks>
        </member>
        <member name="M:Au.AFile.ExistsAsAny(System.String,System.Boolean)">
            <summary>
            Returns true if file or directory exists.
            Calls <see cref="M:Au.AFile.ExistsAs2(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>. If you need exception when fails, instead call <see cref="M:Au.AFile.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/>.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists. Does not care whether its target exists.
            Unlike <see cref="M:Au.AFile.ExistsAsFile(System.String,System.Boolean)"/> and <see cref="M:Au.AFile.ExistsAsDirectory(System.String,System.Boolean)"/>, this function returns true when the file exists but cannot get its attributes. Then <c>ExistsAsAny(path)</c> is not the same as <c>ExistsAsFile(path) || ExistsAsDirectory(path)</c>.
            </remarks>
        </member>
        <member name="M:Au.AFile.ExistsAsFile(System.String,System.Boolean)">
            <summary>
            Returns true if file exists and is not a directory.
            Returns false if does not exist or if fails to get its attributes.
            Calls <see cref="M:Au.AFile.ExistsAs(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>. If you need exception when fails, instead call <see cref="M:Au.AFile.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists and its target is not a directory. Does not care whether its target exists.
            </remarks>
        </member>
        <member name="M:Au.AFile.ExistsAsDirectory(System.String,System.Boolean)">
            <summary>
            Returns true if directory (folder or drive) exists.
            Returns false if does not exist or if fails to get its attributes.
            Calls <see cref="M:Au.AFile.ExistsAs(System.String,System.Boolean)"/>, which calls API <msdn>GetFileAttributes</msdn>.
            </summary>
            <param name="path">Full path. Supports <c>@"\.."</c> etc. If useRawPath is false (default), supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>). Can be null.</param>
            <param name="useRawPath">Pass path to the API as it is, without any normalizing and full-path checking.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>. If you need exception when fails, instead call <see cref="M:Au.AFile.GetAttributes(System.String,System.IO.FileAttributes@,Au.Types.FAFlags)"/> and check attribute Directory.
            Always use full path. If path is not full: if useRawPath is false (default) returns NotFound; if useRawPath is true, searches in "current directory".
            For symbolic links etc, returns true if the link exists and its target is a directory. Does not care whether its target exists.
            </remarks>
        </member>
        <member name="M:Au.AFile.SearchPath(System.String,System.String[])">
            <summary>
            Finds file or directory and returns full path.
            Returns null if cannot be found.
            </summary>
            <remarks>
            If the path argument is full path, calls <see cref="M:Au.AFile.ExistsAsAny(System.String,System.Boolean)"/> and returns normalized path if exists, null if not.
            Else searches in these places:
            1. dirs, if used.
            2. <see cref="P:Au.AFolders.ThisApp"/>.
            3. Calls API <msdn>SearchPath</msdn>, which searches in process directory, Windows system directories, current directory, PATH environment variable. The search order depends on API <msdn>SetSearchPathMode</msdn> or registry settings.
            4. If path ends with ".exe", tries to get path from registry "App Paths" keys.
            </remarks>
            <param name="path">Full or relative path or just filename with extension. Supports network paths too.</param>
            <param name="dirs">0 or more directories where to search.</param>
        </member>
        <member name="M:Au.AFile.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})">
            <summary>
            Gets names and other info of files and subdirectories in the specified directory.
            Returns an enumerable collection of <see cref="T:Au.Types.FEFile"/> objects containing the info.
            </summary>
            <param name="directoryPath">Full path of the directory.</param>
            <param name="flags"></param>
            <param name="filter">
            Callback function. Called for each file and subdirectory. If returns false, the file/subdirectory is not included in results.
            Can be useful when <b>EnumDirectory</b> is called indirectly, for example by the <see cref="M:Au.AFile.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> method. If you call it directly, you can instead skip the file in your foreach loop.
            Example: <c>filter: k => k.IsDirectory || k.Name.Ends(".png", true)</c>. See <see cref="P:Au.Types.FEFile.IsDirectory"/>.
            </param>
            <param name="errorHandler">
            Callback function. Called when fails to get children of a subdirectory, when using flag <see cref="F:Au.Types.FEFlags.AndSubdirectories"/>.
            Receives the subdirectory path. Can call <see cref="T:Au.ALastError"/><b>.Code</b> and throw an exception. If does not throw, the enumeration continues as if the directory is empty.
            If <i>errorHandler</i> not used, then <b>EnumDirectory</b> throws exception. See also: flag <see cref="F:Au.Types.FEFlags.IgnoreAccessDeniedErrors"/>.
            </param>
            <exception cref="T:System.ArgumentException"><i>directoryPath</i> is invalid path or not full path.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"><i>directoryPath</i> directory does not exist.</exception>
            <exception cref="T:Au.Types.AuException">Failed to get children of <i>directoryPath</i> or of a subdirectory.</exception>
            <remarks>
            Uses API <msdn>FindFirstFile</msdn>.
            
            By default gets only direct children. Use flag <see cref="F:Au.Types.FEFlags.AndSubdirectories"/> to get all descendants.
            
            The paths that this function gets are normalized, ie may not start with exact <i>directoryPath</i> string. Expanded environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>), "..", DOS path etc.
            Paths longer than <see cref="F:Au.APath.MaxDirectoryPathLength"/> have <c>@"\\?\"</c> prefix (see <see cref="M:Au.APath.PrefixLongPathIfNeed(System.String)"/>).
            
            For symbolic links and mounted folders, gets info of the link/folder and not of its target.
            
            These errors are ignored:
            1. Missing target directory of a symbolic link or mounted folder.
            2. If used flag <see cref="F:Au.Types.FEFlags.IgnoreAccessDeniedErrors"/> - access denied.
            
            When an error is ignored, the function works as if that [sub]directory is empty; does not throw exception and does not call <i>errorHandler</i>.
            
            Enumeration of a subdirectory starts immediately after the subdirectory itself is retrieved.
            </remarks>
        </member>
        <member name="M:Au.AFile._SafeDeleteExistingDirectory.Rename(System.String,System.Boolean)">
            <summary>
            note: path must be normalized.
            </summary>
        </member>
        <member name="M:Au.AFile.Rename(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Renames file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newName">New name without path. Example: "name.txt".</param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">
            - <i>path</i> is not full path (see <see cref="M:Au.APath.IsFullPath(System.String)"/>).
            - <i>newName</i> is invalid filename.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>MoveFileEx</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AFile.Move(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Moves (changes path of) file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newPath">
            New full path.
            <note>It is not the new parent directory. Use <see cref="M:Au.AFile.MoveTo(System.String,System.String,Au.Types.IfExists)"/> for it.</note>
            </param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">path or newPath is not full path (see <see cref="M:Au.APath.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            In most cases uses API <msdn>MoveFileEx</msdn>. It's fast, because don't need to copy files.
            In these cases copies/deletes: destination is on another drive; need to merge directories.
            When need to copy, does not copy security properties; sets default.
            
            Creates the destination directory if does not exist (see <see cref="M:Au.AFile.CreateDirectory(System.String,System.String)"/>).
            If path and newPath share the same parent directory, just renames the file.
            </remarks>
        </member>
        <member name="M:Au.AFile.MoveTo(System.String,System.String,Au.Types.IfExists)">
            <summary>
            Moves file or directory into another directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newDirectory">New parent directory.</param>
            <param name="ifExists"></param>
            <exception cref="T:System.ArgumentException">
            - <i>path</i> or <i>newDirectory</i> is not full path (see <see cref="M:Au.APath.IsFullPath(System.String)"/>).
            - <i>path</i> is drive. To move drive content, use <see cref="M:Au.AFile.Move(System.String,System.String,Au.Types.IfExists)"/>.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            In most cases uses API <msdn>MoveFileEx</msdn>. It's fast, because don't need to copy files.
            In these cases copies/deletes: destination is on another drive; need to merge directories.
            When need to copy, does not copy security properties; sets default.
            
            Creates the destination directory if does not exist (see <see cref="M:Au.AFile.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.AFile.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})">
            <summary>
            Copies file or directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newPath">
            New full path.
            <note>It is not the new parent directory. Use <see cref="M:Au.AFile.CopyTo(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/> for it.</note>
            </param>
            <param name="ifExists"></param>
            <param name="copyFlags">Options used when copying directory.</param>
            <param name="filter">
            Callback function. Can be used when copying directory. Called for each descendant file and subdirectory.
            If returns false, the file/subdirectory is not copied.
            Example: <c>filter: k => k.IsDirectory || k.Name.Ends(".png", true)</c>. See <see cref="P:Au.Types.FEFile.IsDirectory"/>.
            </param>
            <exception cref="T:System.ArgumentException">path or newPath is not full path (see <see cref="M:Au.APath.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>CopyFileEx</msdn>.
            On Windows 7 does not copy security properties; sets default.
            Does not copy symbolic links (silently skips, no exception) if this process is not running as administrator.
            Creates the destination directory if does not exist (see <see cref="M:Au.AFile.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.AFile.CopyTo(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})">
            <summary>
            Copies file or directory into another directory.
            </summary>
            <param name="path">Full path.</param>
            <param name="newDirectory">New parent directory.</param>
            <param name="ifExists"></param>
            <param name="copyFlags">Options used when copying directory.</param>
            <param name="filter">See <see cref="M:Au.AFile.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>.</param>
            <exception cref="T:System.ArgumentException">
            - <i>path</i> or <i>newDirectory</i> is not full path (see <see cref="M:Au.APath.IsFullPath(System.String)"/>).
            - <i>path</i> is drive. To copy drive content, use <see cref="M:Au.AFile.Copy(System.String,System.String,Au.Types.IfExists,Au.Types.FCFlags,System.Func{Au.Types.FEFile,System.Boolean})"/>.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The source file (path) does not exist or cannot be found.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Uses API <msdn>CopyFileEx</msdn>.
            On Windows 7 does not copy security properties; sets default.
            Does not copy symbolic links (silently skips, no exception) if this process is not running as administrator.
            Creates the destination directory if does not exist (see <see cref="M:Au.AFile.CreateDirectory(System.String,System.String)"/>).
            </remarks>
        </member>
        <member name="M:Au.AFile.Delete(System.String,System.Boolean)">
            <summary>
            Deletes file or directory.
            Does nothing if it does not exist (no exception).
            </summary>
            <param name="path">Full path.</param>
            <param name="tryRecycleBin">
            Send to the Recycle Bin. If not possible, delete anyway.
            Why could be not possible: 1. The file is in a removable drive (most removables don't have a recycle bin). 2. The file is too large. 3. The path is too long. 4. The Recycle Bin is not used on that drive (it can be set in the Recycle Bin Properties dialog). 5. This process is non-UI-interactive, eg a service. 6. Unknown reasons.
            Note: it is much slower. To delete multiple, use <see cref="M:Au.AFile.Delete(System.Collections.Generic.IEnumerable{System.String},System.Boolean)"/>.
            </param>
            <exception cref="T:System.ArgumentException">path is not full path (see <see cref="M:Au.APath.IsFullPath(System.String)"/>).</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            If directory, also deletes all its files and subdirectories. If fails to delete some, tries to delete as many as possible.
            Deletes read-only files too.
            Does not show any message boxes etc (confirmation, error, UAC consent, progress).
            
            Some reasons why this function can fail:
            1. The file is open (in any process). Or a file in the directory is open.
            2. This process does not have security permissions to access or delete the file or directory or some of its descendants.
            3. The directory is (or contains) the "current directory" (in any process).
            </remarks>
        </member>
        <member name="M:Au.AFile.Delete(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Deletes multiple files or/and directories.
            The same as <see cref="M:Au.AFile.Delete(System.String,System.Boolean)"/>, but faster when using Recycle Bin.
            </summary>
            <param name="paths">string array, List or other collection. Full paths.</param>
            <param name="tryRecycleBin"></param>
        </member>
        <member name="M:Au.AFile._Delete(System.String,System.Boolean)">
            <summary>
            note: path must be normalized.
            </summary>
        </member>
        <member name="M:Au.AFile.CreateDirectory(System.String,System.String)">
            <summary>
            Creates new directory if does not exists.
            If need, creates missing parent/ancestor directories.
            Returns true if created new directory, false if the directory already exists. Throws exception if fails.
            </summary>
            <param name="path">Path of new directory.</param>
            <param name="templateDirectory">Optional path of a template directory from which to copy some properties. See API <msdn>CreateDirectoryEx</msdn>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            If the directory already exists, this function does nothing, and returns false.
            Else, at first it creates missing parent/ancestor directories, then creates the specified directory.
            To create the specified directory, calls API <msdn>CreateDirectory</msdn> or <msdn>CreateDirectoryEx</msdn> (if templateDirectory is not null).
            </remarks>
        </member>
        <member name="M:Au.AFile.CreateDirectoryFor(System.String)">
            <summary>
            Creates parent directory for a new file, if does not exist.
            The same as <see cref="M:Au.AFile.CreateDirectory(System.String,System.String)"/>, just removes filename from <i>filePath</i>.
            Returns true if created new directory, false if the directory already exists. Throws exception if fails.
            </summary>
            <param name="filePath">Path of new file.</param>
            <exception cref="T:System.ArgumentException">Not full path. No filename.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            string path = @"D:\Test\new\test.txt";
            AFile.CreateDirectoryFor(path);
            File.WriteAllText(path, "text"); //would fail if directory @"D:\Test\new" does not exist
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AFile._PreparePath(System.String)">
            <summary>
            Expands environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>). Throws ArgumentException if not full path. Normalizes. Removes or adds <c>'\\'</c> at the end.
            </summary>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
        </member>
        <member name="M:Au.AFile._FindFilename(System.String,System.Boolean)">
            <summary>
            Finds filename, eg <c>@"b.txt"</c> in <c>@"c:\a\b.txt"</c>.
            </summary>
            <exception cref="T:System.ArgumentException"><c>'\\'</c> not found or is at the end. If noException, instead returns -1.</exception>
        </member>
        <member name="M:Au.AFile._RemoveFilename(System.String,System.Boolean)">
            <summary>
            Removes filename, eg <c>@"c:\a\b.txt"</c> -> <c>@"c:\a"</c>.
            </summary>
            <exception cref="T:System.ArgumentException"><c>'\\'</c> not found or is at the end. If noException, instead returns null.</exception>
        </member>
        <member name="M:Au.AFile._GetFilename(System.String,System.Boolean)">
            <summary>
            Gets filename, eg <c>@"c:\a\b.txt"</c> -> <c>@"b.txt"</c>.
            </summary>
            <exception cref="T:System.ArgumentException"><c>'\\'</c> not found or is at the end. If noException, instead returns null.</exception>
        </member>
        <member name="M:Au.AFile._IsSepChar(System.Char)">
            <summary>
            Returns true if character <c>c == '\\' || c == '/'</c>.
            </summary>
        </member>
        <member name="M:Au.AFile.WaitIfLocked``1(System.Func{``0},System.Int32)">
            <summary>
            This function can be used to safely open a file that may be temporarily locked (used by another process or thread). Waits while the file is locked.
            </summary>
            <returns>Returns the return value of the lambda <i>f</i>.</returns>
            <param name="f">Lambda that calls a function that creates, opens or opens/reads/closes a file.</param>
            <param name="millisecondsTimeout">Wait max this number of milliseconds. Can be <see cref="F:System.Threading.Timeout.Infinite"/> (-1).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>millisecondsTimeout</i> less than -1.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by the called function.</exception>
            <remarks>
            Calls the lambda and handles <b>IOException</b>. If the exception indicates that the file is locked, waits and retries in loop.
            </remarks>
            <example>
            <code><![CDATA[
            var s1 = File.ReadAllText(file); //unsafe. Exception if the file is locked.
            
            var s2 = AFile.WaitIfLocked(() => File.ReadAllText(file)); //safe. Waits while the file is locked.
            
            using(var f = AFile.WaitIfLocked(() => File.OpenText(file))) { //safe. Waits while the file is locked.
            	var s3 = f.ReadToEnd();
            }
            
            using(var f = AFile.WaitIfLocked(() => File.Create(file))) { //safe. Waits while the file is locked.
            	f.WriteByte(1);
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AFile.WaitIfLocked(System.Action,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException"><i>millisecondsTimeout</i> less than -1.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by the called function.</exception>
            <example>
            <code><![CDATA[
            File.WriteAllText(file, "TEXT"); //unsafe. Exception if the file is locked.
            
            AFile.WaitIfLocked(() => File.WriteAllText(file, "TEXT")); //safe. Waits while the file is locked.
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AFile.LoadText(System.String,System.Text.Encoding)">
            <summary>
            Loads text file in a safer way.
            Uses <see cref="M:System.IO.File.ReadAllText(System.String)"/> and <see cref="M:Au.AFile.WaitIfLocked``1(System.Func{``0},System.Int32)"/>.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.</param>
            <param name="encoding">Text encoding in file. Default <b>Encoding.UTF8</b>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.ReadAllText(System.String)"/>.</exception>
        </member>
        <member name="M:Au.AFile.LoadBytes(System.String)">
            <summary>
            Loads file in a safer way.
            Uses <see cref="M:System.IO.File.ReadAllBytes(System.String)"/> and <see cref="M:Au.AFile.WaitIfLocked``1(System.Func{``0},System.Int32)"/>.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.ReadAllBytes(System.String)"/>.</exception>
        </member>
        <member name="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)">
            <summary>
            Writes any data to a file in a safe way, using a callback function.
            </summary>
            <param name="file">
            File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            The file can exist or not; this function overwrites it. If the directory does not exist, this function creates it.
            </param>
            <param name="writer">
            Callback function (lambda etc) that creates/writes/closes a temporary file. Its parameter is the full path of the temporary file, which normally does not exist.
            May be called multiple times, because this function retries if the file is locked or if the directory does not exist (if writer throws <b>DirectoryNotFoundException</b> exception).
            </param>
            <param name="backup">Create backup file named <i>file</i> + "~backup".</param>
            <param name="tempDirectory">
            Directory for backup file and temporary file. If null or "" - <i>file</i>'s directory. Can contain environment variales etc.
            Must be in the same drive as <i>file</i>. If the directory does not exist, this function creates it.</param>
            <param name="lockedWaitMS">If cannot open file because it is open by another process etc, wait max this number of milliseconds. Can be <see cref="F:System.Threading.Timeout.Infinite"/> (-1).</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of the <i>writer</i> function.</exception>
            <exception cref="T:System.IO.IOException">Failed to replace file. The <i>writer</i> function also can thow it.</exception>
            <remarks>
            The file-write functions provided by .NET and Windows API are unreliable, because:
            1. Fails if the file is temporarily open by another process or thread without sharing.
            2. Can corrupt file data. If this thread, process, PC or disk dies while writing, may write only part of data or just make empty file. Usually it happens when PC is turned off incorrectly.
            
            To protect from 1, this functions waits/retries if the file is temporarily open/locked, like <see cref="M:Au.AFile.WaitIfLocked(System.Action,System.Int32)"/>.
            To protect from 2, this function writes to a temporary file and renames/replaces the specified file using API <msdn>ReplaceFile</msdn>. Although not completely atomic, it ensures that file data is not corrupt; if cannot write all data, does not change existing file data.
            Also this function auto-creates directory if does not exist.
            
            This function is slower. Speed can be important when saving many files.
            </remarks>
        </member>
        <member name="M:Au.AFile.SaveText(System.String,System.String,System.Boolean,System.String,System.Int32,System.Text.Encoding)">
            <summary>
            Writes text to a file in a safe way, using <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>.
            More info: <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.
            </summary>
            <param name="text">Text to write.</param>
            <param name="encoding">Text encoding in file. Default is UTF-8 without BOM.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="M:Au.AFile.SaveBytes(System.String,System.Byte[],System.Boolean,System.String,System.Int32)">
            <summary>
            Writes data to a file in a safe way, using <see cref="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])"/>.
            More info: <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.
            </summary>
            <param name="bytes">Data to write.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.</exception>
        </member>
        <member name="T:Au.AFile.More">
            <summary>
            Miscellaneous rarely used file/directory functions.
            </summary>
        </member>
        <member name="M:Au.AFile.More.GetFileId(System.String,Au.Types.FileId@)">
            <summary>
            Gets <see cref="T:Au.Types.FileId"/> of a file or directory.
            Returns false if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="path">Full path. Supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>).</param>
            <param name="fileId"></param>
        </member>
        <member name="M:Au.AFile.More.LibIsSameFile(System.String,System.String)">
            <summary>
            Calls <see cref="M:Au.AFile.More.GetFileId(System.String,Au.Types.FileId@)"/> for two paths and returns true if both calls succeed and the ids are equal.
            Paths should be normalized. They are passed to API unmodified.
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
        </member>
        <member name="M:Au.AFile.More.CalculateDirectorySize(System.String,Au.Types.FEFlags)">
            <summary>
            Calls <see cref="M:Au.AFile.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/> and returns sum of all file sizes.
            With default flags, it includes sizes of all descendant files, in this directory and all subdirectories except in inaccessible [sub]directories.
            </summary>
            <param name="path">Full path.</param>
            <param name="flags"><b>EnumDirectory</b> flags.</param>
            <exception cref="T:System.Exception"><see cref="M:Au.AFile.EnumDirectory(System.String,Au.Types.FEFlags,System.Func{Au.Types.FEFile,System.Boolean},System.Action{System.String})"/> exceptions. By default, no exceptions if used full path and the directory exists.</exception>
            <remarks>
            This function is slow if the directory is large.
            Don't use this function for files (throws exception) and drives (instead use <see cref="T:System.IO.DriveInfo"/>, it's fast and includes sizes of Recycle Bin and other protected hidden system directories).
            </remarks>
        </member>
        <member name="T:Au.AFolders">
             <summary>
             Gets known/special folder paths (Desktop, Temp, etc).
             </summary>
             <remarks>
             For return values is used type <see cref="T:Au.Types.FolderPath"/>, not string. It is implicitly convertible to string. Its operator + appends a filename or relative path string, with \ separator if need. Example: <c>string s = AFolders.Desktop + "file.txt"; //C:\Users\Name\Desktop\file.txt</c>
             If a function cannot get folder path, the return value contains null string. Then the + operator would throw <see cref="T:Au.Types.AuException"/>.
            
             Some folders are known only on newer Windows versions or only on some computers. Some property-get functions have a suffix like <b>_Win8</b> which means that the folder is unavailable on older Windows.
             Some known folders, although supported and registerd, may be still not created.
             
             Some folders are virtual, for example Control Panel. They don't have a file system path, but can be identified by an unmanaged array called "ITEMIDLIST" or "PIDL". Functions of the nested class <see cref="T:Au.AFolders.VirtualPidl"/> return it as <see cref="T:Au.APidl"/>. Functions of the nested class <see cref="T:Au.AFolders.Virtual"/> return it as string <c>":: ITEMIDLIST"</c> that can be used with some functions of this library (of classes <b>AExec</b>, <b>APidl</b>, <b>AIcon</b>) but not with .NET or native functions.
            
             Most functions use Windows "Known Folders" API, such as <msdn>SHGetKnownFolderPath</msdn>.
             The list of Windows predefined known folders: <msdn>KNOWNFOLDERID</msdn>.
             Names of folders specific to this application have prefix <b>This</b>, like <b>ThisApp</b>.
             
             Some paths depend on the bitness (32 or 64 bit) of the OS and this process.
             <table>
             <tr>
             <td>32-bit Windows</td>
             <td>
             System, SystemX86, SystemX64: <c>@"C:\WINDOWS\system32"</c>
             <br/>ProgramFiles, ProgramFilesX86, ProgramFilesX64: <c>@"C:\Program Files"</c>
             <br/>ProgramFilesCommon, ProgramFilesCommonX86, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             </td>
             </tr>
             <tr>
             <td>64-bit Windows, 64-bit process</td>
             <td>
             System, SystemX64: <c>@"C:\WINDOWS\system32"</c>
             <br/>SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
             <br/>ProgramFiles, ProgramFilesX64: <c>@"C:\Program Files"</c>
             <br/>ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
             <br/>ProgramFilesCommon, ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             <br/>ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
             </td>
             </tr>
             <tr>
             <td>64-bit Windows, 32-bit process</td>
             <td>
             System: <c>@"C:\WINDOWS\system32"</c>. However the OS in most cases redirects this path to <c>@"C:\WINDOWS\SysWOW64"</c>.
             <br/>SystemX86: <c>@"C:\WINDOWS\SysWOW64"</c>
             <br/>SystemX64: <c>@"C:\WINDOWS\Sysnative"</c>. The OS redirects it to the true <c>@"C:\WINDOWS\system32"</c>. It is a special path that you don't see in Explorer.
             <br/>ProgramFiles, ProgramFilesX86: <c>@"C:\Program Files (x86)"</c>
             <br/>ProgramFilesX64: <c>@"C:\Program Files"</c>
             <br/>ProgramFilesCommon, ProgramFilesCommonX86: <c>@"C:\Program Files (x86)\Common Files"</c>
             <br/>ProgramFilesCommonX64: <c>@"C:\Program Files\Common Files"</c>
             </td>
             </tr>
             </table>
             </remarks>
        </member>
        <member name="P:Au.AFolders.ProgramFiles">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.AFolders.ProgramFilesX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.AFolders.ProgramFilesCommon">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.AFolders.ProgramFilesCommonX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.AFolders.System">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.AFolders.SystemX86">
            <summary>More info in class help.</summary>
        </member>
        <member name="T:Au.AFolders.Virtual">
            <summary>
            Gets ITEMIDLIST of known/special virtual folders (eg Control Panel), as string like ":: 12345678...". 
            </summary>
        </member>
        <member name="T:Au.AFolders.VirtualPidl">
            <summary>
            Gets ITEMIDLIST of known/special virtual folders (eg Control Panel), as <see cref="T:Au.APidl"/>. 
            </summary>
        </member>
        <member name="P:Au.AFolders.Temp">
            <summary>
            Temp folder (temporary files) of this user account.
            </summary>
        </member>
        <member name="P:Au.AFolders.ThisApp">
            <summary>
            Folder containing assemblies of this app.
            </summary>
        </member>
        <member name="P:Au.AFolders.ThisAppBS">
            <summary>
            <see cref="P:Au.AFolders.ThisApp"/> with appended backslash character.
            Note: returns string, not <see cref="T:Au.Types.FolderPath"/> like other functions.
            </summary>
        </member>
        <member name="P:Au.AFolders.ThisAppTemp">
            <summary>
            Gets or sets path of folder "temporary files of this application".
            Default is <c>AFolders.Temp + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
            </remarks>
        </member>
        <member name="P:Au.AFolders.ThisAppDocuments">
            <summary>
            Gets or sets path of folder "user document files of this application".
            Default is <c>AFolders.Documents + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
            </remarks>
        </member>
        <member name="P:Au.AFolders.ThisAppData">
            <summary>
            Gets or sets path of folder "private files of this application of this user account".
            Default is <c>AFolders.RoamingAppData + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
            </remarks>
        </member>
        <member name="P:Au.AFolders.ThisAppDataLocal">
            <summary>
            Gets or sets path of folder "local (non-roaming) private files of this application of this user account".
            Default is <c>AFolders.LocalAppData + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Creates the folder if does not exist when 'set' or 'get' function called first time in this process.
            </remarks>
        </member>
        <member name="P:Au.AFolders.ThisAppDataCommon">
            <summary>
            Gets or sets path of folder "common (all users) private files of this application".
            Default is <c>AFolders.ProgramData + "Au"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            The 'set' function does not change system settings. It just remembers a string that will be later returned by the 'get' function in this process.
            Note: the ProgramData folder has special permissions. Programs running not as administrator usually cannot write there.
            This function does not auto-create the folder; usually it is created when installing the application.
            </remarks>
        </member>
        <member name="P:Au.AFolders.ThisAppImages">
            <summary>
            Gets or sets path of folder "images (icons etc) of this application".
            Default is <c>ThisAppBS + "Images"</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown by the 'set' function if this property is already set.</exception>
            <remarks>
            Used by functions of these classes: AIcon, AMenu, AToolbar, AWinImage, possibly some other.
            This function does not auto-create the folder; usually it is created when installing the application.
            </remarks>
        </member>
        <member name="P:Au.AFolders.Workspace">
            <summary>
            Gets folder of current workspace.
            Available only in the Au editor process. Elsewhere null.
            </summary>
        </member>
        <member name="P:Au.AFolders.SystemX64">
            <summary>
            Gets non-redirected path of the System32 folder.
            </summary>
            <remarks>
            If this process is 32-bit and OS is 64-bit, when it uses the <see cref="P:Au.AFolders.System"/> folder path (<c>@"C:\WINDOWS\system32"</c>), the OS in most cases redirects it to <c>@"C:\Windows\SysWOW64"</c>, which contains 32-bit versions of program files. Use SystemX64 when you want to avoid the redirection and access the true System32 folder which on 64-bit OS contains 64-bit program files.
            More info in class help.
            </remarks>
            <seealso cref="T:Au.Util.ADisableFsRedirection"/>
            <seealso cref="P:Au.AVersion.Is32BitProcessAnd64BitOS"/>
        </member>
        <member name="P:Au.AFolders.ProgramFilesX64">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.AFolders.ProgramFilesCommonX64">
            <summary>More info in class help.</summary>
        </member>
        <member name="P:Au.AFolders.NetRuntime">
            <summary>
            Gets .NET Core runtime folder, like <c>C:\Program Files\dotnet\shared\Microsoft.NETCore.App\3.1.0</c>.
            </summary>
        </member>
        <member name="P:Au.AFolders.NetRuntimeBS">
            <summary>
            Gets .NET Core runtime folder with <c>'\\'</c> at the end, like <c>C:\Program Files\dotnet\shared\Microsoft.NETCore.App\3.1.0\</c>.
            </summary>
        </member>
        <member name="P:Au.AFolders.NetRuntimeDesktop">
            <summary>
            Gets .NET Core runtime desktop folder, like <c>C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\3.1.0</c>.
            </summary>
        </member>
        <member name="P:Au.AFolders.NetRuntimeDesktopBS">
            <summary>
            Gets .NET Core runtime desktop folder with <c>'\\'</c> at the end, like <c>C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\3.1.0\</c>.
            </summary>
        </member>
        <member name="P:Au.AFolders.CdDvdDrive">
            <summary>
            Gets CD/DVD drive path, like <c>@"D:\"</c>.
            Returns null if unavailable.
            </summary>
        </member>
        <member name="P:Au.AFolders.RemovableDrive0">
            <summary>Calls <see cref="M:Au.AFolders.RemovableDrive(System.Int32)"/>(0).</summary>
        </member>
        <member name="P:Au.AFolders.RemovableDrive1">
            <summary>Calls <see cref="M:Au.AFolders.RemovableDrive(System.Int32)"/>(1).</summary>
        </member>
        <member name="P:Au.AFolders.RemovableDrive2">
            <summary>Calls <see cref="M:Au.AFolders.RemovableDrive(System.Int32)"/>(2).</summary>
        </member>
        <member name="P:Au.AFolders.RemovableDrive3">
            <summary>Calls <see cref="M:Au.AFolders.RemovableDrive(System.Int32)"/>(3).</summary>
        </member>
        <member name="M:Au.AFolders.RemovableDrive(System.Int32)">
            <summary>
            Gets removable/external/USB drive path, like <c>@"F:\"</c>.
            Returns null if unavailable.
            </summary>
            <param name="driveIndex">0-based removable drive index.</param>
            <remarks>Uses <see cref="M:System.IO.DriveInfo.GetDrives"/> and counts only drives of type DriveType.Removable.</remarks>
        </member>
        <member name="M:Au.AFolders.RemovableDrive(System.String)">
            <summary>
            Gets removable/external/USB drive name (like <c>@"F:\"</c>) by its volume label.
            Returns null if unavailable.
            </summary>
            <param name="volumeLabel">Volume label. You can see it in drive Properties dialog; it is not the drive name that is displayed in File Explorer.</param>
        </member>
        <member name="M:Au.AFolders.EnvVar(System.String)">
            <summary>
            Gets the value of an environment variable.
            Returns null if unavailable.
            </summary>
        </member>
        <member name="M:Au.AFolders.GetKnownFolders">
            <summary>
            Gets canonical names and paths of all known folders, including custom known folders registerd by applications.
            These names can be used with <see cref="M:Au.AFolders.GetFolder(System.String)"/>.
            </summary>
        </member>
        <member name="M:Au.AFolders.GetFolder(System.String)">
            <summary>
            Gets path of a known folder by its name as string.
            Returns null if unavailable.
            </summary>
            <param name="folderName">
            A property name of this class. Examples: <c>"Documents"</c>, <c>"Temp"</c>, <c>"ThisApp"</c>.
            Or a property name of the nested class Virtual, like <c>"Virtual.ControlPanel"</c>. Gets <c>":: ITEMIDLIST"</c>.
            Or known folder canonical name. See <see cref="M:Au.AFolders.GetKnownFolders"/>. If has prefix <c>"Virtual."</c>, gets <c>":: ITEMIDLIST"</c>. Much slower, but allows to get paths of folders registered by applications.
            </param>
        </member>
        <member name="T:Au.AIcon">
            <summary>
            Gets icons for files etc.
            </summary>
        </member>
        <member name="M:Au.AIcon.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)">
            <summary>
            Gets file icon.
            Extracts icon directly from the file, or gets shell icon, depending on file type, icon index, flags etc.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="file">
            Can be:
            - Path of any file or folder.
            - URL, like <c>"http://..."</c> or <c>"mailto:a@b.c"</c> or <c>"file:///path"</c>.
            - ITEMIDLIST like <c>":: ITEMIDLIST"</c>. It can be of any file, folder, URL or virtual object like Control Panel. See <see cref="M:Au.APidl.ToBase64String"/>.
            - Shell object parsing name, like <c>@"::{CLSID-1}\::{CLSID-2}"</c> or <c>@"shell:AppsFolder\WinStoreAppId"</c>.
            - File type like <c>".txt"</c> or URL protocol like <c>"http:"</c>.
            
            If it is a file containing multiple icons (eg exe, dll), can be specified icon index like <c>"path,index"</c> or native icon resource id like <c>"path,-id"</c>.
            If not full path, the function will look in <see cref="P:Au.AFolders.ThisAppImages"/>. See also <see cref="T:Au.Types.GIFlags"/>.
            Supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>).
            </param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.AIcon.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)">
            <summary>
            Gets file icon.
            More info: <see cref="M:Au.AIcon.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>.
            </summary>
            <returns>Returns null if failed.</returns>
        </member>
        <member name="M:Au.AIcon.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)">
            <summary>
            Gets file icon.
            More info: <see cref="M:Au.AIcon.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>.
            </summary>
            <returns>Returns icon handle, or default(IntPtr) if failed. Later call <see cref="M:Au.AIcon.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy it.</returns>
        </member>
        <member name="M:Au.AIcon.GetPidlIcon(Au.APidl,System.Int32)">
            <summary>
            Gets icon of a file or other shell object specified as ITEMIDLIST.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="pidl">ITEMIDLIST pointer (PIDL).</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.AIcon.GetPidlIconImage(Au.APidl,System.Int32)">
            <summary>
            Gets icon of a file or other shell object specified as ITEMIDLIST.
            More info: <see cref="M:Au.AIcon.GetPidlIcon(Au.APidl,System.Int32)"/>.
            </summary>
            <returns>Returns null if failed.</returns>
        </member>
        <member name="M:Au.AIcon.GetPidlIconHandle(Au.APidl,System.Int32)">
            <summary>
            Gets icon of a file or other shell object specified as ITEMIDLIST.
            More info: <see cref="M:Au.AIcon.GetPidlIcon(Au.APidl,System.Int32)"/>.
            </summary>
            <returns>Returns icon handle, or default(IntPtr) if failed. Later call <see cref="M:Au.AIcon.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy it.</returns>
        </member>
        <member name="M:Au.AIcon.GetShellIconSize(Au.Types.IconSize)">
            <summary>
            Gets the width and height of shell icons of standard sizes - small, large, extra large and jumbo.
            Jumbo is always 256. Others depend on text size (DPI) that can be changed in Windows Settings. If text size is 100%, they usually are 16, 32, 48.
            </summary>
        </member>
        <member name="M:Au.AIcon.LoadIcon(System.String,System.Int32,System.Int32)">
            <summary>
            Extracts icon from file that contains it.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="file">.ico, .exe, .dll or other file that contains one or more icons. Also supports cursor files - .cur, .ani. Must be full path, without icon index. Supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>).</param>
            <param name="index">Icon index or negative icon resource id in the .exe/.dll file.</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.AIcon.LoadIconHandle(System.String,System.Int32,System.Int32)">
            <summary>
            Extracts icon from file that contains it.
            More info: <see cref="M:Au.AIcon.LoadIcon(System.String,System.Int32,System.Int32)"/>.
            </summary>
            <returns>Returns icon handle, or default(IntPtr) if failed. Later call <see cref="M:Au.AIcon.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy it.</returns>
        </member>
        <member name="M:Au.AIcon.GetStockIcon(Au.Types.StockIcon,System.Int32)">
            <summary>
            Gets a shell stock icon.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="icon">Shell stock icon id.</param>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.AIcon.GetStockIconHandle(Au.Types.StockIcon,System.Int32)">
            <summary>
            Gets a shell stock icon.
            More info: <see cref="M:Au.AIcon.GetStockIcon(Au.Types.StockIcon,System.Int32)"/>.
            </summary>
            <returns>Returns icon handle, or default(IntPtr) if failed. Later call <see cref="M:Au.AIcon.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy it.</returns>
        </member>
        <member name="M:Au.AIcon.GetAppIcon(System.Int32)">
            <summary>
            Gets <msdn>IDI_APPLICATION</msdn> icon from unmanaged resources of this program file.
            </summary>
            <returns>Returns null if there are no icons.</returns>
            <param name="size">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
        </member>
        <member name="M:Au.AIcon.GetAppIconHandle(System.Int32)">
            <summary>
            Gets <msdn>IDI_APPLICATION</msdn> icon from unmanaged resources of this program file.
            More info: <see cref="M:Au.AIcon.GetAppIcon(System.Int32)"/>.
            </summary>
            <returns>Returns native icon handle, or default(IntPtr) if there are no icons.</returns>
            <remarks>The icon is cached and protected from destroying, therefore don't need to destroy it, and not error to do it.</remarks>
        </member>
        <member name="M:Au.AIcon.GetWindowIcon(Au.AWnd,System.Boolean)">
            <summary>
            Gets icon that is displayed in window title bar and in taskbar button.
            </summary>
            <returns>Returns null if failed.</returns>
            <param name="w"></param>
            <param name="size32">Get 32x32 icon. If false, gets 16x16 icon.</param>
            <remarks>
            Icon size depends on DPI (text size, can be changed in Windows Settings). By default small is 16, large 32.
            This function can be used with windows of any process.
            </remarks>
        </member>
        <member name="M:Au.AIcon.GetWindowIconHandle(Au.AWnd,System.Boolean)">
            <summary>
            Gets icon that is displayed in window title bar and in taskbar button.
            </summary>
            <returns>Returns icon handle, or default(IntPtr) if failed. Later call <see cref="M:Au.AIcon.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy it.</returns>
            <param name="w"></param>
            <param name="size32">Get 32x32 icon. If false, gets 16x16 icon.</param>
            <remarks>
            Icon size depends on DPI (text size, can be changed in Windows Settings). By default small is 16, large 32.
            This function can be used with windows of any process.
            </remarks>
        </member>
        <member name="M:Au.AIcon.CreateIcon(System.Int32,System.Int32,System.Action{System.Drawing.Graphics})">
            <summary>
            Creates icon at run time.
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="drawCallback">Called to draw icon. If null, the icon will be completely transparent.</param>
        </member>
        <member name="M:Au.AIcon.CreateIconHandle(System.Int32,System.Int32,System.Action{System.Drawing.Graphics})">
            <summary>
            Creates icon at run time.
            More info: <see cref="M:Au.AIcon.CreateIcon(System.Int32,System.Int32,System.Action{System.Drawing.Graphics})"/>.
            </summary>
            <returns>Returns native icon handle. Later call <see cref="M:Au.AIcon.DestroyIconHandle(System.IntPtr)"/> or some <b>HandleToX</b> function that will destroy it.</returns>
        </member>
        <member name="M:Au.AIcon.DestroyIconHandle(System.IntPtr)">
            <summary>
            Destroys native icon.
            Calls API <msdn>DestroyIcon</msdn>. Does nothing if iconHandle is default(IntPtr).
            </summary>
        </member>
        <member name="M:Au.AIcon.HandleToIcon(System.IntPtr,System.Boolean)">
            <summary>
            Converts unmanaged icon to Icon object.
            Returns null if hIcon is default(IntPtr).
            </summary>
            <param name="hIcon">Icon handle.</param>
            <param name="destroyIcon">If true (default), the returned variable owns the unmanaged icon and destroys it when disposing. If false, the returned variable just uses the unmanaged icon and will not destroy; the caller later should destroy it with <see cref="M:Au.AIcon.DestroyIconHandle(System.IntPtr)"/>.</param>
        </member>
        <member name="M:Au.AIcon.HandleToImage(System.IntPtr,System.Boolean)">
            <summary>
            Converts unmanaged icon to Bitmap object and destroys the unmanaged icon.
            Returns null if hIcon is default(IntPtr) or if fails to convert.
            </summary>
            <param name="hIcon">Icon handle.</param>
            <param name="destroyIcon">If true (default), destroys the unmanaged icon.</param>
        </member>
        <member name="M:Au.AIcon.ParseIconLocation(System.String@,System.Int32@)">
            <summary>
            Parses icon location string.
            Returns true if it includes icon index or resource id.
            </summary>
            <param name="s">Icon location. Can be <c>"path,index"</c> or <c>"path,-id"</c> or just path. Receives path.</param>
            <param name="index">Receives the number or 0.</param>
            <remarks>Also supports path enclosed in double quotes like <c>"\"path\",index"</c>, and spaces between comma and index like <c>"path, index"</c>.</remarks>
        </member>
        <member name="T:Au.AIconCache">
            <summary>
            Gets icons of files etc as Bitmap. Uses 2-level cache - memory and file.
            </summary>
            <threadsafety static="true" instance="true"/>
        </member>
        <member name="M:Au.AIconCache.#ctor(System.String,System.Int32)">
            
        </member>
        <member name="M:Au.AIconCache.SaveCacheFileNow">
            <summary>
            Saves to the cache file now, if need.
            Automatically called on process exit.
            </summary>
        </member>
        <member name="M:Au.AIconCache.ClearCache">
            <summary>
            Clears the memory cache and deletes the cache file.
            </summary>
        </member>
        <member name="M:Au.AIconCache.GetImage(System.String,System.Boolean,Au.Types.GIFlags,System.Action{System.Drawing.Bitmap,System.Object},System.Object)">
            <summary>
            Gets file icon as <b>Bitmap</b>.
            Returns null if the icon is not cached and failed to get it, eg file does not exist.
            </summary>
            <param name="file">Any file or folder.</param>
            <param name="useExt">
            Get file type icon, depending on filename extension. Use this to avoid getting separate image object for each file of same type.
            This is ignored if filename extension is ".ico" or ".exe" or starts with ".exe," or ".dll,".
            </param>
            <param name="giFlags">Flags for <see cref="M:Au.AIcon.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)"/>.</param>
            <param name="autoUpdate">
            If not null, the cached image will be auto-updated when changed. Then will be called this function. It can update the image in UI.
            How it works: If this function finds cached image, it sets timer that after ~50 ms loads that icon/image from file again and compares with the cached image. If different, updates the cache. Does it once, not periodically.
            Use only in UI threads. Does not work if this thread does not retrieve/dispatch posted messages.
            </param>
            <param name="auParam">Something to pass to the <i>autoUpdate</i> callback function.</param>
            <remarks>
            If the icon is in the memory cache, gets it from there.
            Else if it is in the file cache, gets it from there and adds to the memory cache.
            Else gets from file (uses <see cref="M:Au.AIcon.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)"/> and adds to the file cache and to the memory cache.
            </remarks>
        </member>
        <member name="M:Au.AIconCache.GetImage(System.String,System.Func{System.Drawing.Bitmap},System.Action{System.Drawing.Bitmap,System.Object},System.Object,System.Boolean)">
            <summary>
            Gets any icon or image using callback function.
            Returns null if the icon is not cached and the callback function returns null.
            </summary>
            <param name="name">Some unique name. It is used to identify this image in cache.</param>
            <param name="callback">Called to get image. To convert icon handle to image, use <see cref="M:Au.AIcon.HandleToImage(System.IntPtr,System.Boolean)"/>.</param>
            <param name="autoUpdate"></param>
            <param name="auParam"></param>
            <param name="auDispose">If true (default), auto-updating can dispose unused image returned by <i>callback</i>.</param>
            <remarks>
            If the icon is in the memory cache, gets it from there.
            Else if it is in the file cache, gets it from there and adds to the memory cache.
            Else calls callback function, which should return image, and adds to the file cache and to the memory cache.
            </remarks>
        </member>
        <member name="T:Au.APath">
            <summary>
            Extends <see cref="T:System.IO.Path"/>.
            </summary>
        </member>
        <member name="M:Au.APath.ExpandEnvVar(System.String)">
             <summary>
             If path starts with <c>"%"</c> or <c>"\"%"</c>, expands environment variables enclosed in %, else just returns path.
             Also supports known folder names, like <c>"%AFolders.Documents%"</c>. More info in Remarks.
             </summary>
             <param name="path">Any string. Can be null.</param>
             <remarks>
             Supports known folder names. See <see cref="T:Au.AFolders"/>.
             Example: <c>@"%AFolders.Documents%\file.txt"</c>.
             Example: <c>@"%AFolders.Virtual.ControlPanel%" //gets ":: ITEMIDLIST"</c>.
             Usually known folders are used like <c>string path = AFolders.Documents + "file.txt"</c>. However it cannot be used when you want to store paths in text files, registry, etc. Then this feature is useful.
             To get known folder path, this function calls <see cref="M:Au.AFolders.GetFolder(System.String)"/>.
            
             This function is called by many functions of classes <b>APath</b>, <b>AFile</b>, <b>AExec</b>, <b>AIcon</b>, some others, therefore all they support environment variables and known folders in path string.
             </remarks>
        </member>
        <member name="M:Au.APath.LibGetEnvVar(System.String)">
            <summary>
            Gets environment variable's value.
            Returns "" if variable not found.
            Does not support AFolders.X.
            </summary>
            <param name="name">Case-insensitive name. Without %.</param>
            <remarks>
            Environment variable values cannot be "" or null. Setting empty value removes the variable.
            </remarks>
        </member>
        <member name="M:Au.APath.LibEnvVarExists(System.String)">
            <summary>
            Returns true if environment variable exists.
            </summary>
            <param name="name">Case-insensitive name.</param>
        </member>
        <member name="M:Au.APath.IsFullPath(System.String)">
            <summary>
            Returns true if the string is full path, like <c>@"C:\a\b.txt"</c> or <c>@"C:"</c> or <c>@"\\server\share\..."</c>:
            </summary>
            <param name="path">Any string. Can be null.</param>
            <remarks>
            Returns true if <i>path</i> matches one of these wildcard patterns:
            - <c>@"?:\*"</c> - local path, like <c>@"C:\a\b.txt"</c>. Here ? is A-Z, a-z.
            - <c>@"?:"</c> - drive name, like <c>@"C:"</c>. Here ? is A-Z, a-z.
            - <c>@"\\*"</c> - network path, like <c>@"\\server\share\..."</c>. Or has prefix <c>@"\\?\"</c>.
            
            Supports <c>'/'</c> characters too.
            
            Supports only file-system paths. Returns false if path is URL (<see cref="M:Au.APath.IsUrl(System.String)"/>) or starts with <c>"::"</c>.
            
            If path starts with <c>"%environmentVariable%"</c>, shows warning and returns false. You should at first expand environment variables with <see cref="M:Au.APath.ExpandEnvVar(System.String)"/> or instead use <see cref="M:Au.APath.IsFullPathExpandEnvVar(System.String@)"/>.
            </remarks>
        </member>
        <member name="M:Au.APath.IsFullPathExpandEnvVar(System.String@)">
            <summary>
            Expands environment variables and calls <see cref="M:Au.APath.IsFullPath(System.String)"/>.
            Returns true if the string is full path, like <c>@"C:\a\b.txt"</c> or <c>@"C:"</c> or <c>@"\\server\share\..."</c>:
            </summary>
            <param name="path">
            Any string. Can be null.
            If starts with '%' character, calls <see cref="M:Au.APath.IsFullPath(System.String)"/> with expanded environment variables (<see cref="M:Au.APath.ExpandEnvVar(System.String)"/>). If it returns true, replaces the passed variable with the expanded path string.
            </param>
            <remarks>
            Returns true if <i>path</i> matches one of these wildcard patterns:
            - <c>@"?:\*"</c> - local path, like <c>@"C:\a\b.txt"</c>. Here ? is A-Z, a-z.
            - <c>@"?:"</c> - drive name, like <c>@"C:"</c>. Here ? is A-Z, a-z.
            - <c>@"\\*"</c> - network path, like <c>@"\\server\share\..."</c>. Or has prefix <c>@"\\?\"</c>.
            Supports '/' characters too.
            Supports only file-system paths. Returns false if path is URL (<see cref="M:Au.APath.IsUrl(System.String)"/>) or starts with <c>"::"</c>.
            </remarks>
        </member>
        <member name="M:Au.APath.GetRootLength(System.String)">
            <summary>
            Gets the length of the drive or network folder part in path, including its separator if any.
            If the string does not start with a drive or network folder path, returns 0 or prefix length (<c>@"\\?\"</c> or <c>@"\\?\UNC\"</c>).
            </summary>
            <param name="path">Full path or any string. Can be null. Should not be <c>@"%environmentVariable%\..."</c>.</param>
            <remarks>
            Supports prefixes <c>@"\\?\"</c> and <c>@"\\?\UNC\"</c>.
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            </remarks>
        </member>
        <member name="M:Au.APath.GetUrlProtocolLength(System.String)">
            <summary>
            Gets the length of the URL protocol name (also known as URI scheme) in string, including ':'.
            If the string does not start with a protocol name, returns 0.
            </summary>
            <param name="s">A URL or path or any string. Can be null.</param>
            <remarks>
            URL examples: <c>"http:"</c> (returns 5), <c>"http://www.x.com"</c> (returns 5), <c>"file:///path"</c> (returns 5), <c>"shell:etc"</c> (returns 6).
            
            The protocol can be unknown. The function just checks string format, which is an ASCII alpha character followed by one or more ASCII alpha-numeric, '.', '-', '+' characters, followed by ':' character.
            </remarks>
        </member>
        <member name="M:Au.APath.IsUrl(System.String)">
            <summary>
            Returns true if the string starts with a URL protocol name (existing or not) and ':' character.
            Calls <see cref="M:Au.APath.GetUrlProtocolLength(System.String)"/> and returns true if it's not 0.
            </summary>
            <param name="s">A URL or path or any string. Can be null.</param>
            <remarks>
            URL examples: <c>"http:"</c>, <c>"http://www.x.com"</c>, <c>"file:///path"</c>, <c>"shell:etc"</c>.
            </remarks>
        </member>
        <member name="M:Au.APath.Combine(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Combines two path parts using character <c>'\\'</c>. For example directory path and file name.
            </summary>
            <param name="s1">First part. Usually a directory.</param>
            <param name="s2">Second part. Usually a filename or relative path.</param>
            <param name="s2CanBeFullPath">s2 can be full path. If it is, ignore s1 and return s2 with expanded environment variables. If false (default), simply combines s1 and s2.</param>
            <param name="prefixLongPath">Call <see cref="M:Au.APath.PrefixLongPathIfNeed(System.String)"/> which may prepend <c>@"\\?\"</c> if the result path is very long. Default true.</param>
            <remarks>
            If s1 and s2 are null or "", returns "". Else if s1 is null or "", returns s2. Else if s2 is null or "", returns s1.
            Similar to System.IO.Path.Combine. Main differences: does not throw exceptions; has some options.
            Does not expand environment variables. For it use <see cref="M:Au.APath.ExpandEnvVar(System.String)"/> before, or <see cref="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)"/> instead. Path that starts with an environment variable is considerd not full path.
            </remarks>
            <seealso cref="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)"/>
        </member>
        <member name="M:Au.APath.LibCombine(System.String,System.String,System.Boolean)">
            <summary>
            Combines two path parts.
            Unlike <see cref="M:Au.APath.Combine(System.String,System.String,System.Boolean,System.Boolean)"/>, fails if some part is empty or <c>@"\"</c> or if s2 is <c>@"\\"</c>. Also does not check s2 full path.
            If fails, throws exception or returns null (if noException).
            </summary>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Au.APath.LibIsSepChar(System.Char)">
            <summary>
            Returns true if character <c>c == '\\' || c == '/'</c>.
            </summary>
        </member>
        <member name="M:Au.APath._EndsWithDriveWithoutSep(System.String,System.Int32)">
            <summary>
            Returns true if ends with ':' preceded by a drive letter, like "C:" or "more\C:", but not like "moreC:".
            </summary>
            <param name="s">Can be null.</param>
            <param name="length">Use when want to check drive at a middle, not at the end. Eg returns true if s is <c>@"C:\more"</c> and length is 2.</param>
        </member>
        <member name="M:Au.APath._AddRemoveSep(System.String)">
            <summary>
            Ensures that s either ends with a valid drive path (eg <c>@"C:\"</c> but not "C:") or does not end with <c>'\\'</c> or <c>'/'</c> (unless would become empty if removed).
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)">
            <summary>
            Makes normal full path from path that can contain special substrings etc.
            </summary>
            <param name="path">Any path.</param>
            <param name="defaultParentDirectory">If path is not full path, combine it with defaultParentDirectory to make full path.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">path is not full path, and <i>defaultParentDirectory</i> is not used or does not make it full path.</exception>
            <remarks>
            The sequence of actions:
            1. If path starts with '%' character, expands environment variables and special folder names. See <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            2. If path is not full path but looks like URL, and used flag CanBeUrl, returns path.
            3. If path is not full path, and defaultParentDirectory is not null/"", combines path with ExpandEnvVar(defaultParentDirectory).
            4. If path is not full path, throws exception.
            5. Calls API <msdn>GetFullPathName</msdn>. It replaces <c>'/'</c> with <c>'\\'</c>, replaces multiple <c>'\\'</c> with single (where need), processes <c>@"\.."</c> etc, trims spaces, etc.
            6. If no flag DoNotExpandDosPath, if path looks like a short DOS path version (contains <c>'~'</c> etc), calls API <msdn>GetLongPathName</msdn>. It converts short DOS path to normal path, if possible, for example <c>@"c:\progra~1"</c> to <c>@"c:\program files"</c>. It is slow. It converts path only if the file exists.
            7. If no flag DoNotRemoveEndSeparator, removes <c>'\\'</c> character at the end, unless it is like <c>@"C:\"</c>.
            8. Appends <c>'\\'</c> character if ends with a drive name (eg <c>"C:"</c> -> <c>@"C:\"</c>).
            9. If no flag DoNotPrefixLongPath, calls <see cref="M:Au.APath.PrefixLongPathIfNeed(System.String)"/>, which adds <c>@"\\?\"</c> etc prefix if path is very long.
            
            Similar to <see cref="M:System.IO.Path.GetFullPath(System.String)"/>. Main differences: this function expands environment variables, does not support relative paths, supports <c>@"\\?\very long path"</c>, trims <c>'\\'</c> at the end if need, does not throw exceptions when it thinks that path is invalid (except when path is not full).
            </remarks>
        </member>
        <member name="M:Au.APath.LibNormalize(System.String,Au.Types.PNFlags,System.Boolean)">
            <summary>
            Same as <see cref="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)"/>, but skips full-path checking.
            s should be full path. If not full and not null/"", combines with current directory.
            </summary>
        </member>
        <member name="M:Au.APath.LibNormalizeMinimally(System.String,System.Boolean)">
            <summary>
            Prepares path for passing to API that support "..", DOS path etc.
            Calls ExpandEnvVar, _AddRemoveSep, PrefixLongPathIfNeed. Optionally throws if !IsFullPath(path).
            </summary>
            <exception cref="T:System.ArgumentException">Not full path (only if throwIfNotFullPath is true).</exception>
        </member>
        <member name="M:Au.APath.LibNormalizeForNET(System.String)">
            <summary>
            Prepares path for passing to .NET file functions.
            Calls ExpandEnvVar, _AddRemoveSep. Throws if !IsFullPath(path).
            </summary>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
        </member>
        <member name="M:Au.APath.LibExpandDosPath(System.String)">
            <summary>
            Calls API GetLongPathName.
            Does not check whether s contains '~' character etc. Note: the API is slow.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.APath.LibIsPossiblyDos(System.String)">
            <summary>
            Returns true if pathOrFilename looks like a DOS filename or path.
            Examples: <c>"abcde~12"</c>, <c>"abcde~12.txt"</c>, <c>@"c:\path\abcde~12.txt"</c>, <c>"c:\abcde~12\path"</c>.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.APath.LibIsShellPath(System.String)">
            <summary>
            Returns true if starts with "::".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.APath.PrefixLongPath(System.String)">
            <summary>
            If path is full path (see <see cref="M:Au.APath.IsFullPath(System.String)"/>) and does not start with <c>@"\\?\"</c>, prepends <c>@"\\?\"</c>.
            If path is network path (like <c>@"\\computer\folder\..."</c>), makes like <c>@"\\?\UNC\computer\folder\..."</c>.
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with <c>"%environmentVariable%"</c>. This function does not expand it. See <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            </param>
            <remarks>
            Windows API kernel functions support extended-length paths, ie longer than 259 characters. But the path must have this prefix. Windows API shell functions don't support it.
            </remarks>
        </member>
        <member name="M:Au.APath.PrefixLongPathIfNeed(System.String)">
            <summary>
            Calls <see cref="M:Au.APath.PrefixLongPath(System.String)"/> if path is longer than <see cref="F:Au.APath.MaxDirectoryPathLength"/> (247).
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with <c>"%environmentVariable%"</c>. This function does not expand it. See <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            </param>
        </member>
        <member name="M:Au.APath.UnprefixLongPath(System.String)">
            <summary>
            If path starts with <c>@"\\?\"</c> prefix, removes it.
            If path starts with <c>@"\\?\UNC\"</c> prefix, removes <c>@"?\UNC\"</c>.
            </summary>
            <param name="path">
            Path. Can be null.
            Must not start with <c>"%environmentVariable%"</c>. This function does not expand it. See <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            </param>
        </member>
        <member name="M:Au.APath._GetPrefixLength(System.String)">
            <summary>
            If s starts with <c>@"\\?\UNC\"</c>, returns 8.
            Else if starts with <c>@"\\?\"</c>, returns 4.
            Else returns 0.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="F:Au.APath.MaxFilePathLength">
            <summary>
            Maximal file (not directory) path length supported by all functions (native, .NET and this library).
            For longer paths need <c>@"\\?\"</c> prefix. It is supported by most native kernel API (but not shell API) and by most functions of this library.
            </summary>
        </member>
        <member name="F:Au.APath.MaxDirectoryPathLength">
            <summary>
            Maximal directory path length supported by all functions (native, .NET and this library).
            For longer paths need <c>@"\\?\"</c> prefix. It is supported by most native kernel API (but not shell API) and by most functions of this library.
            </summary>
        </member>
        <member name="M:Au.APath.CorrectFileName(System.String,System.String)">
            <summary>
            Replaces characters that cannot be used in file names.
            Returns valid filename. However it can be too long (itself or when combined with a directory path).
            </summary>
            <param name="name">Initial filename.</param>
            <param name="invalidCharReplacement">A string that will replace each invalid character. Default <c>"-"</c>.</param>
            <remarks>
            Also corrects other forms of invalid or problematic filename: trims spaces and other blank characters; replaces <c>"."</c> at the end; prepends <c>"@"</c> if a reserved name like <c>"CON"</c> or <c>"CON.txt"</c>; returns <c>"-"</c> if name is null/empty/whitespace.
            </remarks>
        </member>
        <member name="M:Au.APath.IsInvalidFileName(System.String)">
            <summary>
            Returns true if name cannot be used for a file name, eg contains <c>'\\'</c> etc characters or is empty.
            More info: <see cref="M:Au.APath.CorrectFileName(System.String,System.String)"/>.
            </summary>
            <param name="name">Any string. Example: "name.txt". Can be null.</param>
        </member>
        <member name="M:Au.APath.GetFileName(System.String,System.Boolean)">
            <summary>
            Gets filename with or without extension.
            Returns "" if there is no filename.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <param name="withoutExtension">Remove extension, unless <i>path</i> ends with <c>'\\'</c> or <c>'/'</c>.</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})"/> and <see cref="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})"/>. Some differences: does not throw exceptions; if ends with <c>'\\'</c> or <c>'/'</c>, gets part before it, eg <c>"B"</c> from <c>@"C:\A\B\"</c>.
            
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            Also supports URL and shell parsing names like <c>@"::{CLSID-1}\0\::{CLSID-2}"</c>.
            
            Examples:
            
            | path | result
            | - | -
            | <c>@"C:\A\B\file.txt"</c> | <c>"file.txt"</c>
            | <c>"file.txt"</c> | <c>"file.txt"</c>
            | <c>"file"</c> | <c>"file"</c>
            | <c>@"C:\A\B"</c> | <c>"B"</c>
            | <c>@"C:\A\B\"</c> | <c>"B"</c>
            | <c>@"C:\A\/B\/"</c> | <c>"B"</c>
            | <c>@"C:\"</c> | <c>""</c>
            | <c>@"C:"</c> | <c>""</c>
            | <c>@"\\network\share"</c> | <c>"share"</c>
            | <c>@"C:\aa\file.txt:alt.stream"</c> | <c>"file.txt:alt.stream"</c>
            | <c>"http://a.b.c"</c> | <c>"a.b.c"</c>
            | <c>"::{A}\::{B}"</c> | <c>"::{B}"</c>
            | <c>""</c> | <c>""</c>
            | <c>null</c> | <c>null</c>
            
            Examples when <i>withoutExtension</i> true:
            
            | path | result
            | - | -
            | <c>@"C:\A\B\file.txt"</c> | <c>"file"</c>
            | <c>"file.txt"</c> | <c>"file"</c>
            | <c>"file"</c> | <c>"file"</c>
            | <c>@"C:\A\B"</c> | <c>"B"</c>
            | <c>@"C:\A\B\"</c> | <c>"B"</c>
            | <c>@"C:\A\B.B\"</c> | <c>"B.B"</c>
            | <c>@"C:\aa\file.txt:alt.stream"</c> | <c>"file.txt:alt"</c>
            | <c>"http://a.b.c"</c> | <c>"a.b"</c>
            </remarks>
        </member>
        <member name="M:Au.APath.GetExtension(System.String)">
            <summary>
            Gets filename extension, like <c>".txt"</c>.
            Returns "" if there is no extension.
            Returns null if path is null.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            Like <see cref="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})"/>, but does not throw exceptions.
            </remarks>
        </member>
        <member name="M:Au.APath.GetExtension(System.String,System.String@)">
            <summary>
            Gets filename extension and path part without the extension.
            More info: <see cref="M:Au.APath.GetExtension(System.String)"/>.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <param name="pathWithoutExtension">Receives path part without the extension. Can be the same variable as path.</param>
        </member>
        <member name="M:Au.APath.FindExtension(System.String)">
            <summary>
            Finds filename extension, like <c>".txt"</c>.
            Returns '.' character index, or -1 if there is no extension.
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <remarks>
            Returns -1 if <c>'.'</c> is before <c>'\\'</c> or <c>'/'</c>.
            </remarks>
        </member>
        <member name="M:Au.APath.GetDirectoryPath(System.String,System.Boolean)">
            <summary>
            Removes filename part from path. By default also removes separator (<c>'\\'</c> or <c>'/'</c>) if it is not after drive name (eg <c>"C:"</c>).
            Returns "" if the string is a filename.
            Returns null if the string is null or a root (like <c>@"C:\"</c> or <c>"C:"</c> or <c>@"\\server\share"</c> or <c>"http:"</c>).
            </summary>
            <param name="path">Path or filename. Can be null.</param>
            <param name="withSeparator">Don't remove separator character(s) (<c>'\\'</c> or <c>'/'</c>). See examples.</param>
            <remarks>
            Similar to <see cref="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})"/>. Some differences: does not throw exceptions; skips <c>'\\'</c> or <c>'/'</c> at the end (eg from <c>@"C:\A\B\"</c> gets <c>@"C:\A"</c>, not <c>@"C:\A\B"</c>); does not expand DOS path; much faster.
            
            Parses raw string. You may want to <see cref="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)"/> it at first.
            
            Supports separators <c>'\\'</c> and <c>'/'</c>.
            Also supports URL and shell parsing names like <c>@"::{CLSID-1}\0\::{CLSID-2}"</c>.
            
            Examples:
            
            | path | result
            | - | -
            | <c>@"C:\A\B\file.txt"</c> | <c>@"C:\A\B"</c>
            | <c>"file.txt"</c> | <c>""</c>
            | <c>@"C:\A\B\"</c> | <c>@"C:\A"</c>
            | <c>@"C:\A\/B\/"</c> | <c>@"C:\A"</c>
            | <c>@"C:\"</c> | <c>null</c>
            | <c>@"\\network\share"</c> | <c>null</c>
            | <c>"http:"</c> | <c>null</c>
            | <c>@"C:\aa\file.txt:alt.stream"</c> | <c>"C:\aa"</c>
            | <c>"http://a.b.c"</c> | <c>"http:"</c>
            | <c>"::{A}\::{B}"</c> | <c>"::{A}"</c>
            | <c>""</c> | <c>""</c>
            | <c>null</c> | <c>null</c>
            
            Examples when <i>withSeparator</i> true:
            
            | path | result
            | - | -
            | <c>@"C:\A\B"</c> | <c>@"C:\A\"</c> (not <c>@"C:\A"</c>)
            | <c>"http://x.y"</c> | <c>"http://"</c> (not <c>"http:"</c>)
            </remarks>
        </member>
        <member name="M:Au.APath.LibIsExtension(System.String)">
            <summary>
            Returns true if s is like <c>".ext"</c> and the ext part does not contain characters <c>.\\/:</c>.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.APath.LibIsProtocol(System.String)">
            <summary>
            Returns true if s is like "protocol:" and not like "c:" or "protocol:more".
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="M:Au.APath.MakeUnique(System.String,System.Boolean)">
            <summary>
            Gets path with unique filename for a new file or directory. 
            If the specified path is of an existing file or directory, returns path where the filename part is modified like "file 2.txt", "file 3.txt" etc. Else returns unchanged path.
            </summary>
            <param name="path">Suggested full path.</param>
            <param name="isDirectory">The path is for a directory. The number is always appended at the very end, not before .extension.</param>
        </member>
        <member name="T:Au.APidl">
            <summary>
            Manages an ITEMIDLIST structure that is used to identify files and other shell objects instead of a file-system path.
            </summary>
            <remarks>
            Wraps an ITEMIDLIST*, also known as PIDL or LPITEMIDLIST. In C# it is IntPtr.
            When calling native shell API, virtual objects can be identified only by ITEMIDLIST*. Some API also support "parsing name", which may look like <c>"::{CLSID-1}\::{CLSID-2}"</c>. File-system objects can be identified by path as well as by ITEMIDLIST*. URLs can be identified by URL as well as by ITEMIDLIST*.
            
            The ITEMIDLIST structure is in unmanaged memory. You can dispose APidl variables, or GC will do it later.
            
            This class has only ITEMIDLIST functions that are used in this library. Look for other functions in the MSDN library. Many of them are named with IL prefix, like ILClone, ILGetSize, ILFindLastID.
            </remarks>
        </member>
        <member name="P:Au.APidl.UnsafePtr">
            <summary>
            Gets the ITEMIDLIST* (PIDL).
            </summary>
            <remarks>
            The ITEMIDLIST memory is managed by this variable and will be freed when disposing or GC-collecting it. Use <see cref="M:System.GC.KeepAlive(System.Object)"/> where need.
            </remarks>
        </member>
        <member name="P:Au.APidl.HandleRef">
            <summary>
            Gets the ITEMIDLIST* (PIDL).
            </summary>
            <remarks>
            Use to pass to API where the parameter type is HandlePtr. It is safer than <see cref="P:Au.APidl.UnsafePtr"/> because ensures that this variable will not be GC-collected during API call even if not referenced after the call.
            </remarks>
        </member>
        <member name="P:Au.APidl.IsNull">
            <summary>
            Returns true if the PIDL is default(IntPtr).
            </summary>
        </member>
        <member name="M:Au.APidl.#ctor(System.IntPtr)">
            <summary>
            Assigns an ITEMIDLIST to this variable.
            </summary>
            <param name="pidl">
            ITEMIDLIST* (PIDL).
            It can be created by any API that creates ITEMIDLIST. They allocate the memory with API CoTaskMemAlloc. This variable will finally free it with Marshal.FreeCoTaskMem which calls API CoTaskMemFree.
            </param>
        </member>
        <member name="M:Au.APidl.#ctor(System.IntPtr,System.IntPtr)">
            <summary>
            Combines two ITEMIDLIST (parent and child) and assigns the result to this variable.
            </summary>
            <param name="pidlAbsolute">Absolute PIDL (parent folder).</param>
            <param name="pidlRelative">Relative PIDL (child object).</param>
            <remarks>
            Does not free <i>pidlAbsolute</i> and <i>pidlRelative</i>.
            </remarks>
        </member>
        <member name="M:Au.APidl.Dispose">
            <summary>
            Frees the ITEMIDLIST with Marshal.FreeCoTaskMem and clears this variable.
            </summary>
        </member>
        <member name="M:Au.APidl.Finalize">
            
        </member>
        <member name="M:Au.APidl.Detach">
            <summary>
            Gets the ITEMIDLIST and clears this variable so that it cannot be used and will not free the ITEMIDLIST memory. To free it use Marshal.FreeCoTaskMem.
            </summary>
        </member>
        <member name="M:Au.APidl.FromString(System.String,System.Boolean)">
            <summary>
            Converts string to ITEMIDLIST and creates new APidl variable that holds it.
            Returns null if failed.
            </summary>
            <param name="s">A file-system path or URL or shell object parsing name (see <see cref="M:Au.APidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)"/>) or ":: ITEMIDLIST" (see <see cref="M:Au.APidl.ToBase64String"/>). Supports environment variables (see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>).</param>
            <param name="throwIfFailed">Throw exception if failed.</param>
            <exception cref="T:Au.Types.AuException">Failed, and throwIfFailed is true. Probably invalid s.</exception>
            <remarks>
            Calls <msdn>SHParseDisplayName</msdn>, except when string is ":: ITEMIDLIST".
            When ":: ITEMIDLIST", does not check whether the shell object exists.
            Note: APidl is disposable.
            </remarks>
        </member>
        <member name="M:Au.APidl.LibFromString(System.String,System.Boolean)">
            <summary>
            The same as <see cref="M:Au.APidl.FromString(System.String,System.Boolean)"/>, but returns unmanaged ITEMIDLIST*.
            Later need to free it with Marshal.FreeCoTaskMem.
            </summary>
            <param name="s"></param>
            <param name="throwIfFailed"></param>
        </member>
        <member name="M:Au.APidl._Normalize(System.String)">
            <summary>
            The same as <see cref="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)"/>(CanBeUrlOrShell|DoNotPrefixLongPath), but ignores non-full path (returns s).
            </summary>
            <param name="s">File-system path or URL or "::...".</param>
        </member>
        <member name="M:Au.APidl.ToShellString(Au.Types.Native.SIGDN,System.Boolean)">
            <summary>
            Converts the ITEMIDLIST to file path or URL or shell object parsing name or display name, depending on stringType argument.
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            If failed, returns null or throws exception.
            </summary>
            <param name="stringType">
            String format. API <msdn>SIGDN</msdn>.
            Often used:
            - Native.SIGDN.NORMALDISPLAY - returns object name without path. It is best to display in UI but cannot be parsed to create ITEMIDLIST again.
            - Native.SIGDN.FILESYSPATH - returns path if the ITEMIDLIST identifies a file system object (file or directory). Else returns null.
            - Native.SIGDN.URL - if URL, returns URL. If file system object, returns its path like "file:///C:/a/b.txt". Else returns null.
            - Native.SIGDN.DESKTOPABSOLUTEPARSING - returns path (if file system object) or URL (if URL) or shell object parsing name (if virtual object eg Control Panel). Note: not all returned parsing names can actually be parsed to create ITEMIDLIST again, therefore usually it's better to use <see cref="M:Au.APidl.ToString"/> instead.
            </param>
            <param name="throwIfFailed">If failed, throw AuException.</param>
            <exception cref="T:Au.Types.AuException">Failed, and throwIfFailed is true.</exception>
            <remarks>
            Calls <msdn>SHGetNameFromIDList</msdn>.
            </remarks>
        </member>
        <member name="M:Au.APidl.ToShellString(System.IntPtr,Au.Types.Native.SIGDN,System.Boolean)">
            <summary>
            This overload uses an ITEMIDLIST* that is not stored in an APidl variable.
            </summary>
        </member>
        <member name="M:Au.APidl.ToString">
            <summary>
            Converts the ITEMIDLIST to string.
            If it identifies an existing file-system object (file or directory), returns path. If URL, returns URL. Else returns ":: ITEMIDLIST" (see <see cref="M:Au.APidl.ToBase64String"/>).
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            </summary>
        </member>
        <member name="M:Au.APidl.ToString(System.IntPtr)">
            <summary>
            This overload uses an ITEMIDLIST* that is not stored in an APidl variable.
            </summary>
        </member>
        <member name="M:Au.APidl.ToBase64String">
            <summary>
            Returns string ":: ITEMIDLIST".
            Returns null if this variable does not have an ITEMIDLIST (eg disposed or detached).
            </summary>
            <remarks>
            The string can be used with some functions of this library, mostly of classes <b>AExec</b>, <b>APidl</b> and <b>AIcon</b>. Cannot be used with native and .NET functions.
            </remarks>
        </member>
        <member name="M:Au.APidl.ToBase64String(System.IntPtr)">
            <summary>
            This overload uses an ITEMIDLIST* that is not stored in an APidl variable.
            </summary>
        </member>
        <member name="T:Au.AProcess">
            <summary>
            Process functions. Extends <see cref="T:System.Diagnostics.Process"/>.
            </summary>
        </member>
        <member name="M:Au.AProcess.GetName(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets process executable file name (like "notepad.exe") or full path.
            Returns null if fails.
            </summary>
            <param name="processId">Process id.</param>
            <param name="fullPath">
            Get full path.
            Note: Fails to get full path if the process belongs to another user session, unless current process is running as administrator; also fails to get full path of some system processes.
            </param>
            <param name="noSlowAPI">When the fast API QueryFullProcessImageName fails, don't try to use another much slower API WTSEnumerateProcesses. Not used if <i>fullPath</i> is true.</param>
            <remarks>
            This function is much slower than getting window name or class name.
            </remarks>
            <seealso cref="P:Au.AWnd.ProgramName"/>
            <seealso cref="P:Au.AWnd.ProgramPath"/>
            <seealso cref="P:Au.AWnd.ProcessId"/>
        </member>
        <member name="M:Au.AProcess.LibGetNameCached(Au.AWnd,System.Int32,System.Boolean)">
            <summary>
            Same as GetName, but faster when called several times for same window, like <c>if(w.ProgramName=="A" || w.ProgramName=="B")</c>.
            </summary>
        </member>
        <member name="M:Au.AProcess.LibProcessInfo.GetName(System.Boolean)">
            <summary>
            Gets process executable file name (like "notepad.exe"). Not full path.
            If contains looks like a DOS path and !cannotOpen, tries to unexpand DOS path.
            Don't call multiple times, because always converts from raw char*.
            </summary>
        </member>
        <member name="M:Au.AProcess.AllProcesses(System.Boolean)">
            <summary>
            Gets basic info of all processes: name, id, session id.
            </summary>
            <param name="ofThisSession">Get processes only of this user session (skip services etc).</param>
            <exception cref="T:Au.Types.AuException">Failed. Unlikely.</exception>
        </member>
        <member name="M:Au.AProcess.GetProcessIds(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets process ids of all processes of the specified program.
            Returns array containing 0 or more elements.
            </summary>
            <param name="processName">
            Process executable file name, like "notepad.exe".
            String format: [](xref:wildcard_expression).
            </param>
            <param name="fullPath">
            <i>processName</i> is full path.
            Note: Fails to get full path if the process belongs to another user session, unless current process is running as administrator; also fails to get full path of some system processes.
            </param>
            <param name="ofThisSession">Get processes only of this user session.</param>
            <exception cref="T:System.ArgumentException">
            - <i>processName</i> is "" or null.
            - Invalid wildcard expression (<c>"**options "</c> or regular expression).
            </exception>
        </member>
        <member name="M:Au.AProcess.GetProcessId(System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets process id of the first found process of the specified program.
            Returns 0 if not found.
            More info: <see cref="M:Au.AProcess.GetProcessIds(System.String,System.Boolean,System.Boolean)"/>.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="P:Au.AProcess.ProcessId">
            <summary>
            Gets current process id.
            See API <msdn>GetCurrentProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.AProcess.ProcessHandle">
            <summary>
            Returns current process handle.
            See API <msdn>GetCurrentProcess</msdn>.
            Don't need to close the handle.
            </summary>
        </member>
        <member name="P:Au.AProcess.ExeModuleHandle">
            <summary>
            Gets native module handle of the program file of this process.
            </summary>
        </member>
        <member name="M:Au.AProcess.ProcessIdFromHandle(System.IntPtr)">
            <summary>
            Gets process id from handle.
            Returns 0 if failed. Supports <see cref="T:Au.ALastError"/>.
            Calls API <msdn>GetProcessId</msdn>.
            </summary>
            <param name="processHandle">Process handle.</param>
        </member>
        <member name="M:Au.AProcess.GetSessionId(System.Int32)">
            <summary>
            Gets user session id of a process.
            Returns -1 if failed. Supports <see cref="T:Au.ALastError"/>.
            Calls API <msdn>ProcessIdToSessionId</msdn>.
            </summary>
            <param name="processId">Process id.</param>
        </member>
        <member name="P:Au.AProcess.ProcessSessionId">
            <summary>
            Gets user session id of this process.
            Calls API <msdn>ProcessIdToSessionId</msdn> and <msdn>GetCurrentProcessId</msdn>.
            </summary>
        </member>
        <member name="M:Au.AProcess.GetVersionInfo(System.Int32)">
            <summary>
            Gets version info of process executable file.
            Return null if fails.
            </summary>
            <param name="processId">Process id.</param>
        </member>
        <member name="M:Au.AProcess.GetDescription(System.Int32)">
            <summary>
            Gets description of process executable file.
            Return null if fails.
            </summary>
            <param name="processId">Process id.</param>
            <remarks>
            Calls <see cref="M:Au.AProcess.GetVersionInfo(System.Int32)"/> and <see cref="P:System.Diagnostics.FileVersionInfo.FileDescription"/>.
            </remarks>
        </member>
        <member name="E:Au.AProcess.Exit">
            <summary>
            Before this process exits, either normally or on unhandled exception.
            </summary>
            <remarks>
            The event handler is called when one of these events occur, with their parameters: <see cref="E:System.AppDomain.ProcessExit"/>, <see cref="E:System.AppDomain.UnhandledException"/>.
            The event handler is called before static object finalizers.
            </remarks>
        </member>
        <member name="T:Au.AProcessMemory">
            <summary>
            Allocates, writes and reads memory in other process.
            </summary>
            <remarks>
            Objects of this class must be disposed. Example: <c>using(var pm=new AProcessMemory(...)) { ... }</c>.
            </remarks>
        </member>
        <member name="M:Au.AProcessMemory.Finalize">
            
        </member>
        <member name="M:Au.AProcessMemory.Dispose">
            
        </member>
        <member name="P:Au.AProcessMemory.ProcessHandle">
            <summary>
            Process handle.
            Opened with access PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE.
            </summary>
        </member>
        <member name="P:Au.AProcessMemory.Mem">
            <summary>
            Address of memory allocated in that process.
            </summary>
            <remarks>
            The address is invalid in this process.
            </remarks>
        </member>
        <member name="M:Au.AProcessMemory.SetMem(System.IntPtr,System.Boolean)">
            <summary>
            Sets an address of memory in that process that is to be used by the read and write functions.
            </summary>
            <param name="mem">A memory address in that process.</param>
            <param name="freeWhenDisposing">
            Let the Dispose method (or finalizer) call API <msdn>VirtualFreeEx</msdn> to free mem. The memory must be allocated with API <msdn>VirtualAllocEx</msdn> (by any process) or <msdn>VirtualAlloc</msdn> (by that process).
            If false, mem can be any memory in that process, and this variable will not free it. Alternatively you can use <see cref="M:Au.AProcessMemory.ReadOther(System.IntPtr,System.Void*,System.Int32)"/> and <see cref="M:Au.AProcessMemory.WriteOther(System.IntPtr,System.Void*,System.Int32)"/>.</param>
            <exception cref="T:System.InvalidOperationException">This variable already has Mem, unless it was set by this function with <i>freeWhenDisposing</i> = false.</exception>
            <remarks>
            This function can be used if this variable was created with <i>nBytes</i> = 0. Else exception. Also exception if this function previously called with <i>freeWhenDisposing</i> = true.
            </remarks>
        </member>
        <member name="M:Au.AProcessMemory.#ctor(Au.AWnd,System.Int32)">
            <summary>
            Opens window's process handle and optionally allocates memory in that process.
            </summary>
            <param name="w">A window in that process.</param>
            <param name="nBytes">If not 0, allocates this number of bytes of memory in that process.</param>
            <remarks>This is the preferred constructor when the process has windows. It works with windows of [](xref:uac) High integrity level when this process is Medium+uiAccess.</remarks>
            <exception cref="T:Au.Types.AuWndException">w invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed to open process handle (usually because of UAC) or allocate memory.</exception>
        </member>
        <member name="M:Au.AProcessMemory.#ctor(System.Int32,System.Int32)">
            <summary>
            Opens window's process handle and optionally allocates memory in that process.
            </summary>
            <param name="processId">Process id.</param>
            <param name="nBytes">If not 0, allocates this number of bytes of memory in that process.</param>
            <exception cref="T:Au.Types.AuException">Failed to open process handle (usually because of [](xref:uac)) or allocate memory.</exception>
        </member>
        <member name="M:Au.AProcessMemory.WriteUnicodeString(System.String,System.Int32)">
            <summary>
            Copies a string from this process to the memory allocated in that process by the constructor.
            In that process the string is written as '\0'-terminated UTF-16 string. For it is used (s.Length+1)*2 bytes of memory in that process (+1 for the '\0', *2 because UTF-16 character size is 2 bytes).
            Returns false if fails.
            </summary>
            <param name="s">A string in this process.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.AProcessMemory.WriteAnsiString(System.String,System.Int32,System.Text.Encoding)">
            <summary>
            Copies a string from this process to the memory allocated in that process by the constructor.
            In that process the string is written as '\0'-terminated ANSI string, in default or specified encoding.
            Returns false if fails.
            </summary>
            <param name="s">A string in this process. Normal C# string (UTF-16), not ANSI.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="M:Au.AProcessMemory.ReadUnicodeString(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies a string from the memory in that process allocated by the constructor to this process.
            Returns the copied string, or null if fails.
            In that process the string must be in Unicode UTF-16 format (ie not ANSI).
            </summary>
            <param name="nChars">Number of characters to copy. In both processes a character is 2 bytes.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="findLength">Find true string length by searching for '\0' character in nChars range. If false, the returned string is of nChars length even if contains '\0' characters.</param>
        </member>
        <member name="M:Au.AProcessMemory.ReadAnsiString(System.Int32,System.Int32,System.Boolean,System.Text.Encoding)">
            <summary>
            Copies a string from the memory in that process allocated by the constructor to this process.
            Returns the copies string, or null if fails.
            In that process the string must be in ANSI format (ie not Unicode UTF-16).
            </summary>
            <param name="nBytes">Number bytes to copy. In that process a character is 1 or more bytes (depending on encoding). In this process will be 2 bytes (normal C# string).</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
            <param name="findLength">Find true string length by searching for '\0' character in nBytes range of the ANSI string.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="M:Au.AProcessMemory.Write(System.Void*,System.Int32,System.Int32)">
            <summary>
            Copies a value-type variable or other memory from this process to the memory in that process allocated by the constructor.
            Returns false if fails.
            </summary>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.AProcessMemory.WriteOther(System.IntPtr,System.Void*,System.Int32)">
            <summary>
            Copies a value-type variable or other memory from this process to a known memory address in that process.
            Returns false if fails.
            </summary>
            <param name="ptrDestinationInThatProcess">Memory address in that process where to copy memory from this process.</param>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <seealso cref="M:Au.AProcessMemory.SetMem(System.IntPtr,System.Boolean)"/>
        </member>
        <member name="M:Au.AProcessMemory.Read(System.Void*,System.Int32,System.Int32)">
            <summary>
            Copies from the memory in that process allocated by the constructor to a value-type variable or other memory in this process.
            Returns false if fails.
            </summary>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <param name="offsetBytes">Offset in the memory allocated by the constructor.</param>
        </member>
        <member name="M:Au.AProcessMemory.ReadOther(System.IntPtr,System.Void*,System.Int32)">
            <summary>
            Copies from a known memory address in that process to a value-type variable or other memory in this process.
            Returns false if fails.
            </summary>
            <param name="ptrSourceInThatProcess">Memory address in that process from where to copy memory.</param>
            <param name="ptr">Unsafe address of a value type variable or other memory in this process.</param>
            <param name="nBytes">Number of bytes to copy.</param>
            <seealso cref="M:Au.AProcessMemory.SetMem(System.IntPtr,System.Boolean)"/>
        </member>
        <member name="T:Au.ARegistry">
            <summary>
            Registry functions. Extends <see cref="T:Microsoft.Win32.Registry"/>.
            </summary>
        </member>
        <member name="F:Au.ARegistry.AuKey">
            <summary>
            Default registry key, used when the key argument is null or <c>@"\"</c> or starts with <c>@"\"</c>.
            </summary>
        </member>
        <member name="P:Au.ARegistry.HKEY_CURRENT_USER">
            
        </member>
        <member name="P:Au.ARegistry.HKEY_CLASSES_ROOT">
            
        </member>
        <member name="P:Au.ARegistry.HKEY_LOCAL_MACHINE">
            
        </member>
        <member name="M:Au.ARegistry.ParseKeyString(System.String@)">
            <summary>
            Parses registry key string and returns hive as RegistryKey.
            If key starts with <c>"HKEY_"</c>, removes hive name from it and returns that hive. For example, if key is <c>@"HKEY_LOCAL_MACHINE\Software\Test"</c>, sets key=<c>@"Software\Test"</c> and returns HKEY_LOCAL_MACHINE.
            Else if key is null or <c>@"\"</c>, sets key=<c>ARegistry.AuKey (@"Software\Au")</c> and returns HKEY_CURRENT_USER.
            Else if key starts with <c>@"\"</c>, prepends <c>ARegistry.AuKey (@"Software\Au")</c> and returns HKEY_CURRENT_USER.
            Else just returns HKEY_CURRENT_USER.
            Valid hive names: <c>"HKEY_CURRENT_USER"</c>, <c>"HKEY_LOCAL_MACHINE"</c>, <c>"HKEY_CLASSES_ROOT"</c>, <c>"HKEY_USERS"</c>, <c>"HKEY_PERFORMANCE_DATA"</c> or <c>"HKEY_CURRENT_CONFIG"</c>.
            </summary>
            <param name="key">Registry key. Can start with a hive name.</param>
            <exception cref="T:System.ArgumentException"><i>key</i> starts with <c>"HKEY_"</c> but it is an invalid hive name.</exception>
        </member>
        <member name="M:Au.ARegistry.Open(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Opens a key for read access.
            Returns null if the key does not exist.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", the function just returns parentKeyOrHive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
        </member>
        <member name="M:Au.ARegistry.CreateOrOpen(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Creates a new key or opens an existing key for write access.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", the function just returns parentKeyOrHive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create or open the registry key.</exception>
            <exception cref="T:System.UnauthorizedAccessException">parentKeyOrHive was not opened with write access.</exception>
            <exception cref="T:System.IO.IOException">See <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.</exception>
        </member>
        <member name="M:Au.ARegistry.CanOpen(System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Returns true if key exists and you can open it to read.
            Uses <see cref="M:Microsoft.Win32.RegistryKey.OpenSubKey(System.String)"/>.
            </summary>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/>.</param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
        </member>
        <member name="M:Au.ARegistry.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets value of REG_DWORD type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to read the registry key.</exception>
            <exception cref="T:System.IO.IOException">The key has been marked for deletion.</exception>
            <exception cref="T:System.InvalidCastException">Wrong value type.</exception>
        </member>
        <member name="M:Au.ARegistry.GetLong(System.Int64@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets value of REG_QWORD type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.ARegistry.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.ARegistry.GetString(System.String@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets string value of REG_SZ or REG_EXPAND_SZ type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.ARegistry.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.ARegistry.GetStringArray(System.String[]@,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets string value of REG_MULTI_SZ type.
            Returns false if the value or key does not exist.
            </summary>
            <param name="data">Receives data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.ARegistry.GetInt(System.Int32@,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.ARegistry.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_DWORD type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.ArgumentException">'key' starts with "HKEY_" but it is an invalid hive name.</exception>
            <exception cref="T:System.ObjectDisposedException">'parentKeyOrHive' is a closed key handle.</exception>
            <exception cref="T:System.Security.SecurityException">The user does not have the permissions required to create, open or modify the registry key.</exception>
            <exception cref="T:System.UnauthorizedAccessException">parentKeyOrHive was not opened with write access.</exception>
            <exception cref="T:System.IO.IOException">See <see cref="M:Microsoft.Win32.RegistryKey.CreateSubKey(System.String)"/>.</exception>
        </member>
        <member name="M:Au.ARegistry.SetLong(System.Int64,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_QWORD type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.ARegistry.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.ARegistry.SetString(System.String,System.String,System.String,Microsoft.Win32.RegistryKey,System.Boolean)">
            <summary>
            Sets string value of REG_SZ or REG_EXPAND_SZ type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <param name="REG_EXPAND_SZ">Let the registry value type be REG_EXPAND_SZ.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.ARegistry.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.ARegistry.SetStringArray(System.String[],System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets string value of REG_MULTI_SZ type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions are listed in <see cref="M:Au.ARegistry.SetInt(System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)"/> topic.</exception>
        </member>
        <member name="M:Au.ARegistry.SetBinary(System.Void*,System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Sets value of REG_BINARY type.
            Creates key and value if don't exist.
            </summary>
            <param name="data">Data. For example a struct variable (unsafe address).</param>
            <param name="size">Data size. For example, Marshal.SizeOf(variable) or Marshal.SizeOf(typeof(DATA)).</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.ARegistry.CreateOrOpen(System.String,Microsoft.Win32.RegistryKey)"/>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed to write the value to the key.</exception>
        </member>
        <member name="M:Au.ARegistry.GetBinary(System.Void*,System.Int32,System.String,System.String,Microsoft.Win32.RegistryKey)">
            <summary>
            Gets binary data. The registry value type can be REG_BINARY or any other.
            Returns registry data size that the function copied into the 'data' memory.
            Returns 0 if the key or value does not exist.
            </summary>
            <param name="data">Receives data. For example a struct variable (unsafe address).</param>
            <param name="size">data memory size. For example, Marshal.SizeOf(variable). Must be &gt;= registry data size.</param>
            <param name="valueName">Registry value name.</param>
            <param name="key">Registry key. See <see cref="M:Au.ARegistry.ParseKeyString(System.String@)"/></param>
            <param name="parentKeyOrHive">If not null, the 'key' argument is a subkey of this key or hive; if the 'key' argument is null or "", parentKeyOrHive is the direct parent key of the value.</param>
            <exception cref="T:System.Exception">Exceptions thrown by <see cref="M:Au.ARegistry.Open(System.String,Microsoft.Win32.RegistryKey)"/>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">The value exists but failed to get it, for example the specified size is smaller than registry data size.</exception>
        </member>
        <member name="T:Au.AShortcutFile">
            <summary>
            Creates shell shortcuts (.lnk files) and gets shortcut properties.
            </summary>
        </member>
        <member name="M:Au.AShortcutFile.Dispose">
            <summary>
            Releases internally used COM objects (IShellLink, IPersistFile).
            </summary>
        </member>
        <member name="P:Au.AShortcutFile.IShellLink">
            <summary>
            Returns the internally used IShellLink COM interface.
            </summary>
        </member>
        <member name="M:Au.AShortcutFile.Open(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to get shortcut properties.
            Exception if shortcut file does not exist or cannot open it for read access.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open .lnk file.</exception>
        </member>
        <member name="M:Au.AShortcutFile.Create(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to create or replace a shortcut file.
            You can set properties and finally call <see cref="M:Au.AShortcutFile.Save"/>.
            If the shortcut file already exists, Save replaces it.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
        </member>
        <member name="M:Au.AShortcutFile.OpenOrCreate(System.String)">
            <summary>
            Creates a new instance of the Shortcut class that can be used to create or modify a shortcut file.
            Exception if file exists but cannot open it for read-write access.
            You can get and set properties and finally call <see cref="M:Au.AShortcutFile.Save"/>.
            If the shortcut file already exists, Save updates it.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open existing .lnk file.</exception>
        </member>
        <member name="M:Au.AShortcutFile.Save">
            <summary>
            Saves the Shortcut variable properties to the shortcut file.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to save .lnk file.</exception>
            <remarks>
            Creates parent folder if need.
            </remarks>
        </member>
        <member name="P:Au.AShortcutFile.TargetPath">
            <summary>
            Gets or sets shortcut target path.
            This property is null if target isn't a file system object, eg Control Panel or URL.
            </summary>
            <remarks>The 'get' function gets path with expanded environment variables. If possible, it corrects the target of MSI shortcuts and 64-bit Program Files shortcuts where IShellLink.GetPath() lies.</remarks>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.AShortcutFile.TargetPathRawMSI">
            <summary>
            Gets shortcut target path and does not correct wrong MSI shortcut target.
            </summary>
        </member>
        <member name="P:Au.AShortcutFile.TargetPidl">
            <summary>
            Gets or sets a non-file-system target (eg Control Panel) through its ITEMIDLIST.
            </summary>
            <remarks>
            Also can be used for any target type, but gets raw value, for example MSI shortcut target is incorrect.
            Most but not all shortcuts have this property; the 'get' function returns null if the shortcut does not have it.
            </remarks>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.AShortcutFile.TargetURL">
            <summary>
            Gets or sets a URL target.
            Note: it is a .lnk shortcut, not a .url shortcut.
            The 'get' function returns string "file:///..." if target is a file.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.AShortcutFile.TargetAnyType">
            <summary>
            Gets or sets target of any type - file/folder, URL, virtual shell object (see <see cref="T:Au.APidl"/>).
            The string can be used with <see cref="M:Au.AExec.Run(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="M:Au.AShortcutFile.GetIconLocation(System.Int32@)">
            <summary>
            Gets custom icon file path and icon index.
            Returns null if the shortcut does not have a custom icon (then you see its target icon).
            </summary>
            <param name="iconIndex">Receives 0 or icon index or negative icon resource id.</param>
        </member>
        <member name="M:Au.AShortcutFile.SetIconLocation(System.String,System.Int32)">
            <summary>
            Sets icon file path and icon index.
            </summary>
            <param name="path"></param>
            <param name="iconIndex">0 or icon index or negative icon resource id.</param>
            <exception cref="T:Au.Types.AuException"/>
        </member>
        <member name="P:Au.AShortcutFile.WorkingDirectory">
            <summary>
            Gets or sets the working directory path (Start in).
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.AShortcutFile.Arguments">
            <summary>
            Gets or sets the command-line arguments.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.AShortcutFile.Description">
            <summary>
            Gets or sets the description text (Comment).
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.AShortcutFile.Hotkey">
            <summary>
            Gets or sets hotkey.
            Example: <c>x.Hotkey = Keys.Control | Keys.Alt | Keys.E;</c>
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="P:Au.AShortcutFile.ShowState">
            <summary>
            Gets or sets the window show state.
            The value can be 1 (normal, default), 2 (minimized) or 3 (maximized).
            Most programs ignore it.
            </summary>
            <exception cref="T:Au.Types.AuException">The 'set' function failed.</exception>
        </member>
        <member name="M:Au.AShortcutFile.GetTarget(System.String)">
            <summary>
            Gets shortcut target path or URL or virtual shell object ITEMIDLIST.
            Uses <see cref="M:Au.AShortcutFile.Open(System.String)"/> and <see cref="P:Au.AShortcutFile.TargetAnyType"/>.
            </summary>
            <param name="lnkPath">Shortcut file (.lnk) path.</param>
            <exception cref="T:Au.Types.AuException">Failed to open.</exception>
        </member>
        <member name="M:Au.AShortcutFile.Delete(System.String)">
            <summary>
            If shortcut file exists, unregisters its hotkey and deletes it.
            </summary>
            <param name="lnkPath">.lnk file path.</param>
            <exception cref="T:Au.Types.AuException">Failed to unregister hotkey.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AFile.Delete(System.String,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AShortcutFile._UnregisterHotkey(System.String)">
            <exception cref="T:Au.Types.AuException">Failed to open or save.</exception>
        </member>
        <member name="T:Au.ASqlite">
            <summary>
            A SQLite database connection.
            Creates/opens/closes database file or in-memory database. Executes SQL, etc.
            </summary>
            <remarks>
            This class wraps a SQLite API object sqlite3* and related sqlite3_x functions. They are documented perfectly in the SQLite website.
            Uses this unmanaged dll: AFolders.ThisApp + @"64\sqlite3.dll". In 32-bit process - "32" instead of "64".
            
            To correctly close the database file, at first need to dipose all child objects, such as <see cref="T:Au.ASqliteStatement"/>, then dispose the <b>ASqlite</b> object. To dispose a static <b>ASlite</b> variable, you may want to use <see cref="E:Au.AProcess.Exit"/> event. Although this class has a finalizer that disposes the object (closes database), you should always dispose explicitly. Finalizers don't run on process exit.
            </remarks>
            <seealso cref="T:Au.ASqliteStatement"/>
            <example>
            <code><![CDATA[
            //open database file
            using var db = new ASqlite(@"Q:\test\sqlite.db");
            //create table
            db.Execute("CREATE TABLE IF NOT EXISTS test(id INTEGER PRIMARY KEY, name TEXT, x INT, guid BLOB, array BLOB)");
            
            //add 2 rows of data
            using(var trans = db.Transaction()) { //optional, but makes much faster when making multiple changes, and ensures that all or none of these changes are written to the database
            	using(var p = db.Statement("INSERT OR REPLACE INTO test VALUES(?, ?, :x, ?, ?)")) {
            		//assume we want to add values of these variables to the database table
            		int id = 1; string name = "TEXT"; long x = -10; Guid guid = Guid.NewGuid(); int[] arr = new int[] { 1, 2, 3 };
            		//add first row
            		p.Bind(1, id);
            		p.Bind(2, name).BindStruct(4, guid).Bind(5, arr);
            		p.Bind(":x", x);
            		p.Step();
            		//add second row
            		p.Reset().Bind(1, 2).Bind(":x", 123456789012345).Step(); //unbound columns are null
            	}
            	//update single row
            	db.Execute("UPDATE test SET name=?2 WHERE id=?1", 2, "two");
            	//write all this to database
            	trans.Commit();
            }
            
            //get data
            using(var p = db.Statement("SELECT * FROM test")) {
            	while(p.Step()) { //for each row of results
            		Print(p.GetInt(0), p.GetText(1), p.GetLong(2));
            		Print(p.GetStruct<Guid>("guid"));
            		Print(p.GetArray<int>("array"));
            		Print("----");
            	}
            }
            //get single value
            if(db.Get(out string s1, "SELECT name FROM test WHERE id=?", 1)) Print(s1); else Print("not found");
            if(db.Get(out int i1, "PRAGMA page_size")) Print(i1);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ASqlite.#ctor(System.String,Au.Types.SLFlags,System.String)">
            <summary>
            Opens or creates a database file.
            </summary>
            <param name="file">
            Database file.
            Special strings:
            ":memory:" - create a private, temporary in-memory database.
            "" - create a private, temporary on-disk database.
            Starts with "file:" - see sqlite3_open_v2 documentation in SQLite website.
            If not one of above special strings, must be full path, and can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>
            </param>
            <param name="flags">sqlite3_open_v2 flags, documanted in SQLite website. Default: read-write, create file if does not exist (and parent directory).</param>
            <param name="sql">
            SQL to execute. For example, one or more ;-separated PRAGMA statements to configure the database connection. Or even "CREATE TABLE IF NOT EXISTS ...".
            This function also always executes "PRAGMA foreign_keys=ON;PRAGMA secure_delete=ON;".
            </param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:Au.Types.SLException">Failed to open database or execute sql.</exception>
            <remarks>
            Calls sqlite3_open_v2.
            <note>If a variable of this class is used by multiple threads, use <c>lock(variable) {  }</c> where need.</note>
            </remarks>
        </member>
        <member name="M:Au.ASqlite.Dispose">
            <summary>
            Calls sqlite3_close_v2.
            If fails, prints warning.
            </summary>
        </member>
        <member name="M:Au.ASqlite.Finalize">
            
        </member>
        <member name="M:Au.ASqlite.op_Implicit(Au.ASqlite)~System.IntPtr">
            <summary>sqlite3*</summary>
        </member>
        <member name="P:Au.ASqlite.Handle">
            <summary>sqlite3*</summary>
        </member>
        <member name="M:Au.ASqlite.Execute(System.String)">
            <summary>
            Calls sqlite3_exec to execute one or more SQL statements that don't return data.
            </summary>
            <param name="sql">SQL statement, or several ;-separated statements.</param>
            <exception cref="T:Au.Types.SLException">Failed to execute sql.</exception>
        </member>
        <member name="M:Au.ASqlite.Execute(System.String,System.Object[])">
            <summary>
            Executes single SQL statement that does not return data. Binds values.
            </summary>
            <param name="sql">Single SQL statement.</param>
            <param name="bind">
            Values that will replace ? characters in sql.
            Read about SQL parameters in SQLite website. Supported types: <see cref="M:Au.ASqliteStatement.BindAll(System.Object[])"/>. Example: <see cref="T:Au.ASqlite"/>.
            </param>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqlite.Statement(System.String)">
            <summary>
            Returns <c>new Statement(this, sql)</c>.
            </summary>
            <param name="sql">Single SQL statement. This function does not execute it.</param>
            <seealso cref="T:Au.ASqliteStatement"/>
        </member>
        <member name="M:Au.ASqlite.Statement(System.String,System.Object[])">
            <summary>
            Returns <c>new Statement(this, sql).BindAll(bind)</c>.
            </summary>
            <param name="sql">Single SQL statement. This function does not execute it.</param>
            <param name="bind">
            Values that will replace ? characters in sql. Optional.
            Read about SQL parameters in SQLite website. Supported types: <see cref="M:Au.ASqliteStatement.BindAll(System.Object[])"/>. Example: <see cref="T:Au.ASqlite"/>.
            </param>
            <seealso cref="T:Au.ASqliteStatement"/>
            <seealso cref="M:Au.ASqliteStatement.BindAll(System.Object[])"/>
        </member>
        <member name="M:Au.ASqlite.Get(System.Int32@,System.String,System.Object[])">
            <summary>
            Executes single SQL statement and gets single value.
            Returns false if the statement returned no data.
            </summary>
            <param name="value">Receives data.</param>
            <param name="sql">SQL statement.</param>
            <param name="bind">
            Values that will replace ? characters in sql.
            Read about SQL parameters in SQLite website. Supported types: <see cref="M:Au.ASqliteStatement.BindAll(System.Object[])"/>. Example: <see cref="T:Au.ASqlite"/>.
            </param>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
            <remarks>
            The Get(out int, ...) overload also can be used to get uint, short, ushort, byte, sbyte, enum. Will need to cast from int.
            The Get(out long, ...) overload also can be used to get ulong, 64-bit enum, maybe DateTime.
            The Get(out double, ...) overload also can be used to get float.
            Use <see cref="M:Au.ASqlite.GetStruct``1(``0@,System.String,System.Object[])"/> for other value types - decimal, Guid, Rect, etc.
            </remarks>
        </member>
        <member name="M:Au.ASqlite.Get(System.Int64@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqlite.Get(System.Boolean@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqlite.Get(System.Double@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqlite.Get(System.String@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqlite.Get``1(``0[]@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqlite.Get``1(System.Collections.Generic.List{``0}@,System.String,System.Object[])">
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqlite.GetStruct``1(``0@,System.String,System.Object[])">
            <summary>See <see cref="M:Au.ASqlite.Get(System.Int32@,System.String,System.Object[])"/>.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqlite.Any(System.String,System.Object[])">
            <summary>
            Executes single SQL statement and returns true if it returns at least one row of data.
            More info: <see cref="M:Au.ASqlite.Get(System.Int32@,System.String,System.Object[])"/>.
            </summary>
            <remarks>This function is similar to the <b>GetX</b> functions, but it does not retrieve the data.</remarks>
        </member>
        <member name="P:Au.ASqlite.LastInsertRowid">
            <summary>
            sqlite3_last_insert_rowid.
            </summary>
        </member>
        <member name="P:Au.ASqlite.Changes">
            <summary>
            sqlite3_changes.
            </summary>
        </member>
        <member name="P:Au.ASqlite.IsInTransaction">
            <summary>
            0 == sqlite3_get_autocommit.
            </summary>
        </member>
        <member name="M:Au.ASqlite.Transaction(System.String,System.String)">
            <summary>
            Returns <c>new SLTransaction(this, sql, sqlOfDispose)</c>.
            See <see cref="M:Au.Types.SLTransaction.#ctor(Au.ASqlite,System.String,System.String)"/>.
            </summary>
            <param name="sql">SQL to execute now. Default "BEGIN".</param>
            <param name="sqlOfDispose">SQL to execute when disposing the <b>SLTransaction</b> variable. Default "ROLLBACK".</param>
        </member>
        <member name="M:Au.ASqlite.TableExists(System.String)">
            <summary>
            Returns true if the table exists.
            </summary>
            <param name="table">Table name.</param>
        </member>
        <member name="P:Au.ASqlite.IsUtf16">
            <summary>
            Returns true if default database text encoding is not UTF-8.
            </summary>
        </member>
        <member name="T:Au.ASqliteStatement">
            <summary>
            Creates and executes a SQLite prepared statement.
            </summary>
            <threadsafety static="true" instance="false"/>
            <remarks>
            This class wraps a SQLite API object sqlite3_stmt* and related sqlite3_x functions. They are documented perfectly in the SQLite website.
            More info and example: <see cref="T:Au.ASqlite"/>.
            <note type="important">A variable of this class can be used by multiple threads, but not simultaneously. Use <c>lock(database) {  }</c> where need.</note>
            </remarks>
        </member>
        <member name="M:Au.ASqliteStatement.#ctor(Au.ASqlite,System.String,System.Boolean)">
            <summary>
            Calls sqlite3_prepare16_v3.
            </summary>
            <param name="db"></param>
            <param name="sql">Single SQL statement.</param>
            <param name="persistent">Use flag SQLITE_PREPARE_PERSISTENT.</param>
            <exception cref="T:System.ArgumentNullException">db is null.</exception>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <exception cref="T:System.NotSupportedException">sql contains more than single SQL statement.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Dispose">
            <summary>
            Calls sqlite3_finalize.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.Finalize">
            
        </member>
        <member name="M:Au.ASqliteStatement.op_Implicit(Au.ASqliteStatement)~System.IntPtr">
            <summary>sqlite3_stmt*</summary>
        </member>
        <member name="P:Au.ASqliteStatement.Handle">
            <summary>sqlite3_stmt*</summary>
        </member>
        <member name="P:Au.ASqliteStatement.DB">
            
        </member>
        <member name="M:Au.ASqliteStatement.Step">
            <summary>
            Calls sqlite3_step.
            Returns true if results data available (sqlite3_step returned SQLITE_ROW).
            </summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Reset(System.Boolean,System.Boolean)">
            <summary>
            Calls sqlite3_reset and/or sqlite3_clear_bindings. Returns self.
            </summary>
            <param name="resetStatement">Call sqlite3_reset. Default true.</param>
            <param name="clearBindings">Call sqlite3_clear_bindings. Default true.</param>
        </member>
        <member name="M:Au.ASqliteStatement.Bind(Au.Types.SLIndexOrName,System.Int32)">
            <summary>Calls sqlite3_bind_int. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind(Au.Types.SLIndexOrName,System.UInt32)">
            <summary>Calls sqlite3_bind_int. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind(Au.Types.SLIndexOrName,System.Int64)">
            <summary>Calls sqlite3_bind_int64. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind(Au.Types.SLIndexOrName,System.UInt64)">
            <summary>Calls sqlite3_bind_int64. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind(Au.Types.SLIndexOrName,System.Boolean)">
            <summary>Calls sqlite3_bind_int(value ? 1 : 0). Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind``1(Au.Types.SLIndexOrName,``0)">
            <summary>Binds an enum value as int or long. Calls sqlite3_bind_int or sqlite3_bind_int64. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind(Au.Types.SLIndexOrName,System.Double)">
            <summary>Calls sqlite3_bind_double. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind(Au.Types.SLIndexOrName,System.String)">
            <summary>Calls sqlite3_bind_text16. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind(Au.Types.SLIndexOrName,System.Void*,System.Int64)">
            <summary>Calls sqlite3_bind_blob64. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind``1(Au.Types.SLIndexOrName,``0[])">
            <summary>Calls sqlite3_bind_blob64. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.Bind``1(Au.Types.SLIndexOrName,System.Collections.Generic.List{``0})">
            <summary>Calls sqlite3_bind_blob64. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
        </member>
        <member name="M:Au.ASqliteStatement.BindStruct``1(Au.Types.SLIndexOrName,``0)">
            <summary>Binds a value as blob. Calls sqlite3_bind_blob64. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <remarks>Can be any value type that does not contain fields of reference types. Examples: Guid, Point, int, decimal.</remarks>
        </member>
        <member name="M:Au.ASqliteStatement.BindNull(Au.Types.SLIndexOrName)">
            <summary>Calls sqlite3_bind_null. Returns self.</summary>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <remarks>Usually don't need to call this function. Unset parameter values are null. The Bind(string/void*/Array/List) functions set null too if the value is null.</remarks>
        </member>
        <member name="M:Au.ASqliteStatement.BindObject(System.Int32,System.Object)">
            <summary>
            Used by <see cref="M:Au.ASqliteStatement.BindAll(System.Object[])"/>.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.BindAll(System.Object[])">
            <summary>
            Binds multiple values of any supported types.
            Returns self.
            </summary>
            <param name="values">
            Values that will replace ? characters in sql.
            Read about SQL parameters in SQLite website. Example: <see cref="T:Au.ASqlite"/>.
            Supported types:
            int, uint, byte, sbyte, short, ushort - calls sqlite3_bind_int.
            bool - calls sqlite3_bind_int(true?1:0).
            long, ulong - calls sqlite3_bind_int64.
            double, float - calls sqlite3_bind_double.
            string - calls sqlite3_bind_text16.
            decimal - calls sqlite3_bind_blob64.
            Guid - calls sqlite3_bind_blob64.
            An enum type - calls sqlite3_bind_int or sqlite3_bind_int64.
            </param>
            <exception cref="T:System.NotSupportedException">A value is of an unsupported type.</exception>
            <exception cref="T:Au.Types.SLException">Failed.</exception>
            <remarks>
            For each parameter calls a <b>sqlite3_bind_x</b> function depending on type. Uses index 1, 2 and so on.
            This function is an alternative to calling <b>BindX</b> functions for each parameter. However it supports less types and adds boxing overhead.
            Does not call sqlite3_reset and sqlite3_clear_bindings. If need, call <see cref="M:Au.ASqliteStatement.Reset(System.Boolean,System.Boolean)"/> before.
            </remarks>
        </member>
        <member name="M:Au.ASqliteStatement.GetInt(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_int(column)</c>.
            </summary>
            <remarks>
            Use this function to get integer values of size 4, 2 or 1 bytes: int, uint, short, ushort, byte, sbyte, enum.
            </remarks>
        </member>
        <member name="M:Au.ASqliteStatement.GetLong(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_int64(column)</c>.
            </summary>
            <remarks>
            Use this function to get integer values of size 8 bytes: long, ulong, 64-bit enum, maybe DateTime.
            </remarks>
        </member>
        <member name="M:Au.ASqliteStatement.GetBool(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_int64(column) != 0</c>.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.GetDouble(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_double(column)</c>.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.GetText(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_text(column)</c> as string.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.GetBlob(Au.Types.SLIndexOrName,System.Int32@)">
            <summary>
            Returns <c>sqlite3_column_blob(column)</c> and gets blob size.
            </summary>
            <param name="column"></param>
            <param name="nBytes">Blob size.</param>
        </member>
        <member name="M:Au.ASqliteStatement.GetArray``1(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_blob(column)</c> as array.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.GetList``1(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_blob(column)</c> as List.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.GetStruct``1(Au.Types.SLIndexOrName)">
            <summary>
            Returns <c>sqlite3_column_blob(column)</c> as a variable of any value type that does not have fields of reference types.
            </summary>
        </member>
        <member name="P:Au.ASqliteStatement.ColumnCount">
            <summary>
            sqlite3_column_count.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.ColumnName(System.Int32)">
            <summary>
            sqlite3_column_name.
            </summary>
        </member>
        <member name="M:Au.ASqliteStatement.ColumnIndex(System.String)">
            <summary>
            Finds column by name in results.
            Returns 0-based index, or -1 if not found.
            </summary>
            <param name="name">Column name in results, as returned by sqlite3_column_name. Case-sensitive.</param>
        </member>
        <member name="M:Au.ASqliteStatement._WarnGet(System.String)">
            <summary>
            Called by GetX functions when sqlite3_column_x returns null/0.
            Shows warning if sqlite3_errcode is not 0 or Row.
            Does not throw exception because it is not thread-safe.
            </summary>
            <param name="func"></param>
        </member>
        <member name="T:Au.AThread">
            <summary>
            Thread functions. Extends <see cref="T:System.Threading.Thread"/>.
            </summary>
        </member>
        <member name="P:Au.AThread.NativeId">
            <summary>
            Gets native thread id of this thread.
            Calls API <msdn>GetCurrentThreadId</msdn>.
            </summary>
            <remarks>
            It is not the same as <see cref="P:System.Threading.Thread.ManagedThreadId"/>.
            </remarks>
            <seealso cref="P:Au.AWnd.ThreadId"/>
        </member>
        <member name="P:Au.AThread.Handle">
            <summary>
            Returns native thread handle of this thread.
            Calls API <msdn>GetCurrentThread</msdn>.
            </summary>
            <remarks>
            Don't need to close the handle.
            </remarks>
        </member>
        <member name="M:Au.AThread.HasMessageLoop(System.Boolean@)">
            <summary>
            Returns true if this thread has a .NET message loop (Forms or WPF).
            </summary>
            <param name="isWPF">Has WPF message loop and no Forms message loop.</param>
            <remarks>
            Unlike calling <b>Application.MessageLoop</b> etc directly, this function does not cause to load Forms and WPF dlls.
            </remarks>
            <seealso cref="M:Au.AWnd.GetWnd.ThreadWindows(System.Int32,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AThread.HasMessageLoop">
            
        </member>
        <member name="M:Au.AThread.LibTerminate(System.Int32)">
            <summary>
            Calls API OpenThread and TerminateThread.
            If it is a managed thread, at first need to set its IsBackground = true.
            </summary>
            <param name="nativeId"></param>
        </member>
        <member name="M:Au.AThread.Start(System.Action,System.Boolean,System.Boolean)">
            <summary>
            Starts new thread: creates new <see cref="T:System.Threading.Thread"/> object, sets some properties and calls <see cref="M:System.Threading.Thread.Start"/>.
            Returns the <b>Thread</b> variable.
            </summary>
            <param name="threadProc">Thread procedure. Parameter <i>start</i> of <b>Thread</b> constructor.</param>
            <param name="background">If true (default), sets <see cref="P:System.Threading.Thread.IsBackground"/> = true.</param>
            <param name="sta">If true (default), calls <see cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)"/>(ApartmentState.STA).</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="T:Au.AUac">
            <summary>
            Holds an access token (security info) of a process and provides various security info, eg [](xref:uac) integrity level.
            </summary>
        </member>
        <member name="M:Au.AUac.Finalize">
            
        </member>
        <member name="M:Au.AUac.Dispose">
            
        </member>
        <member name="P:Au.AUac.UnsafeTokenHandle">
            <summary>
            The access token handle.
            </summary>
            <remarks>
            The handle is managed by this variable and will be closed when disposing or GC-collecting it. Use <see cref="M:System.GC.KeepAlive(System.Object)"/> where need.
            </remarks>
        </member>
        <member name="P:Au.AUac.Failed">
            <summary>
            Returns true if the last called property function failed.
            Normally it should never fail. Only <see cref="M:Au.AUac.OfProcess(System.Int32)"/> can fail (then it returns null).
            </summary>
        </member>
        <member name="P:Au.AUac.Elevation">
            <summary>
            Gets the [](xref:uac) elevation type of the process.
            </summary>
        </member>
        <member name="P:Au.AUac.IsUIAccess">
            <summary>
            Returns true if the process has [](xref:uac) uiAccess property.
            A uiAccess process can access/automate all windows of processes running in the same user session.
            </summary>
            <remarks>
            Most processes don't have this property. They cannot access/automate windows of higher integrity level (High, System, uiAccess) processes and Windows 8 store apps. For example, cannot send keys and Windows messages.
            Note: High IL (admin) processes also can have this property, therefore <c>IsUIAccess</c> is not the same as <c>IntegrityLevel==IL.UIAccess</c> (<see cref="P:Au.AUac.IntegrityLevel"/> returns <b>UIAccess</b> only for Medium+uiAccess processes; for High+uiAccess processes it returns <b>High</b>). Some Windows API work slightly differently with uiAccess and non-uiAccess admin processes.
            This property is rarely useful. Instead use other properties of this class.
            </remarks>
        </member>
        <member name="P:Au.AUac.IntegrityLevel">
            <summary>
            Gets the [](xref:uac) integrity level (IL) of the process.
            </summary>
            <remarks>
            IL from lowest to highest value: Untrusted, Low, Medium, UIAccess, High, System, Protected, Unknown.
            The IL enum member values can be used like <c>if(x.IntegrityLevel > IL.Medium) ...</c> .
            If UAC is turned off, most non-service processes on administrator account have High IL; on non-administrator - Medium.
            </remarks>
        </member>
        <member name="M:Au.AUac.OfProcess(System.Int32)">
            <summary>
            Opens process access token and creates/returns new <see cref="T:Au.AUac"/> variable that holds it. Then you can use its properties.
            Returns null if failed. For example fails for services and some other processes if current process is not administrator.
            </summary>
            <param name="processId">Process id. If you have a window, use <see cref="P:Au.AWnd.ProcessId"/>.</param>
            <remarks>
            To get <b>AUac</b> of this process, use <see cref="P:Au.AUac.OfThisProcess"/>.
            </remarks>
        </member>
        <member name="P:Au.AUac.OfThisProcess">
            <summary>
            Gets <see cref="T:Au.AUac"/> variable for this process.
            </summary>
        </member>
        <member name="P:Au.AUac.IsAdmin">
            <summary>
            Returns true if this process is running as administrator, ie if the user belongs to the local Administrators group and the process is not limited by [](xref:uac).
            This function for example can be used to check whether you can write to protected locations in the file system and registry.
            </summary>
        </member>
        <member name="P:Au.AUac.IsUacDisabled">
            <summary>
            Returns true if [](xref:uac) is disabled (turned off) completely (not just disabled UAC consent screeen/dialog).
            </summary>
        </member>
        <member name="T:Au.AVersion">
            <summary>
            Provides various version info, for example the true Windows OS version.
            </summary>
            <remarks>
            The Windows version properties return true Windows version. If you need version that depends on manifest and debugger, instead use <see cref="P:System.Environment.OSVersion"/>.
            </remarks>
        </member>
        <member name="P:Au.AVersion.WinVer">
            <summary>
            Gets classic Windows major+minor version value:
            Win7 (0x601), Win8 (0x602), Win8_1 (0x603), Win10 (0xA00).
            Example: <c>if(AVersion.WinVer >= AVersion.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.AVersion.Win7">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.AVersion.WinVer"/>.
            Example: <c>if(AVersion.WinVer >= AVersion.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.AVersion.Win8">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.AVersion.WinVer"/>.
            Example: <c>if(AVersion.WinVer >= AVersion.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.AVersion.Win8_1">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.AVersion.WinVer"/>.
            Example: <c>if(AVersion.WinVer >= AVersion.Win8) ...</c>
            </summary>
        </member>
        <member name="F:Au.AVersion.Win10">
            <summary>
            Classic Windows version major+minor values that can be used with <see cref="P:Au.AVersion.WinVer"/>.
            Example: <c>if(AVersion.WinVer >= AVersion.Win8) ...</c>
            </summary>
        </member>
        <member name="P:Au.AVersion.MinWin8">
            <summary>
            true if Windows 8.0 or later.
            </summary>
        </member>
        <member name="P:Au.AVersion.MinWin8_1">
            <summary>
            true if Windows 8.1 or later.
            </summary>
        </member>
        <member name="P:Au.AVersion.MinWin10">
            <summary>
            true if Windows 10 or later.
            </summary>
        </member>
        <member name="P:Au.AVersion.Is64BitProcess">
            <summary>
            true if this process is 64-bit, false if 32-bit.
            The same as <see cref="P:System.Environment.Is64BitProcess"/>.
            </summary>
        </member>
        <member name="P:Au.AVersion.Is64BitOS">
            <summary>
            true if Windows is 64-bit, false if 32-bit.
            The same as <see cref="P:System.Environment.Is64BitOperatingSystem"/>, but fast. The .NET function is slow in 32-bit process; they forgot to optimize it.
            </summary>
        </member>
        <member name="P:Au.AVersion.Is32BitProcessAnd64BitOS">
            <summary>
            Returns true if this process is a 32-bit process running on 64-bit Windows. Also known as WOW64 process.
            </summary>
        </member>
        <member name="T:Au.AClipboard">
            <summary>
            Clipboard functions: copy, paste, get and set clipboard text and other data.
            </summary>
            <remarks>
            This class is similar to the .NET <see cref="T:System.Windows.Forms.Clipboard"/> class, which uses OLE API, works only in STA threads and does not work well in automation scripts. This class uses non-OLE API and works well in automation scripts and any threads.
            
            To set/get clipboard data of non-text formats, use class <see cref="T:Au.AClipboardData"/>; to paste, use it with <see cref="M:Au.AClipboard.PasteData(Au.AClipboardData,Au.Types.OptKey)"/>; to copy (get from the active app), use it with <see cref="M:Au.AClipboard.CopyData(System.Action,System.Boolean,Au.Types.OptKey)"/>.
            
            Should not be used to copy/paste in windows of own thread. In most cases it works, but strange problems are possible, because it waits until the window processes the copy/paste request, and while waiting it gets/dispatches all messages/events/etc. It's better to call it from another thread. Example in <see cref="M:Au.AKeys.Key(System.Object[])"/>.
            </remarks>
        </member>
        <member name="M:Au.AClipboard.Clear">
            <summary>
            Clears the clipboard.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="P:Au.AClipboard.Text">
            <summary>
            Gets or sets clipboard text.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry) or set clipboard data.</exception>
            <exception cref="T:System.OutOfMemoryException">The 'set' function failed to allocate memory.</exception>
            <remarks>
            The 'get' function calls <see cref="M:Au.AClipboardData.GetText(System.Int32)"/>. Also can get file paths, as multiline text. Returns null if there is no text/files.
            </remarks>
            <seealso cref="T:Au.AClipboardData"/>
        </member>
        <member name="M:Au.AClipboard._SetClipboardData_ClipboardViewerIgnore">
            <summary>
            Calls API SetClipboardData("Clipboard Viewer Ignore"). Clipboard must be open.
            Then clipboard manager/viewer/etc programs that are aware of this convention don't try to get our clipboard data while we are pasting.
            Tested apps that support it: Ditto, Clipdiary. Other 5 tested apps don't.
            </summary>
        </member>
        <member name="M:Au.AClipboard.CopyText(System.Boolean,Au.Types.OptKey)">
            <summary>
            Gets the selected text from the focused app using the clipboard.
            </summary>
            <param name="cut">Use Ctrl+X.</param>
            <param name="options">
            Options. If null (default), uses <see cref="P:Au.AOpt.Key"/>.
            Uses <see cref="P:Au.Types.OptKey.RestoreClipboard"/>, <see cref="P:Au.Types.OptKey.NoBlockInput"/>, <see cref="P:Au.Types.OptKey.KeySpeedClipboard"/>. Does not use <see cref="P:Au.Types.OptKey.Hook"/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Also can get file paths, as multiline text.
            Sends keys Ctrl+C, waits until the focused app sets clipboard data, gets it, finally restores clipboard data.
            Fails (exception) if the focused app does not set clipboard text or file paths, for example if there is no selected text/files.
            Works with console windows too, even if they don't support Ctrl+C.
            </remarks>
        </member>
        <member name="M:Au.AClipboard.CopyData(System.Action,System.Boolean,Au.Types.OptKey)">
            <summary>
            Gets data of any formats from the focused app using the clipboard and a callback function.
            </summary>
            <param name="callback">Callback function. It can get clipboard data of any formats. It can use any clipboard functions, for example the <see cref="T:Au.AClipboardData"/> class or the .NET <see cref="T:System.Windows.Forms.Clipboard"/> class. Don't call copy/paste functions.</param>
            <param name="cut">Use Ctrl+X.</param>
            <param name="options">See <see cref="M:Au.AClipboard.CopyText(System.Boolean,Au.Types.OptKey)"/>.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <exception cref="T:System.Exception">Exceptions thrown by the callback function.</exception>
            <remarks>
            Sends keys Ctrl+C, waits until the focused app sets clipboard data, calls callback function that gets it, finally restores clipboard data.
            Fails (exception) if the focused app does not set clipboard data.
            Works with console windows too, even if they don't support Ctrl+C.
            </remarks>
            <example>
            <code><![CDATA[
            string text = null; Bitmap image = null; string[] files = null;
            AClipboard.CopyData(() => { text = AClipboardData.GetText(); image = AClipboardData.GetImage(); files = AClipboardData.GetFiles(); });
            if(text == null) Print("no text in clipboard"); else Print(text);
            if(image == null) Print("no image in clipboard"); else Print(image.Size);
            if(files == null) Print("no files in clipboard"); else Print(files);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AClipboard.PasteText(System.String,Au.Types.OptKey)">
            <summary>
            Pastes text into the focused app using the clipboard.
            </summary>
            <param name="text">Text.</param>
            <param name="options">
            Options. If null (default), uses <see cref="P:Au.AOpt.Key"/>.
            Uses <see cref="P:Au.Types.OptKey.RestoreClipboard"/>, <see cref="P:Au.Types.OptKey.PasteEnter"/>, <see cref="P:Au.Types.OptKey.NoBlockInput"/>, <see cref="P:Au.Types.OptKey.SleepFinally"/>, <see cref="P:Au.Types.OptKey.Hook"/>, <see cref="P:Au.Types.OptKey.KeySpeedClipboard"/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Adds to the clipboard, sends keys Ctrl+V, waits until the focused app gets clipboard data, finally restores clipboard data.
            Fails (exception) if nothing gets clipboard data in several seconds.
            Works with console windows too, even if they don't support Ctrl+V.
            A clipboard viewer/manager program can make this function slower and less reliable, unless it supports <see cref="P:Au.Types.ClipFormats.ClipboardViewerIgnore"/> or gets clipboard data with a delay.
            Possible problems with some virtual PC programs. Either pasting does not work in their windows, or they use a hidden clipboard viewer that makes this function slower and less reliable.
            </remarks>
            <seealso cref="M:Au.AKeys.Text(System.String)"/>
            <example>
            <code><![CDATA[
            AClipboard.PasteText("Example\r\n");
            Paste("Example\r\n"); //the same as above
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AClipboard.PasteData(Au.AClipboardData,Au.Types.OptKey)">
            <summary>
            Pastes data added to a <see cref="T:Au.AClipboardData"/> variable into the focused app using the clipboard.
            More info: <see cref="M:Au.AClipboard.PasteText(System.String,Au.Types.OptKey)"/>.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            Paste data of two formats: HTML and text.
            <code><![CDATA[
            AClipboard.PasteData(new AClipboardData().AddHtml("<b>text</b>").AddText("text"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AClipboard.LibPaste(System.Object,Au.Types.OptKey,Au.AWnd)">
            <summary>
            Used by AClipboard and AKeys.
            The caller should block user input (if need), release modifier keys, get opt/wFocus, sleep finally (if need).
            </summary>
            <param name="data">string or Data.</param>
            <param name="opt"></param>
            <param name="wFocus"></param>
        </member>
        <member name="T:Au.AClipboard._ClipboardListener">
            <summary>
            Waits until the target app gets (Paste) or sets (Copy) clipboard text.
            For it subclasses our clipboard owner window and uses clipboard messages. Does not unsubclass.
            </summary>
        </member>
        <member name="P:Au.AClipboard._ClipboardListener.Success">
            <summary>
            The clipboard message has been received. Probably the target window responded to the Ctrl+C or Ctrl+V.
            On Paste it is unreliable because of clipboard viewers/managers/etc. The caller also must check IsBadWindow.
            </summary>
        </member>
        <member name="F:Au.AClipboard._ClipboardListener.IsBadWindow">
            <summary>
            On Paste, true if probably not the target process retrieved clipboard data. Probably a clipboard viewer/manager/etc.
            Not used on Copy.
            </summary>
        </member>
        <member name="F:Au.AClipboard._ClipboardListener.FailedToSetData">
            <summary>
            Exception thrown/catched when failed to set clipboard data.
            </summary>
        </member>
        <member name="M:Au.AClipboard._ClipboardListener.#ctor(System.Boolean,System.Object,Au.AWnd,Au.AWnd)">
            <summary>
            Subclasses clipOwner.
            </summary>
            <param name="paste">true if used for paste, false if for copy.</param>
            <param name="data">If used for paste, can be string containing Unicode text or int/string dictionary containing clipboard format/data.</param>
            <param name="clipOwner">Our clipboard owner window.</param>
            <param name="wFocus">The target control or window.</param>
        </member>
        <member name="M:Au.AClipboard._ClipboardListener.Wait(Au.AKeys.Lib.SendCopyPaste@)">
            <summary>
            Waits until the target app gets (Paste) or sets (Copy) clipboard text.
            Throws AuException on timeout (3 s normally, 28 s if the target window is hung).
            </summary>
            <param name="ctrlKey">The variable that was used to send Ctrl+V or Ctrl+C. This function may call Release to avoid too long Ctrl down.</param>
        </member>
        <member name="T:Au.AClipboard.LibOpenClipboard">
            <summary>
            Opens and closes clipboard using API OpenClipboard and CloseClipboard.
            Constructor tries to open for 10 s, then throws AuException.
            If the 'createOwner' parameter is true, creates temporary message-only clipboard owner window.
            If the 'noOpenNow' parameter is true, does not open, only creates owner if need.
            Dispose() closes clipboard and destroys the owner window.
            </summary>
        </member>
        <member name="M:Au.AClipboard.LibOpenClipboard.Reopen(System.Boolean)">
            <summary>
            Opens again.
            Must be closed.
            Owner window should be not destroyed; does not create again.
            </summary>
            <param name="noThrow">If fails, return false, no exception. Also then waits 1 s instead of 10 s.</param>
            <exception cref="T:Au.Types.AuException">Failed to open.</exception>
        </member>
        <member name="T:Au.AClipboard._SaveRestore">
            <summary>
            Saves and restores clipboard data.
            Clipboard must be open. Don't need to call EmptyClipboard before Restore.
            </summary>
        </member>
        <member name="T:Au.AClipboardData">
            <summary>
            Sets or gets clipboard data in multiple formats.
            </summary>
            <remarks>
            The <b>AddX</b> functions add data to the variable (not to the clipboard). Then <see cref="M:Au.AClipboardData.SetClipboard"/> copies the added data to the clipboard. Also you can use the variable with <see cref="M:Au.AClipboard.PasteData(Au.AClipboardData,Au.Types.OptKey)"/>.
            The static <b>GetX</b> functions get data directly from the clipboard.
            </remarks>
            <example>
            Get bitmap image from clipboard.
            <code><![CDATA[
            var image = AClipboardData.GetImage();
            if(image == null) Print("no image in clipboard"); else Print(image.Size);
            ]]></code>
            Set clipboard data of two formats: text and image.
            <code><![CDATA[
            new AClipboardData().AddText("text").AddImage(Image.FromFile(@"q:\file.png")).SetClipboard();
            ]]></code>
            Paste data of two formats: HTML and text.
            <code><![CDATA[
            AClipboard.PasteData(new AClipboardData().AddHtml("<b>text</b>").AddText("text"));
            ]]></code>
            Copy data of two formats: HTML and text.
            <code><![CDATA[
            string html = null, text = null;
            AClipboard.CopyData(() => { html = AClipboardData.GetHtml(); text = AClipboardData.GetText(); });
            Print(html); Print(text);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AClipboardData.AddText(System.String,System.Int32)">
            <summary>
            Adds text.
            Returns this.
            </summary>
            <param name="text">Text.</param>
            <param name="format">
            Clipboard format id. Default: <see cref="F:Au.Types.ClipFormats.Text"/> (CF_UNICODETEXT).
            Text encoding (UTF-16, ANSI, etc) depends on format; default UTF-16. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid format.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Text.Encoding.GetBytes(System.String)"/>, which is called if encoding is not UTF-16.</exception>
        </member>
        <member name="M:Au.AClipboardData.AddBinary(System.Byte[],System.Int32)">
            <summary>
            Adds data of any format as byte[].
            Returns this.
            </summary>
            <param name="data">byte[] containing data.</param>
            <param name="format">Clipboard format id. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid format. Supported are all registered formats and standard formats &lt;CF_MAX except GDI handles.</exception>
        </member>
        <member name="M:Au.AClipboardData.AddImage(System.Drawing.Image)">
            <summary>
            Adds image. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Image"/> (CF_BITMAP).
            Returns this.
            </summary>
            <param name="image">Image. Must be <see cref="T:System.Drawing.Bitmap"/>, else exception.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.AClipboardData.AddHtml(System.String)">
            <summary>
            Adds HTML text. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns this.
            </summary>
            <param name="html">Full HTML or HTML fragment. If full HTML, a fragment in it can be optionally specified. See examples.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <example>
            <code><![CDATA[
            d.AddHtml("<i>italy</i>");
            d.AddHtml("<html><body><i>italy</i></body></html>");
            d.AddHtml("<html><body><!--StartFragment--><i>italy</i><!--EndFragment--></body></html>");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AClipboardData.AddRtf(System.String)">
            <summary>
            Adds rich text (RTF). Uses clipboard format <see cref="P:Au.Types.ClipFormats.Rtf"/> ("Rich Text Format").
            Returns this.
            </summary>
            <param name="rtf">Rich text. Simplest example: <c>@"{\rtf1 text\par}"</c>.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.AClipboardData.AddFiles(System.String[])">
            <summary>
            Adds list of files to copy/paste. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Files"/> (CF_HDROP).
            Returns this.
            </summary>
            <param name="files">One or more file paths.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.AClipboardData.SetClipboard">
            <summary>
            Copies the added data of all formats to the clipboard.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry) or set clipboard data.</exception>
            <exception cref="T:System.OutOfMemoryException">Failed to allocate memory for clipboard data.</exception>
            <remarks>
            Calls API <msdn>OpenClipboard</msdn>, <msdn>EmptyClipboard</msdn>, <msdn>SetClipboardData</msdn> and <msdn>CloseClipboard</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AClipboardData.SetOpenClipboard(System.Boolean,System.Int32)">
            <summary>
            Copies the added data to the clipboard.
            </summary>
            <param name="renderLater">Call API <msdn>SetClipboardData</msdn>(format, default). When/if some app will try to get clipboard data, the first time your clipboard owner window will receive <msdn>WM_RENDERFORMAT</msdn> message and should call <c>SetOpenClipboard(false);</c>.</param>
            <param name="format">Copy data only of this format. If 0 (default), of all formats.</param>
            <exception cref="T:System.OutOfMemoryException">Failed to allocate memory for clipboard data.</exception>
            <exception cref="T:Au.Types.AuException">Failed to set clipboard data.</exception>
            <remarks>
            This function is similar to <see cref="M:Au.AClipboardData.SetClipboard"/>. It calls API <msdn>SetClipboardData</msdn> and does not call <b>OpenClipboard</b>, <b>EmptyClipboard</b>, <b>CloseClipboard</b>. The clipboard must be open and owned by a window of this thread.
            </remarks>
        </member>
        <member name="M:Au.AClipboardData.LibSetText(System.String)">
            <summary>
            Copies Unicode text to the clipboard without open/empty/close.
            </summary>
        </member>
        <member name="M:Au.AClipboardData.LibCreateHtmlFormatData(System.String)">
            <summary>
            Converts HTML string to byte[] containing data in clipboard format "HTML Format".
            </summary>
            <param name="html">Full HTML or HTML fragment. If full HTML, a fragment in it can be optionally specified. See examples.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <example>
            HTML examples.
            <code><![CDATA[
            "<i>italy</i>"
            "<html><body><i>italy</i></body></html>"
            "<html><body><!--StartFragment--><i>italy</i><!--EndFragment--></body></html>"
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AClipboardData.LibGetText(System.Int32)">
            <summary>
            Gets clipboard text without open/close.
            If format is 0, tries CF_UNICODETEXT and CF_HDROP.
            </summary>
        </member>
        <member name="M:Au.AClipboardData.GetText(System.Int32)">
            <summary>
            Gets text from the clipboard.
            Returns null if there is no text.
            </summary>
            <param name="format">
            Clipboard format id. Default: <see cref="F:Au.Types.ClipFormats.Text"/> (CF_UNICODETEXT).
            If 0, tries to get text (<see cref="F:Au.Types.ClipFormats.Text"/>) or file paths (<see cref="F:Au.Types.ClipFormats.Files"/>; returns multiline text).
            Text encoding (UTF-16, ANSI, etc) depends on format; default UTF-16. See <see cref="M:Au.Types.ClipFormats.Register(System.String,System.Text.Encoding)"/>.
            </param>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.AClipboardData.GetBinary(System.Int32)">
            <summary>
            Gets clipboard data of any format as byte[].
            Returns null if there is no data of the specified format.
            </summary>
            <exception cref="T:System.ArgumentException">Invalid format. Supported are all registered formats and standard formats &lt;CF_MAX except GDI handles.</exception>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.AClipboardData.GetImage">
            <summary>
            Gets image from the clipboard. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Image"/> (CF_BITMAP).
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Drawing.Image.FromHbitmap(System.IntPtr)"/>.</exception>
        </member>
        <member name="M:Au.AClipboardData.GetHtml">
            <summary>
            Gets HTML text from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns null if there is no data of this format or if failed to parse it.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.AClipboardData.GetHtml(System.Int32@,System.Int32@,System.String@)">
            <summary>
            Gets HTML text from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Html"/> ("HTML Format").
            Returns null if there is no data of this format or if failed to parse it.
            </summary>
            <param name="fragmentStart">Fragment start index in the returned string.</param>
            <param name="fragmentLength">Fragment length.</param>
            <param name="sourceURL">Source URL, or null if unavailable.</param>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.AClipboardData.GetRtf">
            <summary>
            Gets rich text (RTF) from the clipboard. Uses clipboard format <see cref="P:Au.Types.ClipFormats.Rtf"/> ("Rich Text Format").
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.AClipboardData.GetFiles">
            <summary>
            Gets file paths from the clipboard. Uses clipboard format <see cref="F:Au.Types.ClipFormats.Files"/> (CF_HDROP).
            Returns null if there is no data of this format.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to open clipboard (after 10 s of wait/retry).</exception>
        </member>
        <member name="M:Au.AClipboardData._HdropToFiles(System.IntPtr)">
            <summary>
            Gets file paths from HDROP.
            Returns array of 0 or more non-null elements.
            </summary>
        </member>
        <member name="M:Au.AClipboardData.Contains(System.Int32)">
            <summary>
            Returns true if the clipboard contains data of the specified format.
            </summary>
            <param name="format">Clipboard format id. See <see cref="T:Au.Types.ClipFormats"/>.</param>
            <remarks>Calls API <msdn>IsClipboardFormatAvailable</msdn>.</remarks>
        </member>
        <member name="M:Au.AClipboardData.Contains(System.Int32[])">
            <summary>
            Returns the first of the specified formats that is in the clipboard.
            Returns 0 if the clipboard is empty. Returns -1 if the clipboard contains data but not in any of the specified formats.
            </summary>
            <param name="formats">Clipboard format ids. See <see cref="T:Au.Types.ClipFormats"/>.</param>
            <remarks>Calls API <msdn>GetPriorityClipboardFormat</msdn>.</remarks>
        </member>
        <member name="T:Au.AHookWin">
            <summary>
            Wraps API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <remarks>
            Hooks are used to receive notifications about various system events. Keyboard and mouse input, window messages, various window events.
            
            Threads that use hooks must process Windows messages. For example have a window/dialog/messagebox, or use a 'wait-for' function that dispatches messages or has such option (see <see cref="P:Au.AOpt.WaitFor"/>).
            
            <note type="important">The variable must be disposed, either explicitly (call <b>Dispose</b> or <b>Unhook</b> in the same thread) or with the 'using' pattern. Else this process may crash.</note>
            
            <note type="warning">Avoid many hooks. Each low-level keyboard or mouse hook makes the computer slower, even if the hook procedure is fast. On each input event (key down, key up, mouse move, click, wheel) Windows sends a message to your thread.</note>
            
            To handle hooked events is used a callback functions, aka hook procedure. Hook procedures of some hook types can block some events. Blocked events are not sent to apps and older hooks.
            
            Accessible object functions may fail in hook procedures of low-level keyboard and mouse hooks. Workarounds exist.
            
            Exists an alternative way to monitor keyboard or mouse events - raw input API. Good: less overhead; can detect from which device the input event came. Bad: cannot block events; incompatible with low-level keyboard hooks. This library does not have functions to make the API easier to use.
            </remarks>
        </member>
        <member name="M:Au.AHookWin.Keyboard(System.Action{Au.Types.HookData.Keyboard},System.Boolean,System.Boolean)">
            <summary>
            Sets a low-level keyboard hook (WH_KEYBOARD_LL).
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.AHookWin"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible. More info: <see cref="P:Au.AHookWin.LowLevelHooksTimeout"/>.
            If calls <see cref="M:Au.Types.HookData.Keyboard.BlockEvent"/> or <see cref="M:Au.Types.HookData.ReplyMessage(System.Boolean)"/>(true), the event is not sent to apps and other hooks.
            Event data cannot be modified.
            <note>When the hook procedure returns, the parameter variable becomes invalid and unsafe to use. If you need the data for later use, copy its properties and not whole variable.</note>
            </param>
            <param name="ignoreAuInjected">Don't call the hook procedure for events sent by functions of this library. Default true.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            var stop = false;
            using(AHookWin.Keyboard(x => {
            	Print(x);
            	if(x.vkCode == KKey.Escape) { stop = true; x.BlockEvent(); }
            })) {
            	MessageBox.Show("Low-level keyboard hook.", "Test");
            	//or
            	//AWaitFor.MessagesAndCondition(-10, () => stop); //wait max 10 s for Esc key
            	//Print("the end");
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookWin.Mouse(System.Action{Au.Types.HookData.Mouse},System.Boolean,System.Boolean)">
            <summary>
            Sets a low-level mouse hook (WH_MOUSE_LL).
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.AHookWin"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible. More info: <see cref="P:Au.AHookWin.LowLevelHooksTimeout"/>.
            If calls <see cref="M:Au.Types.HookData.Mouse.BlockEvent"/> or <see cref="M:Au.Types.HookData.ReplyMessage(System.Boolean)"/>(true), the event is not sent to apps and other hooks.
            Event data cannot be modified.
            <note>When the hook procedure returns, the parameter variable becomes invalid and unsafe to use. If you need the data for later use, copy its properties and not whole variable.</note>
            </param>
            <param name="ignoreAuInjected">Don't call the hook procedure for events sent by functions of this library. Default true.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            var stop = false;
            using(AHookWin.Mouse(x => {
            	Print(x);
            	if(x.Event == HookData.MouseEvent.RightButton) { stop = x.IsButtonUp; x.BlockEvent(); }
            })) {
            	MessageBox.Show("Low-level mouse hook.", "Test");
            	//or
            	//AWaitFor.MessagesAndCondition(-10, () => stop); //wait max 10 s for right-click
            	//Print("the end");
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookWin.ThreadCbt(System.Func{Au.Types.HookData.ThreadCbt,System.Boolean},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_CBT hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.AHookWin"/> object that manages the hook.</returns>
            <param name="hookProc">
            Hook procedure (function that handles hook events).
            Must return as soon as possible.
            If returns true, the event is cancelled. For some events you can modify some fields of event data.
            <note>When the hook procedure returns, the parameter variable becomes invalid and unsafe to use. If you need the data for later use, copy its properties and not whole variable.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using(AHookWin.ThreadCbt(x => {
            	Print(x.code);
            	switch(x.code) {
            	case HookData.CbtEvent.ACTIVATE:
            		Print(x.ActivationInfo(out _, out _));
            		break;
            	case HookData.CbtEvent.CREATEWND:
            		Print(x.CreationInfo(out var c, out _), c->x, c->lpszName);
            		break;
            	case HookData.CbtEvent.CLICKSKIPPED:
            		Print(x.MouseInfo(out var m), m->pt, m->hwnd);
            		break;
            	case HookData.CbtEvent.KEYSKIPPED:
            		Print(x.KeyInfo(out _));
            		break;
            	case HookData.CbtEvent.SETFOCUS:
            		Print(x.FocusInfo(out AWnd wPrev), wPrev);
            		break;
            	case HookData.CbtEvent.MOVESIZE:
            		Print(x.MoveSizeInfo(out var r), r->ToString());
            		break;
            	case HookData.CbtEvent.MINMAX:
            		Print(x.MinMaxInfo(out var state), state);
            		break;
            	case HookData.CbtEvent.DESTROYWND:
            		Print((AWnd)x.wParam);
            		break;
            	}
            	return false;
            })) {
            	MessageBox.Show("CBT hook.", "Test", MessageBoxButtons.OKCancel);
            	//new Form().ShowDialog(); //to test MINMAX
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookWin.ThreadGetMessage(System.Action{Au.Types.HookData.ThreadGetMessage},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_GETMESSAGE hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.AHookWin"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            The event cannot be cancelled. As a workaround, you can set msg->message=0. Also can modify other fields.
            <note>When the hook procedure returns, the pointer field of the parameter variable becomes invalid and unsafe to use.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using(AHookWin.ThreadGetMessage(x => {
            	Print(x.msg->ToString(), x.PM_NOREMOVE);
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookWin.ThreadKeyboard(System.Func{Au.Types.HookData.ThreadKeyboard,System.Boolean},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_GETMESSAGE hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.AHookWin"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            If returns true, the event is cancelled.
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using(AHookWin.ThreadKeyboard(x => {
            	Print(x.key, 0 != (x.lParam & 0x80000000) ? "up" : "", x.lParam, x.PM_NOREMOVE);
            	return false;
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookWin.ThreadMouse(System.Func{Au.Types.HookData.ThreadMouse,System.Boolean},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_MOUSE hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.AHookWin"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            If returns true, the event is cancelled.
            <note>When the hook procedure returns, the pointer field of the parameter variable becomes invalid and unsafe to use.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using(AHookWin.ThreadMouse(x => {
            	Print(x.message, x.m->pt, x.m->hwnd, x.PM_NOREMOVE);
            	return false;
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookWin.ThreadCallWndProc(System.Action{Au.Types.HookData.ThreadCallWndProc},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_CALLWNDPROC hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.AHookWin"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            The event cannot be cancelled or modified.
            <note>When the hook procedure returns, the pointer field of the parameter variable becomes invalid and unsafe to use.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using(AHookWin.ThreadCallWndProc(x => {
            	ref var m = ref *x.msg;
            	var mm = Message.Create(m.hwnd.Handle, (int)m.message, m.wParam, m.lParam);
            	Print(mm, x.sentByOtherThread);
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookWin.ThreadCallWndProcRet(System.Action{Au.Types.HookData.ThreadCallWndProcRet},System.Int32,System.Boolean)">
            <summary>
            Sets a WH_CALLWNDPROCRET hook for a thread of this process.
            See API <msdn>SetWindowsHookEx</msdn>.
            </summary>
            <returns>Returns a new <see cref="T:Au.AHookWin"/> object that manages the hook.</returns>
            <param name="hookProc">
            The hook procedure (function that handles hook events).
            Must return as soon as possible.
            The event cannot be cancelled or modified.
            <note>When the hook procedure returns, the pointer field of the parameter variable becomes invalid and unsafe to use.</note>
            </param>
            <param name="threadId">Native thread id, or 0 for this thread. The thread must belong to this process.</param>
            <param name="setNow">Set hook now. Default true.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>
            <code><![CDATA[
            using(AHookWin.ThreadCallWndProcRet(x => {
            	ref var m = ref *x.msg;
            	var mm = Message.Create(m.hwnd.Handle, (int)m.message, m.wParam, m.lParam); mm.Result = m.lResult;
            	Print(mm, x.sentByOtherThread);
            })) MessageBox.Show("hook");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookWin.Hook(System.Int32)">
            <summary>
            Sets the hook.
            </summary>
            <param name="threadId">If the hook type is a thread hook - thread id, or 0 for current thread. Else not used and must be 0.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <exception cref="T:System.InvalidOperationException">The hook is already set.</exception>
            <exception cref="T:System.ArgumentException">threadId not 0 and the hook type is not a thread hook.</exception>
            <remarks>
            Usually don't need to call this function, because the <b>AHookWin</b> static methods that return a new <b>AHookWin</b> object by default call it.
            </remarks>
        </member>
        <member name="M:Au.AHookWin.Unhook">
            <summary>
            Removes the hook.
            </summary>
            <remarks>
            Does nothing if already removed or wasn't set.
            Later you can call <see cref="M:Au.AHookWin.Hook(System.Int32)"/> to set hook again.
            </remarks>
        </member>
        <member name="P:Au.AHookWin.IsSet">
            <summary>
            Returns true if the hook is set.
            </summary>
        </member>
        <member name="M:Au.AHookWin.Dispose">
            <summary>
            Calls <see cref="M:Au.AHookWin.Unhook"/> and disposes this object.
            </summary>
        </member>
        <member name="M:Au.AHookWin.Finalize">
            
        </member>
        <member name="P:Au.AHookWin.LowLevelHooksTimeout">
            <summary>
            Gets the max time in milliseconds allowed by Windows for low-level keyboard and mouse hook procedures.
            </summary>
            <remarks>
            Gets registry value HKEY_CURRENT_USER\Control Panel\Desktop:LowLevelHooksTimeout. If it is missing, returns 300; it is the default value used by Windows. If greater than 1000, returns 1000, because Windows 10 ignores bigger values.
            
            If a hook procedure takes more time, Windows does not wait. Then the return value is ignored, and the event is passed to other apps, hooks, etc. After several such cases Windows may fully or partially disable the hook. This class detects such cases; then it restores the hook and displays a warning. If the warning is rare, you can ignore it. If frequent, it means your hook procedure is too slow and need to edit it.
            
            Callback functions of keyboard and mouse triggers are called in a hook procedure, therefore must be as fast as possible. More info: <see cref="T:Au.Triggers.TriggerFuncs"/>.
            
            More info: <msdn>registry LowLevelHooksTimeout</msdn>.
            </remarks>
        </member>
        <member name="M:Au.AHookWin.LibOnException(System.Exception,System.IDisposable)">
            <summary>
            Called on any catched exception in a hook procedure.
            Returns true if it is ThreadAbortException.
            </summary>
            <param name="e"></param>
            <param name="hook">On ThreadAbortException calls hook.Dispose.</param>
        </member>
        <member name="M:Au.AHookWin.LibIgnoreModInOtherHooks(System.Int64)">
            <summary>
            Let other hooks (in all processes) ignore modifier keys for timeMS milliseconds. If 0 - restore.
            Used by mouse triggers.
            Returns the timeout time (ATime.WinMilliseconds + timeMS) or 0.
            </summary>
        </member>
        <member name="M:Au.AHookWin.LibIgnoreLShiftCaps(System.Int64)">
            <summary>
            Let all hooks (in all processes) ignore LShift and CapsLock for timeMS milliseconds. If 0 - restore.
            Returns the timeout time (ATime.WinMilliseconds + timeMS) or 0.
            Used when turning off CapsLock with Shift.
            </summary>
        </member>
        <member name="T:Au.AHookAcc">
            <summary>
            Helps with accessible object event hooks. See API <msdn>SetWinEventHook</msdn>.
            </summary>
            <remarks>
            The thread that uses hooks must process Windows messages. For example have a window/dialog/messagebox, or use a 'wait-for' function that dispatches messages or has such option (see <see cref="P:Au.AOpt.WaitFor"/>).
            The variable must be disposed, either explicitly (call <b>Dispose</b> or <b>Unhook</b>) or with the 'using' pattern.
            </remarks>
            <example>
            <code><![CDATA[
            bool stop = false;
            using(new AHookAcc(AccEVENT.SYSTEM_FOREGROUND, 0, x =>
            {
            	Print(x.wnd);
            	var a = x.GetAcc();
            	Print(a);
            	if(x.wnd.ClassNameIs("Shell_TrayWnd")) stop = true;
            })) {
            	MessageBox.Show("hook");
            	//or
            	//AWaitFor.MessagesAndCondition(-10, () => stop); //wait max 10 s for activated taskbar
            	//Print("the end");
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AHookAcc.#ctor(Au.Types.AccEVENT,Au.Types.AccEVENT,System.Action{Au.Types.HookData.AccHookData},System.Int32,System.Int32,Au.Types.AccHookFlags)">
            <summary>
            Sets a hook for an event or a range of events.
            Calls API <msdn>SetWinEventHook</msdn>.
            </summary>
            <param name="eventMin">The lowest event constant value in the range of events. Can be AccEVENT.MIN to indicate the lowest possible event value. Events reference: <msdn>SetWinEventHook</msdn>.</param>
            <param name="eventMax">The highest event constant value in the range of events. Can be AccEVENT.MAX to indicate the highest possible event value. If 0, uses <i>eventMin</i>.</param>
            <param name="hookProc">The hook procedure (function that handles hook events).</param>
            <param name="idProcess">The id of the process from which the hook function receives events. If 0 - all processes on the current desktop.</param>
            <param name="idThread">The native id of the thread from which the hook function receives events. If 0 - all threads.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>See <see cref="T:Au.AHookAcc"/>.</example>
        </member>
        <member name="M:Au.AHookAcc.#ctor(Au.Types.AccEVENT[],System.Action{Au.Types.HookData.AccHookData},System.Int32,System.Int32,Au.Types.AccHookFlags)">
            <summary>
            Sets a hook for multiple events.
            Calls API <msdn>SetWinEventHook</msdn>.
            </summary>
            <param name="events">Events. Reference: API <msdn>SetWinEventHook</msdn>. Elements with value 0 are ignored.</param>
            <param name="hookProc">The hook procedure (function that handles hook events).</param>
            <param name="idProcess">The id of the process from which the hook function receives events. If 0 - all processes on the current desktop.</param>
            <param name="idThread">The native id of the thread from which the hook function receives events. If 0 - all threads.</param>
            <param name="flags"></param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <example>See <see cref="T:Au.AHookAcc"/>.</example>
        </member>
        <member name="M:Au.AHookAcc.Hook(Au.Types.AccEVENT,Au.Types.AccEVENT,System.Int32,System.Int32,Au.Types.AccHookFlags)">
            <summary>
            Sets hooks again after <see cref="M:Au.AHookAcc.Unhook"/>.
            </summary>
            <remarks>
            Parameters are the same as of the constructor, but values can be different.
            </remarks>
        </member>
        <member name="M:Au.AHookAcc.Hook(Au.Types.AccEVENT[],System.Int32,System.Int32,Au.Types.AccHookFlags)">
            <summary>
            Sets hooks again after <see cref="M:Au.AHookAcc.Unhook"/>.
            </summary>
            <remarks>
            Parameters are the same as of the constructor, but values can be different.
            </remarks>
        </member>
        <member name="M:Au.AHookAcc.Unhook">
            <summary>
            Removes the hook.
            </summary>
            <remarks>
            Does nothing if already removed or wasn't set.
            Must be called from the same thread that sets the hook.
            </remarks>
        </member>
        <member name="M:Au.AHookAcc.Dispose">
            <summary>
            Calls <see cref="M:Au.AHookAcc.Unhook"/>.
            </summary>
        </member>
        <member name="M:Au.AHookAcc.Finalize">
            
        </member>
        <member name="T:Au.AInputBlocker">
            <summary>
            Blocks keyboard and/or mouse input events from reaching applications.
            </summary>
            <remarks>
            Uses keyboard and/or mouse hooks. Does not use API <b>BlockInput</b>, it does not work on current Windows versions.
            Blocks hardware-generated events and software-generated events, except generated by functions of this library.
            Functions of this library that send keys or text use this class internally, to block user-pressed keys and resend them afterwards (see <see cref="P:Au.AInputBlocker.ResendBlockedKeys"/>).
            Does not block:
            - In windows of the same thread that started blocking. For example, if your script shows a message box, the user can click its buttons.
            - In windows of higher [](xref:uac) integrity level (IL) processes, unless this process has uiAccess IL.
            - In special desktops/screens, such as when you press Ctrl+Alt+Delete or launch an admin program that requires UAC elevation. See also <see cref="P:Au.AInputBlocker.ResumeAfterCtrlAltDelete"/>.
            - Some Windows hotkeys, such as Ctrl+Alt+Delete and Win+L.
            - Keyboard hooks don't work in windows of this process if this process uses direct input or raw input API.
            
            To stop blocking, can be used the 'using' pattern, like in the example. Or the 'try/finally' pattern, where the finally block calls <see cref="M:Au.AInputBlocker.Dispose"/> or <see cref="M:Au.AInputBlocker.Stop(System.Boolean)"/>. Also automatically stops when this thread ends. Users can stop with Ctrl+Alt+Delete.
            </remarks>
            <example>
            <code><![CDATA[
            using(new AInputBlocker(BIEvents.All)) {
            	Print("blocked");
            	5.s();
            }
            Print("not blocked");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AInputBlocker.#ctor">
            <summary>
            This constructor does nothing (does not call <see cref="M:Au.AInputBlocker.Start(Au.Types.BIEvents)"/>).
            </summary>
        </member>
        <member name="M:Au.AInputBlocker.#ctor(Au.Types.BIEvents)">
            <summary>
            This constructor calls <see cref="M:Au.AInputBlocker.Start(Au.Types.BIEvents)"/>.
            </summary>
            <exception cref="T:System.ArgumentException"><i>what</i> is 0.</exception>
        </member>
        <member name="M:Au.AInputBlocker.Start(Au.Types.BIEvents)">
            <summary>
            Starts blocking.
            </summary>
            <exception cref="T:System.ArgumentException"><i>what</i> is 0.</exception>
            <exception cref="T:System.InvalidOperationException">Already started.</exception>
        </member>
        <member name="M:Au.AInputBlocker.Dispose">
            <summary>
            Calls <see cref="M:Au.AInputBlocker.Stop(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Au.AInputBlocker.Finalize">
            
        </member>
        <member name="M:Au.AInputBlocker.Stop(System.Boolean)">
            <summary>
            Stops blocking.
            Plays back blocked keys if need. See <see cref="P:Au.AInputBlocker.ResendBlockedKeys"/>.
            Does nothing if currently is not blocking.
            </summary>
            <param name="discardBlockedKeys">Do not play back blocked key-down events recorded because of <see cref="P:Au.AInputBlocker.ResendBlockedKeys"/>.</param>
        </member>
        <member name="P:Au.AInputBlocker.ResumeAfterCtrlAltDelete">
            <summary>
            Continue blocking when returned from a special screen where blocking is disabled: Ctrl+Alt+Delete, [](xref:uac) consent, etc.
            </summary>
        </member>
        <member name="P:Au.AInputBlocker.ResendBlockedKeys">
            <summary>
            Record blocked keys, and play back when stopped blocking.
            </summary>
            <remarks>
            Will not play back if: 1. The blocking time is &gt; 10 seconds; then plays back only key-up events. 2. Detected Ctrl+Alt+Delete, [](xref:uac) consent or some other special screen. 3. Called <see cref="P:Au.AInputBlocker.Pause"/>.
            </remarks>
        </member>
        <member name="P:Au.AInputBlocker.DontBlockInjected">
            <summary>
            Don't block software-generated key/mouse events.
            If false (default), only events generated by functions of this library are not blocked.
            </summary>
        </member>
        <member name="P:Au.AInputBlocker.Pause">
            <summary>
            Gets or sets whether the blocking is paused.
            </summary>
            <remarks>
            The 'set' function is much faster than <see cref="M:Au.AInputBlocker.Stop(System.Boolean)"/>/<see cref="M:Au.AInputBlocker.Start(Au.Types.BIEvents)"/>. Does not remove hooks etc. Discards blocked keys.
            </remarks>
        </member>
        <member name="T:Au.AKeys">
            <summary>
            Keyboard functions: send virtual keystrokes and text to the active window, get key states.
            </summary>
            <remarks>
            The main function is <see cref="M:Au.AKeys.Key(System.Object[])"/>. Most documentation is there. See also <see cref="M:Au.AKeys.Text(System.String)"/>. These functions use <see cref="P:Au.AOpt.Key"/>. Alternatively can be used <b>AKeys</b> variables, see <see cref="M:Au.AKeys.#ctor(Au.Types.OptKey)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            AKeys.Key("Ctrl+Shift+Left"); //press Ctrl+Shift+Left
            
            AOpt.Key.KeySpeed = 300; //set options for static functions
            AKeys.Key("Ctrl+A Del Tab*3", (KText)"text", "Enter", 500); //press Ctrl+A, press Del, press Tab 3 times, send text, press Enter, wait 100 ms
            
            AKeys.Text("text\r\n"); //send text that ends with newline
            
            Text("Key and Text can be used without the \"AKeys.\" prefix.");
            Key("Enter");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AKeys.#ctor(Au.Types.OptKey)">
            <param name="cloneOptions">Options to be copied to <see cref="P:Au.AKeys.Options"/> of this variable. If null, uses default options.</param>
            <example>
            <code><![CDATA[
            var k = new AKeys(AOpt.Static.Key);
            k.Options.KeySpeed = 50;
            k.AddKeys("Tab // Space").AddRepeat(3).AddText("text").AddKey(KKey.Enter).AddSleep(500);
            k.Send(); //sends and clears the variable
            k.Add("Tab // Space*3", (KText)"text", KKey.Enter, 500); //the same as the above k.AddKeys... line
            for(int i = 0; i < 5; i++) k.Send(true); //does not clear the variable
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AKeys.Options">
            <summary>
            Options used by this variable.
            </summary>
        </member>
        <member name="M:Au.AKeys.AddKeys(System.String)">
            <summary>
            Adds keystrokes to the internal collection. They will be sent by <see cref="M:Au.AKeys.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="keys">Key names and operators. Example: <c>"Tab Ctrl+V Alt+(E P) Left*3 Space a , 5 #5 $abc"</c>. More info: <see cref="M:Au.AKeys.Key(System.Object[])"/>. Can be null or "".</param>
            <exception cref="T:System.ArgumentException">Error in <i>keys</i> string, for example an unknown key name.</exception>
        </member>
        <member name="M:Au.AKeys.AddKey(Au.Types.KKey,System.Nullable{System.Boolean})">
            <summary>
            Adds single key, specified as <see cref="T:Au.Types.KKey"/>, to the internal collection. It will be sent by <see cref="M:Au.AKeys.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="key">Virtual-key code, as <see cref="T:Au.Types.KKey"/> or int like <c>(KKey)200</c>. Valid values are 1-255.</param>
            <param name="down">true - key down; false - key up; null (default) - key down-up.</param>
            <exception cref="T:System.ArgumentException">Invalid <i>key</i> (0).</exception>
        </member>
        <member name="M:Au.AKeys.AddKey(Au.Types.KKey,System.Int32,System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Adds single key to the internal collection. Allows to specify scan code and whether it is an extended key. It will be sent by <see cref="M:Au.AKeys.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="key">Virtual-key code, as <see cref="T:Au.Types.KKey"/> or int like <c>(KKey)200</c>. Valid values are 1-255. Can be 0.</param>
            <param name="scanCode">Scan code of the physical key. Scan code values are 1-127, but this function allows 1-0xffff. Can be 0.</param>
            <param name="extendedKey">true if the key is an extended key.</param>
            <param name="down">true - key down; false - key up; null (default) - key down-up.</param>
            <exception cref="T:System.ArgumentException">Invalid scan code.</exception>
        </member>
        <member name="M:Au.AKeys.LibAddRaw(Au.Types.KKey,System.UInt16,System.Byte)">
            <summary>
            Adds key down or up event.
            </summary>
            <param name="vk"></param>
            <param name="scan"></param>
            <param name="siFlags">SendInput flags.</param>
        </member>
        <member name="M:Au.AKeys.LibSendBlocked(System.Boolean)">
            <summary>
            Sends key events added by AInputBlocker -> LibAddRaw.
            Simply calls Api.SendInput. No options, no sleep, etc.
            If new events added while sending, sends them too, until there are no new events added.
            </summary>
            <param name="onlyUp">Send only 'up' events.</param>
        </member>
        <member name="M:Au.AKeys.AddText(System.String)">
            <summary>
            Adds text. It will be sent by <see cref="M:Au.AKeys.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="text">Text. Can be null.</param>
            <remarks>
            To send text can be used keys or clipboard, depending on <see cref="P:Au.AOpt.Key"/> and text.
            </remarks>
        </member>
        <member name="M:Au.AKeys.AddAction(System.Action)">
            <summary>
            Adds a callback function.
            Returns self.
            </summary>
            <param name="a"></param>
            <remarks>
            The callback function will be called by <see cref="M:Au.AKeys.Send(System.Boolean)"/> and can do anything except sending keys and copy/paste.
            </remarks>
        </member>
        <member name="M:Au.AKeys.AddRepeat(System.Int32)">
            <summary>
            Adds the repeat-key operator. Then <see cref="M:Au.AKeys.Send(System.Boolean)"/> will send the last added key the specified number of times.
            Returns self.
            </summary>
            <param name="count">Repeat count.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>count</i> &gt;10000 or &lt;0.</exception>
            <exception cref="T:System.ArgumentException">The last added item is not key. Can repeat only single key; cannot repeat text etc.</exception>
        </member>
        <member name="M:Au.AKeys.AddSleep(System.Int32)">
            <summary>
            Adds a short pause. Then <see cref="M:Au.AKeys.Send(System.Boolean)"/> will sleep (wait).
            Returns self.
            </summary>
            <param name="timeMS">Time to sleep, milliseconds.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeMS</i> &gt;10000 (1 minute) or &lt;0.</exception>
        </member>
        <member name="M:Au.AKeys.Add(System.Object[])">
            <summary>
            Adds keystrokes, text, sleep and other events to the internal collection. They will be sent/executed by <see cref="M:Au.AKeys.Send(System.Boolean)"/>.
            Returns self.
            </summary>
            <param name="keysEtc">Arguments. The same as with <see cref="M:Au.AKeys.Key(System.Object[])"/>.</param>
            <exception cref="T:System.ArgumentException">An argument is of an unsupported type or has an invalid value, for example unknown key name.</exception>
        </member>
        <member name="M:Au.AKeys.Send(System.Boolean)">
            <summary>
            Sends keys, text and executes other events added with the <b>AddX</b> functions.
            </summary>
            <param name="canSendAgain">Don't clear the internal collection. If true, this function then can be called again (eg in loop) to send/execute the same keys etc. If false (default), clears the added keys etc; then you can call <b>AddX</b> functions and <b>Send</b> again.</param>
            <exception cref="T:System.ArgumentException"><i>canSendAgain</i> is true and keys end with + or (.</exception>
        </member>
        <member name="T:Au.AKeys.UI">
            <summary>
            Gets key states for using in UI code (forms, WPF).
            </summary>
            <remarks>
            Use functions of this class when processing user input events in user interface code (forms, WPF). In other code (automation scrits, etc) usually it's better to use functions of <see cref="T:Au.AKeys"/> class. Functions of this class are similar to .NET's <b>Control.ModifierKeys</b>, <b>Keyboard.Modifiers</b> etc, but may be easier to use.
            
            In Windows there are two API to get key state (down or up) - <msdn>GetKeyState</msdn> and <msdn>GetAsyncKeyState</msdn>. In most cases they return the same result, but not always.
            
            API <b>GetAsyncKeyState</b> is used by class <see cref="T:Au.AKeys"/> and not by this class (<b>AKeys.UI</b>). When the user (or some software) presses or releases a key, <b>GetAsyncKeyState</b> sees the change immediately. It is good in automation scripts, but not good in UI code because the state is not synchronized with the message queue.
            
            This class (<b>AKeys.UI</b>) uses API <msdn>GetKeyState</msdn>. In the foreground thread (of the active window), it sees key state changes not immediately but after the thread reads key messages from its queue. It is good in UI threads. In background threads this API usually works like <b>GetAsyncKeyState</b>, but it depends on API <msdn>AttachThreadInput</msdn> and in some cases is less reliable, for example may be unaware of keys pressed before the thread started.
            
            The key state returned by these API is not always the same as of the physical keyboard. There is no API to get physical state. The two most common cases when it is different:
            1. When the key is pressed or released by software, such as the <b>Key</b> function of this library.
            2. When the key is blocked by a low-level hook. For example, hotkey triggers of this library use hooks.
            
            Also there is API <msdn>GetKeyboardState</msdn>. It gets states of all keys in single call. Works like <b>GetKeyState</b>.
            </remarks>
        </member>
        <member name="M:Au.AKeys.UI.GetKeyState(Au.Types.KKey)">
            <summary>
            Calls API <msdn>GetKeyState</msdn> and returns its return value.
            </summary>
            <remarks>
            If returns &lt; 0, the key is down (pressed). If the low-order bit is 1, the key is toggled; it works only with CapsLock, NumLock, ScrollLock and several other keys, as well as mouse buttons.
            Can be used for mouse buttons too, for example <c>AKeys.UI.GetKeyState(KKey.MouseLeft)</c>. When mouse left and right buttons are swapped, gets logical state, not physical.
            </remarks>
        </member>
        <member name="M:Au.AKeys.UI.IsPressed(Au.Types.KKey)">
            <summary>
            Returns true if the specified key or mouse button is down (pressed).
            </summary>
            <remarks>
            Can be used for mouse buttons too, for example <c>AKeys.UI.IsPressed(KKey.MouseLeft)</c>. When mouse left and right buttons are swapped, gets logical state, not physical.
            </remarks>
        </member>
        <member name="P:Au.AKeys.UI.IsAlt">
            <summary>
            Returns true if the Alt key is down (pressed).
            </summary>
        </member>
        <member name="P:Au.AKeys.UI.IsCtrl">
            <summary>
            Returns true if the Ctrl key is down (pressed).
            </summary>
        </member>
        <member name="P:Au.AKeys.UI.IsShift">
            <summary>
            Returns true if the Shift key is down (pressed).
            </summary>
        </member>
        <member name="P:Au.AKeys.UI.IsWin">
            <summary>
            Returns true if the Win key is down (pressed).
            </summary>
        </member>
        <member name="M:Au.AKeys.UI.IsMod(Au.Types.KMod)">
            <summary>
            Returns true if some modifier keys are down (pressed).
            </summary>
            <param name="mod">Return true if some of these keys are down (pressed). Default: Ctrl, Shift or Alt.</param>
            <remarks>
            By default does not check the Win key, as it is not used in UI, but you can include it in <i>mod</i> if need.
            </remarks>
        </member>
        <member name="M:Au.AKeys.UI.GetMod(Au.Types.KMod)">
            <summary>
            Gets flags indicating which modifier keys are down (pressed).
            </summary>
            <param name="mod">Check only these keys. Default: Ctrl, Shift, Alt.</param>
            <remarks>
            By default does not check the Win key, as it is not used in UI, but you can include it in <i>mod</i> if need.
            </remarks>
        </member>
        <member name="P:Au.AKeys.UI.IsCapsLock">
            <summary>
            Returns true if the Caps Lock key is toggled.
            </summary>
            <remarks>
            The same as <see cref="P:Au.AKeys.IsCapsLock"/>.
            </remarks>
        </member>
        <member name="P:Au.AKeys.UI.IsNumLock">
            <summary>
            Returns true if the Num Lock key is toggled.
            </summary>
            <remarks>
            The same as <see cref="P:Au.AKeys.IsNumLock"/>.
            </remarks>
        </member>
        <member name="P:Au.AKeys.UI.IsScrollLock">
            <summary>
            Returns true if the Scroll Lock key is toggled.
            </summary>
            <remarks>
            The same as <see cref="P:Au.AKeys.IsScrollLock"/>.
            </remarks>
        </member>
        <member name="M:Au.AKeys.IsPressed(Au.Types.KKey)">
            <summary>
            Returns true if the specified key or mouse button is down (pressed).
            Not for UI code (forms, WPF).
            </summary>
            <remarks>
            Uses API <msdn>GetAsyncKeyState</msdn>.
            When processing user input in UI code (forms, WPF), instead use class <see cref="T:Au.AKeys.UI"/> or .NET functions. They use API <msdn>GetKeyState</msdn>.
            Can be used for mouse buttons too, for example <c>AKeys.IsPressed(KKey.MouseLeft)</c>. When mouse left and right buttons are swapped, gets logical state, not physical.
            </remarks>
        </member>
        <member name="P:Au.AKeys.IsAlt">
            <summary>
            Returns true if the Alt key is down (pressed). Calls <see cref="M:Au.AKeys.IsPressed(Au.Types.KKey)"/>.
            Not for UI code (forms, WPF).
            </summary>
        </member>
        <member name="P:Au.AKeys.IsCtrl">
            <summary>
            Returns true if the Ctrl key is down (pressed). Calls <see cref="M:Au.AKeys.IsPressed(Au.Types.KKey)"/>.
            Not for UI code (forms, WPF).
            </summary>
        </member>
        <member name="P:Au.AKeys.IsShift">
            <summary>
            Returns true if the Shift key is down (pressed). Calls <see cref="M:Au.AKeys.IsPressed(Au.Types.KKey)"/>.
            Not for UI code (forms, WPF).
            </summary>
        </member>
        <member name="P:Au.AKeys.IsWin">
            <summary>
            Returns true if the Win key is down (pressed). Calls <see cref="M:Au.AKeys.IsPressed(Au.Types.KKey)"/>.
            Not for UI code (forms, WPF).
            </summary>
        </member>
        <member name="M:Au.AKeys.IsMod(Au.Types.KMod)">
            <summary>
            Returns true if some modifier keys are down (pressed): Ctrl, Shift, Alt, Win. Calls <see cref="M:Au.AKeys.IsPressed(Au.Types.KKey)"/>.
            Not for UI code (forms, WPF).
            </summary>
            <param name="mod">Return true if some of these keys are pressed. Default - any (Ctrl, Shift, Alt or Win).</param>
            <seealso cref="M:Au.AKeys.WaitForNoModifierKeys(System.Double,Au.Types.KMod)"/>
        </member>
        <member name="M:Au.AKeys.GetMod(Au.Types.KMod)">
            <summary>
            Gets flags indicating which modifier keys are down (pressed): Ctrl, Shift, Alt, Win. Calls <see cref="M:Au.AKeys.IsPressed(Au.Types.KKey)"/>.
            Not for UI code (forms, WPF).
            </summary>
            <param name="mod">Check only these keys. Default - all four.</param>
        </member>
        <member name="P:Au.AKeys.IsCapsLock">
            <summary>
            Returns true if the Caps Lock key is toggled.
            </summary>
        </member>
        <member name="P:Au.AKeys.IsNumLock">
            <summary>
            Returns true if the Num Lock key is toggled.
            </summary>
        </member>
        <member name="P:Au.AKeys.IsScrollLock">
            <summary>
            Returns true if the Scroll Lock key is toggled.
            </summary>
        </member>
        <member name="M:Au.AKeys.WaitForNoModifierKeys(System.Double,Au.Types.KMod)">
            <summary>
            Waits while some modifier keys (Ctrl, Shift, Alt, Win) are down (pressed). See <see cref="M:Au.AKeys.IsMod(Au.Types.KMod)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="mod">Check only these keys. Default: all.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.AKeys.WaitForNoModifierKeysAndMouseButtons(System.Double,Au.Types.KMod,Au.Types.MButtons)">
            <summary>
            Waits while some modifier keys (Ctrl, Shift, Alt, Win) or mouse buttons are down (pressed).
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="mod">Check only these keys. Default: all.</param>
            <param name="buttons">Check only these buttons. Default: all.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <seealso cref="M:Au.AKeys.IsMod(Au.Types.KMod)"/>
            <seealso cref="M:Au.AMouse.IsPressed(Au.Types.MButtons)"/>
            <seealso cref="M:Au.AMouse.WaitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.AKeys.WaitForReleased(System.Double,Au.Types.KKey[])">
            <summary>
            Waits while the specified keys or/and mouse buttons are down (pressed).
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="keys">One or more keys or/and mouse buttons. Waits until all are released.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.AKeys.WaitForReleased(System.Double,System.String)">
            <summary>
            Waits while the specified keys are down (pressed).
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="keys">One or more keys. Waits until all are released. String like with <see cref="M:Au.AKeys.Key(System.Object[])"/>, without operators.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.ArgumentException">Error in keys string.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.AKeys.WaitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)">
            <summary>
            Registers a temporary hotkey and waits for it.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="hotkey">See <see cref="M:Au.ARegisteredHotkey.Register(System.Int32,Au.Types.KHotkey,Au.Types.AnyWnd)"/>.</param>
            <param name="waitModReleased">Also wait until hotkey modifier keys released.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.ArgumentException">Error in hotkey string.</exception>
            <exception cref="T:Au.Types.AuException">Failed to register hotkey.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            Uses <see cref="T:Au.ARegisteredHotkey"/>; it uses API <msdn>RegisterHotKey</msdn>.
            Fails if the hotkey is currently registered by this or another application or used by Windows. Also if F12.
            </remarks>
            <example>
            <code><![CDATA[
            AKeys.WaitForHotkey(0, "F11");
            AKeys.WaitForHotkey(0, KKey.F11);
            AKeys.WaitForHotkey(0, "Shift+A", true);
            AKeys.WaitForHotkey(0, (KMod.Ctrl | KMod.Shift, KKey.P)); //Ctrl+Shift+P
            AKeys.WaitForHotkey(0, Keys.Control | Keys.Alt | Keys.H); //Ctrl+Alt+H
            AKeys.WaitForHotkey(5, "Ctrl+Win+K"); //exception after 5 s
            if(!AKeys.WaitForHotkey(-5, "Left")) Print("timeout"); //returns false after 5 s
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AKeys.WaitForKey(System.Double,Au.Types.KKey,System.Boolean,System.Boolean)">
            <summary>
            Waits for key-down or key-up event of the specified key.
            </summary>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="key">Wait for this key.</param>
            <param name="up">Wait for key-up event.</param>
            <param name="block">Make the event invisible for other apps. If <i>up</i> is true, makes the down event invisible too, if it comes while waiting for the up event.</param>
            <exception cref="T:System.ArgumentException"><i>key</i> is 0.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            Unlike <see cref="M:Au.AKeys.WaitForReleased(System.Double,Au.Types.KKey[])"/>, waits for key event, not for key state.
            Uses low-level keyboard hook. Can wait for any single key. See also <see cref="M:Au.AKeys.WaitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)"/>.
            Ignores key events injected by functions of this library.
            </remarks>
            <example>
            <code><![CDATA[
            AKeys.WaitForKey(0, KKey.Ctrl, up: false, block: true);
            Print("Ctrl");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AKeys.WaitForKey(System.Double,System.String,System.Boolean,System.Boolean)">
            <summary>
            Waits for key-down or key-up event of the specified key.
            </summary>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout"></param>
            <param name="key">Wait for this key. A single-key string like with <see cref="M:Au.AKeys.Key(System.Object[])"/>.</param>
            <param name="up"></param>
            <param name="block"></param>
            <exception cref="T:System.ArgumentException">Invalid <i>key</i> string.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <example>
            <code><![CDATA[
            AKeys.WaitForKey(0, "Ctrl", up: false, block: true);
            Print("Ctrl");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AKeys.WaitForKey(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Waits for key-down or key-up event of any key, and gets the key code.
            </summary>
            <returns>
            Returns the key code. On timeout returns 0 if <i>secondsTimeout</i> is negative; else exception.
            For modifier keys returns the left or right key code, for example LCtrl/RCtrl, not Ctrl.
            </returns>
            <param name="secondsTimeout"></param>
            <param name="up"></param>
            <param name="block"></param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <example>
            <code><![CDATA[
            var key = AKeys.WaitForKey(0, up: true, block: true);
            Print(key);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AKeys.More">
            <summary>
            Miscellaneous rarely used keyboard-related functions.
            </summary>
        </member>
        <member name="M:Au.AKeys.More.GetTextCursorRect(Au.Types.RECT@,Au.AWnd@,System.Boolean)">
            <summary>
            Gets text cursor (caret) position and size.
            Returns false if fails.
            </summary>
            <param name="r">Receives the rectangle, in screen coordinates.</param>
            <param name="w">Receives the control that contains the text cursor.</param>
            <param name="orMouse">If fails, get mouse pointer coodinates.</param>
            <remarks>
            Can get only standard text cursor. Many apps use non-standard cursor; then fails.
            Also fails if the text cursor currently is not displayed.
            </remarks>
        </member>
        <member name="M:Au.AKeys.More.ParseKeyName(System.String)">
            <summary>
            Converts key name to <see cref="T:Au.Types.KKey"/>.
            Returns 0 if unknown key name.
            </summary>
            <param name="keyName">Key name, like with <see cref="M:Au.AKeys.Key(System.Object[])"/>.</param>
        </member>
        <member name="M:Au.AKeys.More.LibParseKeyNameThrow(System.String)">
            <summary>
            Calls <see cref="M:Au.AKeys.More.ParseKeyName(System.String)"/> and throws ArgumentException if invalid key string.
            </summary>
            <param name="keyName"></param>
        </member>
        <member name="M:Au.AKeys.More.ParseKeyName(System.String,System.Int32,System.Int32)">
            <summary>
            Converts key name to <see cref="T:Au.Types.KKey"/>.
            Returns 0 if unknown key name.
            </summary>
            <param name="s">String containing key name, like with <see cref="M:Au.AKeys.Key(System.Object[])"/>.</param>
            <param name="startIndex">Key name start index in <i>s</i>.</param>
            <param name="length">Key name length.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid start index or length.</exception>
        </member>
        <member name="M:Au.AKeys.More.ParseKeysString(System.String)">
            <summary>
            Converts keys string to <see cref="T:Au.Types.KKey"/> array.
            </summary>
            <param name="keys">String containing one or more key names, like with <see cref="M:Au.AKeys.Key(System.Object[])"/>. Operators are not supported.</param>
            <exception cref="T:System.ArgumentException">Error in keys string.</exception>
        </member>
        <member name="M:Au.AKeys.More.ParseHotkeyString(System.String,Au.Types.KMod@,Au.Types.KKey@)">
            <summary>
            Converts hotkey string to <see cref="T:Au.Types.KKey"/> and <see cref="T:Au.Types.KMod"/>.
            For example, if s is "Ctrl+Left", sets mod=KMod.Ctrl, key=KKey.Left.
            Returns false if the string is invalid.
            </summary>
            <remarks>
            Key names are like with <see cref="M:Au.AKeys.Key(System.Object[])"/>.
            Must be single non-modifier key, preceded by zero or more of modifier keys Ctrl, Shift, Alt, Win, all joined with +.
            Valid hotkey examples: <c>"A"</c>, <c>"a"</c>, <c>"7"</c>, <c>"F12"</c>, <c>"."</c>, <c>"End"</c>, <c>"Ctrl+D"</c>, <c>"Ctrl+Alt+Shift+Win+Left"</c>, <c>" Ctrl + U "</c>.
            Invalid hotkey examples: null, "", <c>"A+B"</c>, <c>"Ctrl+A+K"</c>, <c>"A+Ctrl"</c>, <c>"Ctrl+Shift"</c>, <c>"Ctrl+"</c>, <c>"NoSuchKey"</c>, <c>"tab"</c>.
            </remarks>
        </member>
        <member name="M:Au.AKeys.More.ParseHotkeyString(System.String,System.Windows.Forms.Keys@)">
            <summary>
            Converts hotkey string to <see cref="T:System.Windows.Forms.Keys"/>.
            For example, if s is <c>"Ctrl+Left"</c>, sets hotkey=Keys.Control|Keys.Left.
            Returns false if the string is invalid.
            </summary>
        </member>
        <member name="M:Au.AKeys.More.LibParseHotkeyTriggerString(System.String,Au.Types.KMod@,Au.Types.KMod@,Au.Types.KKey@,System.Boolean)">
            <summary>
            Used for parsing of hotkey triggers and mouse trigger modifiers.
            Like <see cref="M:Au.AKeys.More.ParseHotkeyString(System.String,Au.Types.KMod@,Au.Types.KKey@)"/>, but supports 'any mod' (like "Shift?+K" or "?+K") and <i>noKey</i>.
            <i>noKey</i> - s can contain only modifiers, not key. If false, s must be "key" or "mod+key", else returns false. Else s must be "mod" or null/"", else returns false.
            </summary>
        </member>
        <member name="M:Au.AKeys.More.KModToKeys(Au.Types.KMod)">
            <summary>
            Converts modifier key flags from <b>KMod</b> to <b>Keys</b>.
            </summary>
            <remarks>
            For Win returns flag (Keys)0x80000.
            </remarks>
        </member>
        <member name="M:Au.AKeys.More.KModFromKeys(System.Windows.Forms.Keys)">
            <summary>
            Converts modifier key flags from <b>Keys</b> to <b>KMod</b>.
            </summary>
            <remarks>
            For Win can be used flag (Keys)0x80000.
            </remarks>
        </member>
        <member name="M:Au.AKeys.Key(System.Object[])">
            <summary>
            Sends virtual keystrokes to the active window. Also can send text, wait, etc.
            </summary>
            <param name="keysEtc">
            Any number of arguments of these types:
            - string - keys. One or more key names separated by spaces or operators. More info in Remarks.
            <br/>Example: <c>Key("Enter A Ctrl+A");</c>
            <br/>See <see cref="M:Au.AKeys.AddKeys(System.String)"/>.
            - <see cref="T:Au.Types.KText"/> - literal text, like function <see cref="M:Au.AKeys.Text(System.String)"/>.
            <br/>Example: <c>Key((KText)"user", "Tab", (KText)"password", "Enter");</c>
            <br/>Uses virtual keystrokes or the clipboard, depending on <see cref="P:Au.AOpt.Key"/> and text.
            <br/>See <see cref="M:Au.AKeys.AddText(System.String)"/>.
            - <see cref="T:Au.Types.KKey"/> - a single key.
            <br/>Example: <c>Key("Shift+", KKey.Left, "*3");</c> is the same as <c>Key("Shift+Left*3");</c>.
            <br/>See <see cref="M:Au.AKeys.AddKey(Au.Types.KKey,System.Nullable{System.Boolean})"/>.
            - int - milliseconds to sleep. Max 10000.
            <br/>Example: <c>Key("Left", 500, "Right");</c>
            <br/>See <see cref="M:Au.AKeys.AddSleep(System.Int32)"/>.
            - <see cref="T:System.Action"/> - callback function.
            <br/>Example: <c>Action click = () => AMouse.Click(); Key("Shift+", click);</c>
            <br/>See <see cref="M:Au.AKeys.AddAction(System.Action)"/>.
            - null or "" - nothing.
            - (int, bool) - a single key, specified using scan code and extended-key flag.
            <br/>Example: <c>Key((0x3B, false)); //key F1</c>
            <br/>See <see cref="M:Au.AKeys.AddKey(Au.Types.KKey,System.Int32,System.Boolean,System.Nullable{System.Boolean})"/>.
            - (KKey, int, bool) - a single key, specified using <see cref="T:Au.Types.KKey"/> and/or scan code and extended-key flag.
            <br/>Example: <c>Key((KKey.Enter, 0, true)); //numpad Enter</c>
            <br/>See <see cref="M:Au.AKeys.AddKey(Au.Types.KKey,System.Int32,System.Boolean,System.Nullable{System.Boolean})"/>.
            </param>
            <exception cref="T:System.ArgumentException">An argument is of an unsupported type or has an invalid value, for example an unknown key name.</exception>
            <remarks>
            Generates virtual keystrokes. Uses API <msdn>SendInput</msdn>. It works almost like real keyboard.
            
            Usually keys are specified in string, like in this example:
            <code><![CDATA[Key("A F2 Ctrl+Shift+A Enter*2"); //keys A, F2, Ctrl+Shift+A, Enter Enter
            ]]></code>
            
            Key names:
            <table>
            <tr>
            <th>Group</th>
            <th>Keys</th>
            <th>Info</th>
            </tr>
            <tr>
            <td>Named keys</td>
            <td>
            <b>Modifier:</b> <c>Alt</c>, <c>Ctrl</c>, <c>Shift</c>, <c>Win</c>, <c>RAlt</c>, <c>RCtrl</c>, <c>RShift</c>, <c>RWin</c>
            <br/><b>Navigate:</b> <c>Esc</c>, <c>End</c>, <c>Home</c>, <c>PgDn</c>, <c>PgUp</c>, <c>Down</c>, <c>Left</c>, <c>Right</c>, <c>Up</c>
            <br/><b>Other:</b> <c>Back</c>, <c>Del</c>, <c>Enter</c>, <c>Menu</c>, <c>Pause</c>, <c>PrtSc</c>, <c>Space</c>, <c>Tab</c>
            <br/><b>Function:</b> <c>F1</c>-<c>F24</c>
            <br/><b>Lock:</b> <c>CapsLock</c>, <c>NumLock</c>, <c>ScrollLock</c>, <c>Ins</c>
            </td>
            <td>Start with an uppercase character. Only the first 3 characters are significant; others can be any ASCII letters. For example, can be <c>"Back"</c>, <c>"Bac"</c>, <c>"Backspace"</c> or <c>"BACK"</c>, but not <c>"back"</c> or <c>"Ba"</c> or <c>"Back5"</c>.
            <br/>
            <br/>Alias: <c>AltGr</c> (RAlt), <c>App</c> (Menu), <c>PageDown</c> or <c>PD</c> (PgDn), <c>PageUp</c> or <c>PU</c> (PgUp), <c>PrintScreen</c> or <c>PS</c> (PrtSc), <c>BS</c> (Back), <c>PB</c> (Pause/Break), <c>CL</c> (CapsLock), <c>NL</c> (NumLock), <c>SL</c> (ScrollLock), <c>HM</c> (Home).
            </td>
            </tr>
            <tr>
            <td>Text keys</td>
            <td>
            <b>Alphabetic:</b> <c>A</c>-<c>Z</c> (or <c>a</c>-<c>z</c>)
            <br/><b>Number:</b> <c>0</c>-<c>9</c>
            <br/><b>Numeric keypad:</b> <c>#/</c> <c>#*</c> <c>#-</c> <c>#+</c> <c>#.</c> <c>#0</c>-<c>#9</c>
            <br/><b>Other:</b> <c>`</c> <c>-</c> <c>=</c> <c>[</c> <c>]</c> <c>\</c> <c>;</c> <c>'</c> <c>,</c> <c>.</c> <c>/</c>
            </td>
            <td>Spaces between keys are optional, except for uppercase A-Z. For example, can be <c>"A B"</c>, <c>"a b"</c>, <c>"A b"</c> or <c>"ab"</c>, but not <c>"AB"</c> or <c>"Ab"</c>.
            <br/>
            <br/>For <c>`</c> <c>-</c> <c>[</c> <c>]</c> <c>\</c> <c>;</c> <c>'</c> <c>,</c> <c>.</c> <c>/</c> also can be used <c>~</c> <c>_</c> <c>{</c> <c>}</c> <c>|</c> <c>:</c> <c>"</c> <c>&lt;</c> <c>&gt;</c> <c>?</c>.
            </td>
            </tr>
            <tr>
            <td>Other keys</td>
            <td>Names of enum <see cref="T:Au.Types.KKey"/> members.</td>
            <td>Start with an uppercase character.
            <br/>Example: <c>Key("BrowserBack"); //KKey.BrowserBack</c>
            </td>
            </tr>
            <tr>
            <td>Other keys</td>
            <td>Virtual-key codes.</td>
            <td>Start with VK or Vk.
            <br/>Example: <c>Key("VK65 VK0x42");</c>
            </td>
            </tr>
            <tr>
            <td>Forbidden</td>
            <td>Fn, Ctrl+Alt+Del, Win+L, some other</td>
            <td>Programs cannot press these keys.</td>
            </tr>
            <tr>
            <td>Special characters</td>
            <td>
            <b>Operator:</b> + * ( ) $
            <br/><b>Numpad key prefix:</b> #
            <br/><b>Reserved:</b> ! @ % ^ &amp;
            </td>
            <td>These characters cannot be used as keys. Use = 8 9 0 4 3 1 2 5 6 7.</td>
            </tr>
            </table>
            
            Operators:
            <table>
            <tr>
            <th>Operator</th>
            <th>Examples</th>
            <th>Description</th>
            </tr>
            <tr>
            <td><c>*n</c></td>
            <td><c>"Left*3"</c></td>
            <td>Press key n times, like <c>"Left Left Left"</c>.
            <br/>See <see cref="M:Au.AKeys.AddRepeat(System.Int32)"/>.
            </td>
            <tr>
            <td><c>*down</c></td>
            <td><c>"Ctrl*down"</c></td>
            <td>Press key and don't release.</td>
            </tr>
            <tr>
            <td><c>*up</c></td>
            <td><c>"Ctrl*up"</c></td>
            <td>Release key.</td>
            </tr>
            </tr>
            <tr>
            <td><c>+</c></td>
            <td><c>"Ctrl+Shift+A"</c><br/><c>"Alt+E+P"</c></td>
            <td>The same as <c>"Ctrl*down Shift*down A Shift*up Ctrl*up"</c> and <c>"Alt*down E*down P E*up Alt*up"</c>.</td>
            </tr>
            <tr>
            <td><c>+()</c></td>
            <td><c>"Alt+(E P)"</c></td>
            <td>The same as <c>"Alt*down E P Alt*up"</c>.
            <br/>Inside () cannot be used + and +().
            </td>
            </tr>
            <tr>
            <td><c>$</c></td>
            <td><c>"$text"</c></td>
            <td>$ is the same as Shift+.</td>
            </tr>
            </table>
            
            Operators and related keys can be in separate arguments. Examples: <c>Key("Shift+", KKey.A); Key(KKey.A, "*3");</c>.
            
            Uses <see cref="P:Au.AOpt.Key"/>:
            <table>
            <tr>
            <th>Option</th>
            <th>Default</th>
            <th>Changed</th>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.NoBlockInput"/></td>
            <td>false.
            Blocks user-pressed keys. Sends them afterwards.
            <br/>If the last argument is 'sleep', stops blocking before executing it; else stops blocking after executing all arguments.</td>
            <td>true.
            Does not block user-pressed keys.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.NoCapsOff"/></td>
            <td>false.
            If the CapsLock key is toggled, untoggles it temporarily (presses it before and after).</td>
            <td>true.
            Does not touch the CapsLock key.
            <br/>Alphabetic keys of "keys" arguments can depend on CapsLock. Text of "text" arguments doesn't depend on CapsLock, unless <see cref="P:Au.Types.OptKey.TextOption"/> is <see cref="F:Au.Types.KTextOption.Keys"/>.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.NoModOff"/></td>
            <td>false.
            Releases modifier keys (Alt, Ctrl, Shift, Win).
            <br/>Does it only at the start; later they cannot interfere, unless <see cref="P:Au.Types.OptKey.NoBlockInput"/> is true.</td>
            <td>true.
            Does not touch modifier keys.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.TextSpeed"/></td>
            <td>0 ms.</td>
            <td>0 - 1000.
            Changes the speed for "text" arguments (makes slower).</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.KeySpeed"/></td>
            <td>1 ms.</td>
            <td>0 - 1000.
            Changes the speed for "keys" arguments (makes slower if &gt;1).</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.KeySpeedClipboard"/></td>
            <td>5 ms.</td>
            <td>0 - 1000.
            Changes the speed of Ctrl+V keys when text is pasted using the clipboard.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.SleepFinally"/></td>
            <td>10 ms.</td>
            <td>0 - 10000.
            <br/>Tip: to sleep finally, also can be used code like this: <c>Key("keys", 1000);</c>.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.TextOption"/></td>
            <td><see cref="F:Au.Types.KTextOption.Characters"/></td>
            <td><see cref="F:Au.Types.KTextOption.Keys"/> (send keys and Shift) or <see cref="F:Au.Types.KTextOption.Paste"/> (use clipboard).</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.PasteLength"/></td>
            <td>300.
            <br/>This option is used for "text" arguments. If text length &gt;= this value, uses the clipboard.</td>
            <td>&gt;=0.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.PasteEnter"/></td>
            <td>false.
            <br/>This option is used for "text" arguments when using the clipboard.
            </td>
            <td>true.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.RestoreClipboard"/></td>
            <td>true.
            Restore clipboard data (by default only text).
            <br/>This option is used for "text" arguments when using the clipboard.</td>
            <td>false.
            Don't restore clipboard data.</td>
            </tr>
            <tr>
            <td><see cref="P:Au.Types.OptKey.Hook"/></td>
            <td>null.</td>
            <td>Callback function that can modify options depending on active window etc.</td>
            </tr>
            </table>
            
            When you don't want to use or modify <see cref="P:Au.AOpt.Key"/>, you can use a <see cref="T:Au.AKeys"/> variable instead of this function. Example: <c>new AKeys(null).Add("keys", (KText)"text").Send();</c>. More examples in <see cref="M:Au.AKeys.#ctor(Au.Types.OptKey)"/> topic.
            
            This function does not wait until the target app receives and processes sent keystrokes and text; there is no reliable way to know it. It just adds small delays depending on options (<see cref="P:Au.Types.OptKey.SleepFinally"/> etc). If need, change options or add 'sleep' arguments or wait after calling this function. Sending text through the clipboard normally does not have these problems.
            
            This function should not be used to automate windows of own thread. It may work or not. Call it from another thread. See the last example.
            
            Administrator and uiAccess processes don't receive keystrokes sent by standard user processes. See [](xref:uac).
            
            Mouse button codes/names (eg <see cref="F:Au.Types.KKey.MouseLeft"/>) cannot be used to click. Instead use callback, like in the "Ctrl+click" example.
            </remarks>
            <example>
            <code><![CDATA[
            //Press key Enter.
            AKeys.Key("Enter");
            
            //The same as above. The "AKeys." prefix is optional.
            Key("Enter");
            
            //Press keys Ctrl+A.
            Key("Ctrl+A");
            
            //Ctrl+Alt+Shift+Win+A.
            Key("Ctrl+Alt+Shift+Win+A");
            
            //Alt down, E, P, Alt up.
            Key("Alt+(E P)");
            
            //Alt down, E, P, Alt up.
            Key("Alt*down E P Alt*up");
            
            //Press key End, key Backspace 3 times, send text "Text".
            Key("End Back*3", (KText)"Text");
            
            //Press Tab n times, send text "user", press Tab, send text "password", press Enter.
            int n = 5;
            Key($"Tab*{n}", (KText)"user", "Tab", (KText)"password", "Enter");
            
            //Send text "Text".
            Text("Text");
            
            //Press Ctrl+V, wait 500 ms, press Enter.
            Key("Ctrl+V", 500, "Enter");
            
            //F2, Ctrl+K, Left 3 times, Space, A, comma, 5, numpad 5, Shift+A, B, C, BrowserBack.
            Key("F2 Ctrl+K Left*3 Space a , 5 #5 $abc", KKey.BrowserBack);
            
            //Shift down, A 3 times, Shift up.
            Key("Shift+A*3");
            
            //Shift down, A 3 times, Shift up.
            Key("Shift+", KKey.A, "*3");
            
            //Shift down, A, wait 500 ms, B, Shift up.
            Key("Shift+(", KKey.A, 500, KKey.B, ")");
            
            //Send keys and text slowly.
            AOpt.Key.KeySpeed = AOpt.Key.TextSpeed = 50;
            Key("keys$:Space 123456789 Space 123456789 ,Space", (KText)"text: 123456789 123456789\n");
            
            //Ctrl+click
            Action click = () => AMouse.Click();
            Key("Ctrl+", click);
            
            //Ctrl+drag
            Action drag = () => { using(AMouse.LeftDown()) AMouse.MoveRelative(0, 50); };
            Key("Ctrl+", drag);
            
            //Ctrl+drag, poor man's version
            Key("Ctrl*down");
            using(AMouse.LeftDown()) AMouse.MoveRelative(0, 50);
            Key("Ctrl*up");
            ]]></code>
            Show form and send keys/text to it when button clicked.
            <code><![CDATA[
            var f = new Form();
            var b = new Button { Text = "Key" };
            var t = new TextBox { Top = 100 };
            var c = new Button { Text = "Close", Left = 100 };
            f.Controls.Add(b);
            f.Controls.Add(t);
            f.Controls.Add(c); f.CancelButton = c;
            
            b.Click += async (unu, sed) =>
            {
            	//Key("Tab", (KText)"text", 2000, "Esc"); //no
            	await Task.Run(() => { Key("Tab", (KText)"text", 2000, "Esc"); }); //use other thread
            };
            
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AKeys.Text(System.String)">
            <summary>
            Sends text to the active window, using virtual keystrokes or the clipboard.
            </summary>
            <param name="text">Text to send.</param>
            <remarks>
            Uses virtual keystrokes or the clipboard, depending on <see cref="P:Au.AOpt.Key"/> and text.
            To send text and keys use function <see cref="M:Au.AKeys.Key(System.Object[])"/>.
            </remarks>
            <seealso cref="M:Au.AClipboard.PasteText(System.String,Au.Types.OptKey)"/>
            <example>
            <code><![CDATA[
            AKeys.Text("Text.\r\n");
            AKeys.Key((KText)"Send this text and press key", "Enter");
            Text("Can be used without the \"AKeys.\" prefix.\n");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AKeys._KeynameToKey(System.String,System.Int32,System.Int32)">
            <summary>
            Converts part of string to <see cref="T:Au.Types.KKey"/>.
            The substring should contain single key name, eg "Esc", "A", "=".
            Returns 0 if invalid key name.
            </summary>
        </member>
        <member name="T:Au.AKeys.Lib">
            <summary>
            Internal static functions.
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.Sleep(System.Int32)">
            <summary>
            Calls ATime.SleepDoEvents.
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.LimitSleepTime(System.Int32)">
            <summary>
            If t &gt; 10, returns (t / 4 + 8).
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.KeyToMod(Au.Types.KKey)">
            <summary>
            If k is Shift, Ctrl, Alt or Win or their left/right versions, returns it as modifier flag, eg KMod.Shift.
            Else returns 0.
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.VkToSc(Au.Types.KKey,Au.Types.LPARAM)">
            <summary>
            Gets scan code from virtual-key code.
            </summary>
            <param name="vk"></param>
            <param name="hkl">Keyboard layout. If default(LPARAM), uses of current thread.</param>
        </member>
        <member name="M:Au.AKeys.Lib.SendKeyEventRaw(Au.Types.KKey,System.UInt16,System.UInt32)">
            <summary>
            Sends one key event.
            Just calls API SendInput with raw parameters.
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.SendKey(Au.Types.KKey,System.Int32)">
            <summary>
            Sends key.
            Not used for keys whose scancode can depend on keyboard layout. To get scancode, uses keyboard layout of current thread.
            </summary>
            <param name="k"></param>
            <param name="downUp">1 down, 2 up, 0 down-up.</param>
        </member>
        <member name="M:Au.AKeys.Lib.ModPressRelease(System.Boolean,Au.Types.KMod)">
            <summary>
            Presses or releases one or more modifier keys.
            Sends in this order: Ctrl, Alt, Shift, Win.
            </summary>
            <param name="press"></param>
            <param name="mod">Modifier keys. Does nothing if 0.</param>
        </member>
        <member name="M:Au.AKeys.Lib.ReleaseModAndCapsLock(Au.Types.OptKey)">
            <summary>
            Releases modifier keys if pressed and no option NoModOff. Turns off CapsLock if toggled and no option NoCapsOff.
            When releasing modifiers, if pressed Alt or Win without Ctrl, presses-releases Ctrl to avoid menu mode.
            Returns true if turned off CapsLock.
            Does not sleep, blockinput, etc.
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.ReleaseModAndDisableModMenu">
            <summary>
            Releases modifier keys if pressed.
            If pressed Alt or Win without Ctrl, presses-releases Ctrl to avoid menu mode.
            Does not use options, sleep, blockinput, etc.
            </summary>
        </member>
        <member name="T:Au.AKeys.Lib.SendCopyPaste">
            <summary>
            Sends Ctrl+V or Ctrl+C or Ctrl+X, and/or optionally Enter.
            Caller gets opt and wFocus with _GetOptionsAndWndFocused (it may want to know some options too).
            Caller calls Press, waits until the target app gets clipboard data, then calls Release.
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.SendCopyPaste.Press(Au.Types.KKey,Au.Types.OptKey,Au.AWnd,System.Boolean)">
            <summary>
            Presses Ctrl+key. Does not release.
            If enter is true, Release will press Enter.
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.SendCopyPaste.Release">
            <summary>
            Releases keys.
            Does nothing if already released.
            </summary>
        </member>
        <member name="M:Au.AKeys.Lib.SendCopyPaste.Enter(Au.Types.OptKey)">
            <summary>
            Sends Enter.
            </summary>
        </member>
        <member name="M:Au.AKeys._GetOptionsAndWndFocused(Au.AWnd@,System.Boolean)">
            <summary>
            Returns OptKey of this variable or OptKey cloned from this variable and possibly modified by Hook.
            </summary>
            <param name="wFocus">receives the focused or active window. Also the function uses it to avoid frequent calling of Hook.</param>
            <param name="getWndAlways">if false, the caller does not need wFocus. Then wFocus will be default(AWnd) if Hook is null.</param>
        </member>
        <member name="M:Au.AKeys._GetOptions(Au.AWnd)">
            <summary>
            Returns OptKey of this variable or OptKey cloned from this variable and possibly modified by Hook.
            </summary>
            <param name="wFocus">the focused or active window. The function uses it to avoid frequent calling of Hook. If you don't have it, use _GetOptionsAndWndFocused instead.</param>
        </member>
        <member name="M:Au.AKeys.LibKeyTypes.IsMod(Au.Types.KKey)">
            <summary>
            Ctrl, LCtrl, etc.
            </summary>
        </member>
        <member name="M:Au.AKeys.LibKeyTypes.IsGetKeyStateReliable(Au.Types.KKey)">
            <summary>
            API GetKeyState always works.
            For other keys returns 0 if pressed or toggled before starting current thread.
            Modifiers (left/right too), xLock, mouse, some other.
            </summary>
        </member>
        <member name="M:Au.AKeys.LibKeyTypes.IsToggleable(Au.Types.KKey)">
            <summary>
            The same as <see cref="M:Au.AKeys.LibKeyTypes.IsGetKeyStateReliable(Au.Types.KKey)"/>.
            </summary>
        </member>
        <member name="T:Au.AMouse">
            <summary>
            Mouse functions.
            </summary>
            <remarks>
            Should not be used to click windows of own thread. It may work or not. If need, use another thread. Example in <see cref="M:Au.AKeys.Key(System.Object[])"/>.
            </remarks>
        </member>
        <member name="P:Au.AMouse.XY">
            <summary>
            Gets cursor (mouse pointer) position.
            </summary>
        </member>
        <member name="P:Au.AMouse.X">
            <summary>
            Gets cursor (mouse pointer) X coordinate (AMouse.XY.x).
            </summary>
        </member>
        <member name="P:Au.AMouse.Y">
            <summary>
            Gets cursor (mouse pointer) Y coordinate (AMouse.XY.y).
            </summary>
        </member>
        <member name="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Moves the cursor (mouse pointer) to the position x y relative to window w.
            </summary>
            <returns>Cursor position in primary screen coordinates.</returns>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:Au.Types.AuWndException">
            - Invalid window.
            - The top-level window is hidden. No exception if just cloaked, for example in another desktop; then on click will activate, which usually uncloaks.
            - Other window-related failures.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the specified x y.</exception>
            <remarks>
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed"/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OptMouse.Relaxed"/>.
            </remarks>
        </member>
        <member name="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Moves the cursor (mouse pointer) to the specified position in screen.
            </summary>
            <returns>Normalized cursor position.</returns>
            <param name="x">X coordinate.</param>
            <param name="y">Y coordinate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the specified x y.</exception>
            <remarks>
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed"/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OptMouse.Relaxed"/>.
            
            May fail to move the cursor to the specified x y. Some reasons:
            - Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc).
            - The active window belongs to a process of higher [](xref:uac) integrity level.
            - Some application called API ClipCursor. No exception if option <b>Relaxed</b> is true (then final cursor position is undefined).
            </remarks>
        </member>
        <member name="M:Au.AMouse.Move(Au.Types.POINT)">
            <summary>
            Moves the cursor (mouse pointer) to the specified position in screen.
            </summary>
            <param name="p">Coordinates.
            <note type="tip">When need coordinates relative to a non-primary screen or/and the work area, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen,System.Boolean,System.Boolean)"/> or tuple (x, y, workArea) etc. Example: <c>AMouse.Move((x, y, true));</c>.</note>
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the specified x y.</exception>
            <remarks>
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed"/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OptMouse.Relaxed"/>.
            </remarks>
            <example>
            Save-restore mouse position.
            <code><![CDATA[
            var p = AMouse.XY;
            //...;
            AMouse.Move(p);
            ]]></code>
            Use coodinates in the first non-primary screen.
            <code><![CDATA[
            AMouse.Move(Coord.Normalize(10, 10, screen: 1));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AMouse.Save">
            <summary>
            Remembers current mouse cursor position to be later restored with <see cref="M:Au.AMouse.Restore"/>.
            </summary>
        </member>
        <member name="M:Au.AMouse.Restore">
            <summary>
            Moves the mouse cursor where it was at the time of the last <see cref="M:Au.AMouse.Save"/> call in this thread. If it was not called - of the first 'mouse move' or 'mouse click' function call in this thread. Does nothing if these functions were not called.
            </summary>
            <remarks>
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OptMouse.Relaxed"/>.
            </remarks>
        </member>
        <member name="P:Au.AMouse.LastXY">
            <summary>
            Mouse cursor position of the most recent successful 'mouse move' or 'mouse click' function call in this thread.
            If such functions are still not called in this thread, returns <see cref="P:Au.AMouse.XY"/>.
            </summary>
        </member>
        <member name="M:Au.AMouse.MoveRelative(System.Int32,System.Int32)">
            <summary>
            Moves the cursor (mouse pointer) relative to <see cref="P:Au.AMouse.LastXY"/>.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="dx">X offset from <b>LastXY.x</b>.</param>
            <param name="dy">Y offset from <b>LastXY.y</b>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The calculated x y is not in screen. No exception if option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move the cursor to the calculated x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher [](xref:uac) integrity level; 3. Some application called API ClipCursor. No exception option <b>Relaxed</b> is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed"/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/>, <see cref="P:Au.Types.OptMouse.Relaxed"/>.
            </remarks>
        </member>
        <member name="M:Au.AMouse.MoveRecorded(System.String,System.Double)">
            <summary>
            Plays recorded mouse movements, relative to <see cref="P:Au.AMouse.LastXY"/>.
            Returns the final cursor position in primary screen coordinates.
            </summary>
            <param name="recordedString">String containing mouse movement data recorded by a recorder tool that uses <see cref="M:Au.Util.ARecording.MouseToString(System.Collections.Generic.IEnumerable{System.UInt32},System.Boolean)"/>.</param>
            <param name="speedFactor">Speed factor. For example, 0.5 makes 2 times faster.</param>
            <exception cref="T:System.FormatException">Invalid Base64 string.</exception>
            <exception cref="T:System.ArgumentException">The string is not compatible with this library version (recorded with a newer version and has additional options).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The last x y is not in screen. No exception option <b>Relaxed</b> is true (then moves to a screen edge).</exception>
            <exception cref="T:Au.Types.AuException">Failed to move to the last x y. Some reasons: 1. Another thread blocks or modifies mouse input (API BlockInput, mouse hooks, frequent API SendInput etc); 2. The active window belongs to a process of higher [](xref:uac) integrity level; 3. Some application called API ClipCursor. No exception option <b>Relaxed</b> is true (then final cursor position is undefined).</exception>
            <remarks>
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.Relaxed"/> (only for the last movement; always relaxed in intermediate movements).
            </remarks>
        </member>
        <member name="M:Au.AMouse._SendMove(Au.Types.POINT)">
            <summary>
            Sends single mouse movement event.
            x y are normal absolute coordinates.
            </summary>
        </member>
        <member name="M:Au.AMouse._SendButton(Au.Types.MButton,System.Boolean,Au.Types.POINT)">
            <summary>
            Sends single mouse button down or up event.
            Does not use the action flags of button.
            Applies SM_SWAPBUTTON.
            Also moves to p in the same API SendInput call.
            </summary>
        </member>
        <member name="M:Au.AMouse._SendRaw(Au.Types.Api.IMFlags,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calls Api.SendInput to send single mouse movement or/and button down or up or wheel event.
            Converts x, y and wheelTicks as need for MOUSEINPUT.
            For X buttons use Api.IMFlag.XDown|Api.IMFlag.X1 etc.
            If Api.IMFlag.Move, adds Api.IMFlag.Absolute.
            </summary>
        </member>
        <member name="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at position x y relative to window w.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="button">Button and action.</param>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuWndException">x y is not in the window (read more in Remarks).</exception>
            <remarks>
            To move the mouse cursor, calls <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed"/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/> (between moving and clicking), <see cref="P:Au.Types.OptMouse.ClickSpeed"/>, <see cref="P:Au.Types.OptMouse.ClickSleepFinally"/>, <see cref="P:Au.Types.OptMouse.Relaxed"/>.
            If after moving the cursor it is not in the window (or a window of its thread), activates the window (or its top-level parent window). Throws exception if then x y is still not in the window. Skips all this when just releasing button or if option <b>Relaxed</b> is true. Also, if it is a control, x y can be somewhere else in its top-level parent window.
            </remarks>
        </member>
        <member name="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at the specified position in screen.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="button">Button and action.</param>
            <param name="x">X coordinate.</param>
            <param name="y">Y coordinate.</param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
            <remarks>
            To move the mouse cursor, calls <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.MoveSpeed"/>, <see cref="P:Au.Types.OptMouse.MoveSleepFinally"/> (between moving and clicking), <see cref="P:Au.Types.OptMouse.ClickSpeed"/>, <see cref="P:Au.Types.OptMouse.ClickSleepFinally"/>, <see cref="P:Au.Types.OptMouse.Relaxed"/>.
            </remarks>
        </member>
        <member name="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.POINT)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button at the specified position in screen.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="button">Button and action.</param>
            <param name="p">Coordinates.
            <note type="tip">When need coordinates relative to a non-primary screen or/and the work area, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen,System.Boolean,System.Boolean)"/> or tuple (x, y, workArea) etc. Example: <c>AMouse.ClickEx(MButton.Right, (x, y, true));</c>.</note>
            </param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)">
            <summary>
            Clicks, double-clicks, presses or releases a mouse button.
            By default does not move the mouse cursor.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="button">Button and action. Default: left click.</param>
            <param name="useLastXY">
            Use <see cref="P:Au.AMouse.LastXY"/>. It is the mouse cursor position set by the most recent 'mouse move' or 'mouse click' function called in this thread. Use this option for reliability.
            Example: <c>AMouse.Move(100, 100); AMouse.ClickEx(..., true);</c>. The click is always at 100 100, even if somebody changes cursor position between <c>AMouse.Move</c> sets it and <c>AMouse.ClickEx</c> uses it. In such case this option atomically moves the cursor to <b>LastXY</b>. This movement is instant and does not use <see cref="T:Au.AOpt"/>.
            If false (default), clicks at the current cursor position (does not move it).
            </param>
            <exception cref="T:System.ArgumentException">Invalid button flags (multiple buttons or actions specified).</exception>
            <remarks>
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.ClickSpeed"/>, <see cref="P:Au.Types.OptMouse.ClickSleepFinally"/>.
            </remarks>
        </member>
        <member name="M:Au.AMouse.Click(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button click at position x y relative to window w.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.Click(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button click at position x y.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.Click(System.Boolean)">
            <summary>
            Left button click.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.AMouse.LastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.AMouse.RightClick(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button click at position x y relative to window w.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.RightClick(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button click at position x y.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.RightClick(System.Boolean)">
            <summary>
            Right button click.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.AMouse.LastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.AMouse.DoubleClick(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button double click at position x y relative to window w.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.DoubleClick(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button double click at position x y.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.DoubleClick(System.Boolean)">
            <summary>
            Left button double click.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.AMouse.LastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.AMouse.LeftDown(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left down (press and don't release) at position x y relative to window w.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.LeftDown(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button down (press and don't release) at position x y.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.LeftDown(System.Boolean)">
            <summary>
            Left button down (press and don't release).
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="useLastXY">Use <see cref="P:Au.AMouse.LastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.AMouse.LeftUp(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Left button up (release pressed button) at position x y relative to window w.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.LeftUp(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Left button up (release pressed button) at position x y.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.LeftUp(System.Boolean)">
            <summary>
            Left button up (release pressed button).
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.AMouse.LastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.AMouse.RightDown(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button down (press and don't release) at position x y relative to window w.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
            <exception cref="T:Au.Types.AuException">x y is not in the window. More info: <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.RightDown(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button down (press and don't release) at position x y.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.RightDown(System.Boolean)">
            <summary>
            Right button down (press and don't release).
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <returns>The return value can be used to auto-release the pressed button. Example: <see cref="T:Au.Types.MRelease"/>.</returns>
            <param name="useLastXY">Use <see cref="P:Au.AMouse.LastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.AMouse.RightUp(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)">
            <summary>
            Right button up (release pressed button) at position x y relative to window w.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. More info there.
            </summary>
            <param name="w">Window or control.</param>
            <param name="x">X coordinate relative to the client area of w. Default - center.</param>
            <param name="y">Y coordinate relative to the client area of w. Default - center.</param>
            <param name="nonClient">x y are relative to the top-left of the window rectangle.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.RightUp(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Right button up (release pressed button) at position x y.
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,Au.Types.Coord,Au.Types.Coord)"/>. More info there.
            </summary>
            <param name="x">X coordinate in the screen.</param>
            <param name="y">Y coordinate in the screen.</param>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AMouse.Move(Au.Types.Coord,Au.Types.Coord)"/>.</exception>
        </member>
        <member name="M:Au.AMouse.RightUp(System.Boolean)">
            <summary>
            Right button up (release pressed button).
            Calls <see cref="M:Au.AMouse.ClickEx(Au.Types.MButton,System.Boolean)"/>. More info there.
            </summary>
            <param name="useLastXY">Use <see cref="P:Au.AMouse.LastXY"/>, not current cursor position.</param>
        </member>
        <member name="M:Au.AMouse.Wheel(System.Int32,System.Boolean)">
            <summary>
            Mouse wheel forward or backward.
            </summary>
            <param name="ticks">Number of wheel ticks forward (positive) or backward (negative).</param>
            <param name="horizontal">Horizontal wheel.</param>
            <remarks>
            Uses <see cref="P:Au.AOpt.Mouse"/>: <see cref="P:Au.Types.OptMouse.ClickSleepFinally"/>.
            </remarks>
        </member>
        <member name="M:Au.AMouse.IsPressed(Au.Types.MButtons)">
            <summary>
            Returns true if some mouse buttons are down (pressed).
            </summary>
            <param name="buttons">Return true if some of these buttons are down. Default: any (Left, Right, Middle, X1 or X2).</param>
            <remarks>
            Uses API <msdn>GetAsyncKeyState</msdn>.
            When processing user input in UI code (forms, WPF), instead use class <see cref="T:Au.AKeys.UI"/> or .NET functions. They use API <msdn>GetKeyState</msdn>.
            When mouse left and right buttons are swapped, gets logical state, not physical.
            </remarks>
            <seealso cref="M:Au.AMouse.WaitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.AMouse.WaitForNoButtonsPressed(System.Double,Au.Types.MButtons)">
            <summary>
            Waits while some mouse buttons are down (pressed). See <see cref="M:Au.AMouse.IsPressed(Au.Types.MButtons)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="buttons">Wait only for these buttons. Default - all.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <seealso cref="M:Au.AKeys.WaitForNoModifierKeysAndMouseButtons(System.Double,Au.Types.KMod,Au.Types.MButtons)"/>
        </member>
        <member name="M:Au.AMouse.LibWaitForNoButtonsPressed">
            <summary>
            Waits while some buttons are down (pressed), except those pressed by a <see cref="T:Au.AMouse"/> class function in this thread.
            Does nothing option <b>Relaxed</b> is true.
            </summary>
        </member>
        <member name="M:Au.AMouse.WaitForClick(System.Double,Au.Types.MButtons,System.Boolean,System.Boolean)">
            <summary>
            Waits for button-down or button-up event of the specified mouse button or buttons.
            </summary>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="button">Mouse button. If several buttons specified, waits for any of them.</param>
            <param name="up">Wait for button-up event.</param>
            <param name="block">Make the event invisible for other apps. If <i>up</i> is true, makes the down event invisible too, if it comes while waiting for the up event.</param>
            <exception cref="T:System.ArgumentException"><i>button</i> is 0.</exception>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            Unlike <see cref="M:Au.AMouse.WaitForNoButtonsPressed(System.Double,Au.Types.MButtons)"/>, waits for down or up event, not for button state.
            Uses low-level mouse hook.
            Ignores mouse events injected by functions of this library.
            </remarks>
            <example>
            <code><![CDATA[
            AMouse.WaitForClick(0, MButtons.Left, up: true, block: false);
            Print("click");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AMouse.WaitForClick(System.Double,System.Boolean,System.Boolean)">
            <summary>
            Waits for button-down or button-up event of any mouse button, and gets the button code.
            </summary>
            <returns>Returns the button code. On timeout returns 0 if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout"></param>
            <param name="up"></param>
            <param name="block"></param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <example>
            <code><![CDATA[
            var button = AMouse.WaitForClick(0, up: true, block: true);
            Print(button);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AMouse.WaitForCursor(System.Double,Au.Types.MCursor,System.Boolean)">
            <summary>
            Waits for a standard mouse cursor (pointer) visible.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="cursor">Id of a standard cursor.</param>
            <param name="not">Wait until this cursor disappears.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.AMouse.WaitForCursor(System.Double,System.Int64,System.Boolean)">
            <summary>
            Waits for a nonstandard mouse cursor (pointer) visible.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="cursorHash">Cursor hash, as returned by <see cref="M:Au.Util.ACursor.HashCursor(System.IntPtr)"/>.</param>
            <param name="not">Wait until this cursor disappears.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="T:Au.ARegisteredHotkey">
            <summary>
            Registers a hotkey using API <msdn>RegisterHotKey</msdn>. Unregisters when disposing.
            </summary>
            <remarks>
            Can be used as a lightweight alternative to hotkey triggers.
            
            The variable must be disposed, either explicitly (call <b>Dispose</b> or <b>Unregister</b>) or with the 'using' pattern.
            </remarks>
            <example>
            <code><![CDATA[
            static void TestRegisterHotkey()
            {
            	var f = new FormRegisterHotkey();
            	f.ShowDialog();
            }
            
            class FormRegisterHotkey :Form
            {
            	ARegisteredHotkey _hk1, _hk2;
            
            	protected override void WndProc(ref Message m)
            	{
            		switch(m.Msg) {
            		case 1: //WM_CREATE
            			bool r1 = _hk1.Register(1, "Ctrl+Alt+F10", this);
            			bool r2 = _hk2.Register(2, (KMod.Ctrl | KMod.Shift, KKey.D), this); //Ctrl+Shift+D
            			Print(r1, r2);
            			break;
            		case 2: //WM_DESTROY
            			_hk1.Unregister();
            			_hk2.Unregister();
            			break;
            		case ARegisteredHotkey.WM_HOTKEY:
            			Print(m.WParam);
            			break;
            		}
            		base.WndProc(ref m);
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegisteredHotkey.Register(System.Int32,Au.Types.KHotkey,Au.Types.AnyWnd)">
            <summary>
            Registers a hotkey using API <msdn>RegisterHotKey</msdn>.
            Returns false if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="id">Hotkey id. Must be 0 to 0xBFFF. It will be <i>wParam</i> of the <msdn>WM_HOTKEY</msdn> message.</param>
            <param name="hotkey">Hotkey. Can be: string like "Ctrl+Shift+Alt+Win+K", tuple (KMod, KKey), enum KKey, enum Keys, struct KHotkey.</param>
            <param name="window">Window/form that will receive the <msdn>WM_HOTKEY</msdn> message. Must be of this thread. If default, the message must be retrieved in the message loop of this thread.</param>
            <exception cref="T:System.ArgumentException">Error in hotkey string.</exception>
            <exception cref="T:System.InvalidOperationException">This variable already registered a hotkey.</exception>
            <remarks>
            Fails if the hotkey is currently registered by this or another application or used by Windows. Also if F12.
            A single variable cannot register multiple hotkeys simultaneously. Use multiple variables, for example array.
            </remarks>
            <seealso cref="M:Au.AKeys.WaitForHotkey(System.Double,Au.Types.KHotkey,System.Boolean)"/>
            <example>See <see cref="T:Au.ARegisteredHotkey"/>.</example>
        </member>
        <member name="M:Au.ARegisteredHotkey.Unregister">
            <summary>
            Unregisters the hotkey.
            </summary>
            <remarks>
            Called implicitly when disposing this variable.
            Must be called from the same thread as when registering, and the window must be still alive.
            If fails, calls <see cref="M:Au.AStatic.PrintWarning(System.String,System.Int32,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Au.ARegisteredHotkey.Dispose">
            <summary>
            Calls <see cref="M:Au.ARegisteredHotkey.Unregister"/>.
            </summary>
        </member>
        <member name="F:Au.ARegisteredHotkey.WM_HOTKEY">
            <summary>
            This message is posted to the window or to the thread's message loop.
            More info: <msdn>WM_HOTKEY</msdn>.
            </summary>
        </member>
        <member name="T:Au.AChar">
            <summary>
            Provides function to get ASCII character type (is digit etc) etc.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Char.IsDigit(System.Char)"/> etc, these functions never return true for non-ASCII characters. Also they are faster.
            </remarks>
        </member>
        <member name="M:Au.AChar.IsAsciiDigit(System.Char)">
            <summary>
            Returns true if character is '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.AChar.IsAsciiDigit(System.Byte)">
            <summary>
            Returns true if character is '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.AChar.IsAsciiAlpha(System.Char)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z'.
            </summary>
        </member>
        <member name="M:Au.AChar.IsAsciiAlpha(System.Byte)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z'.
            </summary>
        </member>
        <member name="M:Au.AChar.IsAsciiAlphaDigit(System.Char)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z' or '0' to '9'.
            </summary>
        </member>
        <member name="M:Au.AChar.IsAsciiAlphaDigit(System.Byte)">
            <summary>
            Returns true if character is 'A' to 'Z' or 'a' to 'z' or '0' to '9'.
            </summary>
        </member>
        <member name="T:Au.ADebug">
            <summary>
            Functions useful to debug code.
            </summary>
            <remarks>
            The ADebug.PrintX functions write to the same output as <see cref="M:Au.AOutput.Write(System.String)"/>, not to the trace listeners like <see cref="M:System.Diagnostics.Debug.Print(System.String)"/> etc do. Also they add caller's name, file and line number.
            Functions Print, PrintIf, PrintFunc and Dialog work only if DEBUG is defined, which normally is when the caller project is in Debug configuration. Else they are not called, and arguments not evaluated at run time. This is because they have [<see cref="T:System.Diagnostics.ConditionalAttribute"/>("DEBUG")].
            Note: when used in a library, the above functions depend on DEBUG of the library project and not on DEBUG of the consumer project of the library. For example, the library may be in Release configuration even if its consumer project is in Debug configuration. If your library wants to show some info only if its consumer project is in Debug config, instead you can use code like <c>if(AOpt.Debug.Verbose) PrintWarning("text");</c>; see <see cref="M:Au.AStatic.PrintWarning(System.String,System.Int32,System.String)"/>, AOpt.Debug.<see cref="P:Au.Types.OptDebug.Verbose"/>.
            </remarks>
        </member>
        <member name="M:Au.ADebug.Print(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.AOutput.Write(System.String)"/> to show some debug info. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            If text starts with "&lt;&gt;", it can contain Print tags.
            </summary>
        </member>
        <member name="M:Au.ADebug.PrintIf(System.Boolean,System.Object,System.String,System.Int32,System.String)">
            <summary>
            If condition is true, calls <see cref="M:Au.AOutput.Write(System.String)"/> to show some debug info. Also shows current function name/file/line.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            If text starts with "&lt;&gt;", it can contain Print tags.
            </summary>
        </member>
        <member name="M:Au.ADebug.PrintFunc(System.String)">
            <summary>
            Calls <see cref="M:Au.AOutput.Write(System.String)"/> with current function name.
            Works only if DEBUG is defined. Read more in class help.
            The optional argument is not used explicitly.
            </summary>
        </member>
        <member name="M:Au.ADebug.LibPrintNativeError(System.String,System.Int32,System.String)">
            <summary>
            In DEBUG config prints ALastError.Message.
            </summary>
        </member>
        <member name="M:Au.ADebug.LibPrintNativeError(System.Int32,System.String,System.Int32,System.String)">
            <summary>
            In DEBUG config prints ALastError.MessageFor(code).
            </summary>
        </member>
        <member name="M:Au.ADebug.Dialog(System.Object,System.String,System.Int32,System.String)">
            <summary>
            Calls <see cref="M:Au.ADialog.Show(System.String,System.String,System.String,Au.Types.DFlags,Au.Types.DIcon,Au.Types.AnyWnd,System.String)"/> to show some debug info.
            Works only if DEBUG is defined. Read more in class help.
            The 3 optional arguments are not used explicitly.
            </summary>
        </member>
        <member name="M:Au.ADebug.LibCheckFlagsOpt``1(``0,``0)">
            <summary>
            Checks flags and throws ArgumentException if some flags are invalid. The error message includes valid flag names.
            </summary>
            <param name="flags">Flags to check.</param>
            <param name="goodFlags">Valid flags.</param>
            <remarks>
            Can be used in functions that have an enum flags parameter but not all passed flags are valid for that function or object state.
            Does nothing if AOpt.Debug.<see cref="P:Au.Types.OptDebug.Verbose"/> == false.
            When flags are valid, this function is fast.
            </remarks>
        </member>
        <member name="P:Au.ADebug.IsAuDebugConfiguration">
            <summary>
            Returns true if using Debug configuration of Au.dll.
            </summary>
        </member>
        <member name="M:Au.ADebug.LibMemoryGet(System.Boolean)">
            <summary>
            Returns managed memory size as formatted string. Uses GC.GetTotalMemory.
            Works in Release too.
            </summary>
            <param name="fromAnchor">Get the difference from previous call to <b>LibMemorySetAnchor</b>.</param>
        </member>
        <member name="M:Au.ADebug.LibMemoryPrint(System.Boolean)">
            <summary>
            Prints managed memory size. Uses GC.GetTotalMemory.
            Works in Release too.
            </summary>
            <param name="fromAnchor">Get the difference from previous call to <b>LibMemorySetAnchor</b>.</param>
        </member>
        <member name="M:Au.ADebug.LibMemorySetAnchor">
            <summary>
            Memorizes current managed memory size, so that next call to another <b>LibMemoryX</b> function with fromAnchor=true (default) will get memory size difference from current memory size.
            </summary>
        </member>
        <member name="M:Au.ADebug.PrintLoadedAssemblies(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Prints assemblies already loaded or/and loaded in the future.
            </summary>
        </member>
        <member name="T:Au.AMath">
            <summary>
            Simple calculation functions.
            </summary>
        </member>
        <member name="M:Au.AMath.MakeUint(System.UInt32,System.UInt32)">
            <summary>
            Creates uint by placing (ushort)loWord in bits 1-16 and (ushort)hiWord in bits 17-32.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.AMath.MakeUint(System.Int32,System.Int32)">
            <summary>
            Creates uint by placing (ushort)loWord in bits 1-16 and (ushort)hiWord in bits 17-32.
            Like C macro MAKELONG, MAKEWPARAM, MAKELPARAM, MAKELRESULT.
            </summary>
        </member>
        <member name="M:Au.AMath.MakeUshort(System.UInt32,System.UInt32)">
            <summary>
            Creates ushort by placing (byte)loByte in bits 1-8 and (byte)hiByte in bits 9-16.
            Like C macro MAKEWORD.
            </summary>
        </member>
        <member name="M:Au.AMath.MakeUshort(System.Int32,System.Int32)">
            <summary>
            Creates ushort by placing (byte)loByte in bits 1-8 and (byte)hiByte in bits 9-16.
            Like C macro MAKEWORD.
            </summary>
        </member>
        <member name="M:Au.AMath.LoUshort(Au.Types.LPARAM)">
            <summary>
            Gets bits 1-16 as ushort.
            Like C macro LOWORD.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.AMath.HiUshort(Au.Types.LPARAM)">
            <summary>
            Gets bits 17-32 as ushort.
            Like C macro HIWORD.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.AMath.LoShort(Au.Types.LPARAM)">
            <summary>
            Gets bits 1-16 as short.
            Like C macro GET_X_LPARAM.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.AMath.HiShort(Au.Types.LPARAM)">
            <summary>
            Gets bits 17-32 as short.
            Like C macro GET_Y_LPARAM.
            </summary>
            <remarks>
            The parameter is interpreted as uint. Its declared type is LPARAM because it allows to avoid explicit casting from other integer types and IntPtr (casting from IntPtr to uint could throw OverflowException).
            </remarks>
        </member>
        <member name="M:Au.AMath.LoByte(System.UInt16)">
            <summary>
            Gets bits 1-8 as byte.
            Like C macro LOBYTE.
            </summary>
        </member>
        <member name="M:Au.AMath.HiByte(System.UInt16)">
            <summary>
            Gets bits 9-16 as byte.
            Like C macro HIBYTE.
            </summary>
        </member>
        <member name="M:Au.AMath.MulDiv(System.Int32,System.Int32,System.Int32)">
            <summary>
            Multiplies number and numerator without overflow, and divides by denominator.
            The return value is rounded up or down to the nearest integer.
            If either an overflow occurred or denominator was 0, the return value is 1.
            </summary>
        </member>
        <member name="M:Au.AMath.Percent(System.Int32,System.Int32)">
            <summary>
            Returns percent of part in whole.
            </summary>
        </member>
        <member name="M:Au.AMath.Percent(System.Double,System.Double)">
            <summary>
            Returns percent of part in whole.
            </summary>
        </member>
        <member name="M:Au.AMath.AlignUp(System.UInt32,System.UInt32)">
            <summary>
            If value is divisible by alignment, returns value. Else returns nearest bigger number that is divisible by alignment.
            </summary>
            <param name="value">An integer value.</param>
            <param name="alignment">Alignment. Must be a power of two (2, 4, 8, 16...).</param>
            <remarks>For example if alignment is 4, returns 4 if value is 1-4, returns 8 if value is 5-8, returns 12 if value is 9-10, and so on.</remarks>
        </member>
        <member name="M:Au.AMath.AlignUp(System.Int32,System.UInt32)">
            <summary>
            If value is divisible by alignment, returns value. Else returns nearest bigger number that is divisible by alignment.
            </summary>
            <param name="value">An integer value.</param>
            <param name="alignment">Alignment. Must be a power of two (2, 4, 8, 16...).</param>
            <remarks>For example if alignment is 4, returns 4 if value is 1-4, returns 8 if value is 5-8, returns 12 if value is 9-10, and so on.</remarks>
        </member>
        <member name="M:Au.AMath.MinMax(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns value but not less than min and not greater than max.
            If value is less than min, returns min.
            If value is greater than max, returns max.
            </summary>
        </member>
        <member name="M:Au.AMath.Swap``1(``0@,``0@)">
            <summary>
            Swaps values of variables a and b: <c>T t = a; a = b; b = t;</c>
            </summary>
        </member>
        <member name="M:Au.AMath.AngleFromXY(System.Int32,System.Int32)">
            <summary>
            Calculates angle degrees from coordinates x and y.
            </summary>
        </member>
        <member name="T:Au.AOsdWindow">
            <summary>
            Transparent window that can be used for on-screen display. Derived classes on it can draw non-transparent text, rectangle, image, anything.
            </summary>
        </member>
        <member name="M:Au.AOsdWindow.Dispose(System.Boolean)">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="M:Au.AOsdWindow.Dispose">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="M:Au.AOsdWindow.Close">
            <summary>Destroys the OSD window.</summary>
        </member>
        <member name="P:Au.AOsdWindow.Handle">
            <summary>OSD window handle or default(AWnd).</summary>
        </member>
        <member name="P:Au.AOsdWindow.IsHandleCreated">
            <summary>
            Returns true if the OSD window is created.
            </summary>
        </member>
        <member name="M:Au.AOsdWindow.Redraw">
            <summary>
            Redraws the OSD window immediately.
            Does nothing it is not created or not visible.
            </summary>
        </member>
        <member name="M:Au.AOsdWindow.Invalidate">
            <summary>
            Sets to redraw the OSD window later.
            Does nothing it is not created or not visible.
            </summary>
        </member>
        <member name="P:Au.AOsdWindow.Opacity">
            <summary>
            Gets or sets the opacity of the OSD window, from 0 to 1.
            If 1 (default), completely opaque. If 0, pixels of <see cref="P:Au.AOsdWindow.TransparentColor"/> are transparent, others opaque. If between 0 and 1, partially transparent.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsdWindow.TransparentColor">
            <summary>
            Gets or sets transparent color, default 0xF5F4F5. Pixels of this color will be transparent, unless <see cref="P:Au.AOsdWindow.Opacity"/> is not 0.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            Note: when used for transparent text, text edges are blended with this color, and it can become visible if the color is not chosen carefully.
            </remarks>
        </member>
        <member name="P:Au.AOsdWindow.Rect">
            <summary>
            Gets or sets OSD window size and position in screen.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsdWindow.Visible">
            <summary>
            Gets or sets whether the OSD window is visible.
            The 'set' function calls <see cref="M:Au.AOsdWindow.Show"/> (it creates OSD window if need) or <see cref="M:Au.AOsdWindow.Hide"/> (it does not destroy the OSD window).
            </summary>
        </member>
        <member name="M:Au.AOsdWindow.Show">
            <summary>
            Shows the OSD window. Creates if need.
            </summary>
            <remarks>
            In any case, also moves the window to the top of the Z order.
            </remarks>
        </member>
        <member name="M:Au.AOsdWindow.Hide">
            <summary>
            Hides the OSD window. Does not destroy; use <see cref="M:Au.AOsdWindow.Close"/> or <see cref="M:Au.AOsdWindow.Dispose(System.Boolean)"/> for it.
            Does nothing if not created or not visible.
            </summary>
        </member>
        <member name="M:Au.AOsdWindow.WndProc(Au.AWnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Called when the OSD window receives a message.
            If your derived class overrides this function, it must call base.WndProc and return its return value, except when don't need default processing.
            </summary>
        </member>
        <member name="M:Au.AOsdWindow.OnPaint(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Called when the OSD window must be drawn or redrawn.
            Derived classes should override this function and draw anything. Don't need to call base.OnPaint of <see cref="T:Au.AOsdWindow"/>, it does nothing.
            </summary>
            <remarks>
            If <see cref="P:Au.AOsdWindow.Opacity"/> is 0 (default), <i>g</i> is filled with <see cref="P:Au.AOsdWindow.TransparentColor"/>. Pixels of this color will be transparent. The base class draws only non-transparent areas.
            </remarks>
        </member>
        <member name="P:Au.AOsdWindow.Shadow">
            <summary>
            If true, the OSD window will have shadow.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsdWindow.ClickToClose">
            <summary>
            If true, the OSD window receive mouse messages. Only completely transparent areas don't. The user can click to close the OSD (left, right or middle button).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsdWindow.Name">
            <summary>
            OSD window name. Optional, default null.
            </summary>
            <remarks>
            This text is invisible. Can be used to find OSD window. The class name is "Au.OSD"; if with shadow - "Au.OSD2".
            </remarks>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.AOsdWindow.CloseAll(System.String)">
            <summary>
            Closes all OSD windows of this process.
            </summary>
            <param name="name">If not null, closes only OSD windows whose <see cref="P:Au.AOsdWindow.Name"/> matches this [](xref:wildcard_expression).</param>
        </member>
        <member name="T:Au.AOsdRect">
            <summary>
            Shows mouse-transparent rectangle on screen. Its interior can be visually transparent or opaque.
            </summary>
            <remarks>
            Creates a temporary partially transparent window, and draws rectangle in it.
            </remarks>
            <example>
            <code><![CDATA[
            using(var x = new AOsdRect()) {
            	x.Rect = (300, 300, 100, 100);
            	x.Color = Color.SlateBlue;
            	x.Thickness = 4;
            	x.Show();
            	for(int i = 0; i < 5; i++) {
            		250.ms();
            		x.Visible = !x.Visible;
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AOsdRect.#ctor">
            
        </member>
        <member name="P:Au.AOsdRect.Color">
            <summary>
            Gets or sets rectangle color.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
            <example>
            <code><![CDATA[
            x.Color = 0xFF0000; //red
            x.Color = Color.Orange;
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AOsdRect.Thickness">
            <summary>
            Gets or sets rectangle frame width.
            Used only if <see cref="P:Au.AOsdWindow.Opacity"/> is 0 (default).
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.AOsdRect.OnPaint(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Called when the OSD window must be drawn or redrawn. Draws rectangle. More info: <see cref="M:Au.AOsdWindow.OnPaint(System.Drawing.Graphics,System.Drawing.Rectangle)"/>.
            </summary>
        </member>
        <member name="T:Au.AOsd">
            <summary>
            Shows mouse-transparent text on screen. Its background can be visually transparent or opaque.
            </summary>
            <remarks>
            Creates a temporary partially transparent window, and draws text in it.
            Most properties cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.XY">
            <summary>
            Coordinates.
            Default: null - screen center.
            </summary>
            <remarks>
            Not used if <see cref="P:Au.AOsd.Rect"/> is set.
            This property can be changed after creating OSD window.
            </remarks>
            <example>
            <code><![CDATA[
            var m = new AOsd { Text = "Text", ShowMode = OsdShowMode.StrongThread };
            m.XY = (Coord.Center, Coord.Max); //bottom-center of the work area of the primary screen
            m.Show();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AOsd.Rect">
            <summary>
            Gets or sets OSD window size and position in screen.
            </summary>
            <remarks>
            Normally don't need to use this property. If not used, the OSD window size depends on text etc, and position on <see cref="P:Au.AOsd.XY"/>.
            This property can be changed after creating OSD window.
            </remarks>
            <seealso cref="M:Au.AOsd.Measure"/>
        </member>
        <member name="P:Au.AOsd.ResizeWhenContentChanged">
            <summary>
            When changing text, resize/move the OSD window if need.
            Default: false.
            </summary>
        </member>
        <member name="P:Au.AOsd.Text">
            <summary>
            Text in OSD window.
            </summary>
            <remarks>
            This property can be changed after creating OSD window; then the window is not moved/resized, unless <see cref="P:Au.AOsd.ResizeWhenContentChanged"/> is true.
            </remarks>
        </member>
        <member name="P:Au.AOsd.Font">
            <summary>
            Font.
            Default: <see cref="P:Au.AOsd.DefaultFont"/>.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.TextColor">
            <summary>
            Text color.
            Default: <see cref="P:Au.AOsd.DefaultTextColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.BackColor">
            <summary>
            Background color.
            Default: <see cref="P:Au.AOsd.DefaultBackColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            Not used for completely transparent OSD.
            </remarks>
        </member>
        <member name="P:Au.AOsd.BorderColor">
            <summary>
            Border color.
            Default: <see cref="P:Au.AOsd.DefaultBorderColor"/>.
            </summary>
            <remarks>
            This property can be changed after creating OSD window.
            No border if <see cref="P:Au.AOsdWindow.Opacity"/>==0 or <b>BorderColor</b>==<see cref="P:Au.AOsd.BackColor"/>.
            </remarks>
        </member>
        <member name="P:Au.AOsd.BackgroundImage">
            <summary>
            Background image.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.IsOfImageSize">
            <summary>
            When used <see cref="P:Au.AOsd.BackgroundImage"/>, the OSD window has the same size as the image, plus borders.
            Else OSD window size is calculated from sizes of text and icon. Then image is displayed scaled or clipped if need.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.WrapWidth">
            <summary>
            Maximal text width.
            Default: 0 - no limit (depends on screen width etc).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.TextFormatFlags">
            <summary>
            Gets or sets text format flags.
            Default: TextFormatFlags.NoPrefix | TextFormatFlags.WordBreak | TextFormatFlags.ExpandTabs.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.Icon">
            <summary>
            Icon at the left of text.
            For example SystemIcons.Information.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.Shadow">
            <summary>
            If true, the OSD window will have shadow.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            Window shadows can be disabled. See <msdn>SPI_SETDROPSHADOW</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AOsd.ClickToClose">
            <summary>
            If true, the OSD window receive mouse messages. Only completely transparent areas don't. The user can click to close the OSD (left, right or middle button).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.SecondsTimeout">
            <summary>
            Close the OSD window after this time, seconds.
            If 0 (default), depends on text length. Can be <see cref="F:System.Threading.Timeout.Infinite"/> (-1).
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="P:Au.AOsd.ShowMode">
            <summary>
            See <see cref="T:Au.Types.OsdShowMode"/>.
            </summary>
            <remarks>
            This property cannot be changed after creating OSD window.
            </remarks>
        </member>
        <member name="M:Au.AOsd.#ctor">
            
        </member>
        <member name="M:Au.AOsd.Show">
            <summary>
            Shows the OSD window. Creates if need.
            By default does not wait; the window will be closed after <see cref="P:Au.AOsd.SecondsTimeout"/>.
            </summary>
            <remarks>
            Depending on <see cref="P:Au.AOsd.ShowMode"/>, creates the OSD window in this or new thread.
            If the OSD window is already created, just shows it if hidden. Many properties can be changed only before creating OSD window; call <see cref="M:Au.AOsdWindow.Close"/> if need.
            </remarks>
        </member>
        <member name="M:Au.AOsd.OnPaint(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draws OSD text etc.
            </summary>
        </member>
        <member name="M:Au.AOsd.Measure">
            <summary>
            Calculates OSD window size and position.
            Can be called before showing OSD.
            </summary>
        </member>
        <member name="M:Au.AOsd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)">
            <summary>
            Shows a tooltip-like OSD window with text and optionally icon.
            </summary>
            <param name="text"><see cref="P:Au.AOsd.Text"/></param>
            <param name="secondsTimeout"><see cref="P:Au.AOsd.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.AOsd.XY"/></param>
            <param name="icon"><see cref="P:Au.AOsd.Icon"/></param>
            <param name="textColor"><see cref="P:Au.AOsd.TextColor"/></param>
            <param name="backColor"><see cref="P:Au.AOsd.BackColor"/></param>
            <param name="name"><see cref="P:Au.AOsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.AOsd.ShowMode"/></param>
            <param name="doNotShow">Don't call <see cref="M:Au.AOsd.Show"/>. The caller can use the return value to set some other properties and call <b>Show</b>.</param>
            <returns>Returns an <see cref="T:Au.AOsd"/> object that can be used to change properties or close the OSD window.</returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.AOsd.ClickToClose"/>=true, <see cref="P:Au.AOsd.Shadow"/>=true.
            </remarks>
        </member>
        <member name="M:Au.AOsd.ShowTransparentText(System.String,System.Int32,Au.Types.PopupXY,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)">
            <summary>
            Shows a big-font text with transparent background.
            </summary>
            <param name="text"><see cref="P:Au.AOsd.Text"/></param>
            <param name="secondsTimeout"><see cref="P:Au.AOsd.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.AOsd.XY"/></param>
            <param name="color"><see cref="P:Au.AOsd.TextColor"/>. Default: <see cref="P:Au.AOsd.DefaultTransparentTextColor"/>.</param>
            <param name="name"><see cref="P:Au.AOsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.AOsd.ShowMode"/></param>
            <param name="doNotShow">See <see cref="M:Au.AOsd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/>.</param>
            <returns>Returns an <see cref="T:Au.AOsd"/> object that can be used to change properties or close the OSD window.</returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.AOsd.Font"/>=<see cref="P:Au.AOsd.DefaultTransparentTextFont"/>, <see cref="P:Au.AOsdWindow.Opacity"/>=0.
            </remarks>
        </member>
        <member name="M:Au.AOsd.ShowImage(System.Drawing.Image,System.Int32,Au.Types.PopupXY,System.String,Au.Types.OsdShowMode,System.Boolean)">
            <summary>
            Shows on-screen image.
            </summary>
            <param name="image"><see cref="P:Au.AOsd.BackgroundImage"/></param>
            <param name="secondsTimeout"><see cref="P:Au.AOsd.SecondsTimeout"/></param>
            <param name="xy"><see cref="P:Au.AOsd.XY"/></param>
            <param name="name"><see cref="P:Au.AOsdWindow.Name"/></param>
            <param name="showMode"><see cref="P:Au.AOsd.ShowMode"/></param>
            <param name="doNotShow">See <see cref="M:Au.AOsd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/>.</param>
            <returns>Returns an <see cref="T:Au.AOsd"/> object that can be used to change properties or close the OSD window.</returns>
            <remarks>
            Also sets these properties: <see cref="P:Au.AOsd.IsOfImageSize"/>=true, <see cref="P:Au.AOsdWindow.Opacity"/>=0, <see cref="P:Au.AOsd.ClickToClose"/>=true.
            </remarks>
        </member>
        <member name="P:Au.AOsd.DefaultFont">
            <summary>Default font for <see cref="M:Au.AOsd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/> and <b>AOsd</b>. Default: <b>SystemFonts.MessageBoxFont</b> of size 12.</summary>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>The font object is cached, don't dispose.</remarks>
        </member>
        <member name="P:Au.AOsd.DefaultTextColor">
            <summary>Default text color for <see cref="M:Au.AOsd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/> and <b>AOsd</b>. Default: 0xFF404040 (dark gray).</summary>
        </member>
        <member name="P:Au.AOsd.DefaultBorderColor">
            <summary>Default border color for <see cref="M:Au.AOsd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/> and <b>AOsd</b>. Default: 0xFF404040 (dark gray).</summary>
        </member>
        <member name="P:Au.AOsd.DefaultBackColor">
            <summary>Default background color for <see cref="M:Au.AOsd.ShowText(System.String,System.Int32,Au.Types.PopupXY,System.Drawing.Icon,Au.Types.ColorInt,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/> and <b>AOsd</b>. Default: 0xFFFFFFF0 (light yellow).</summary>
        </member>
        <member name="P:Au.AOsd.DefaultTransparentTextFont">
            <summary>Default font for <see cref="M:Au.AOsd.ShowTransparentText(System.String,System.Int32,Au.Types.PopupXY,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/>. Default: "Tahoma" of size 18.</summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Au.AOsd.DefaultTransparentTextColor">
            <summary>Default text color for <see cref="M:Au.AOsd.ShowTransparentText(System.String,System.Int32,Au.Types.PopupXY,Au.Types.ColorInt,System.String,Au.Types.OsdShowMode,System.Boolean)"/>. Default: 0xFF8A2BE2 (Color.BlueViolet).</summary>
        </member>
        <member name="P:Au.AOsd.DefaultScreen">
            <summary>
            Default screen when <see cref="P:Au.AOsd.XY"/> is not set.
            Each thread has its own instance of this property.
            </summary>
        </member>
        <member name="T:Au.AOutput">
            <summary>
            Writes text to the output window, console or log file.
            </summary>
            <remarks>
            When <see cref="M:Au.AOutput.Write(System.String)"/>, <b>Print</b>, etc is called, where the text goes:
            - If redirected, to wherever it is redirected. See <see cref="P:Au.AOutput.Writer"/>.
            - Else if using log file (<see cref="P:Au.AOutput.LogFile"/> not null), writes to the file.
            - Else if using console (<see cref="P:Au.AOutput.IsWritingToConsole"/> returns true), writes to console.
            - Else if using local <see cref="T:Au.AOutputServer"/> (in this process), writes to it.
            - Else if exists global <see cref="T:Au.AOutputServer"/> (in any process), writes to it.
            - Else nowhere.
            </remarks>
        </member>
        <member name="P:Au.AOutput.IsConsoleProcess">
            <summary>
            Returns true if this is a console process.
            </summary>
        </member>
        <member name="P:Au.AOutput.IsWritingToConsole">
            <summary>
            Returns true if is writing to console, false if to the output window or log file. Assuming that <see cref="P:Au.AOutput.Writer"/> is not changed.
            </summary>
            <remarks>
            Does not write to console in these cases:
            - <see cref="P:Au.AOutput.IsConsoleProcess"/> is false.
            - <see cref="P:Au.AOutput.IgnoreConsole"/> is true.
            - <see cref="P:Au.AOutput.LogFile"/> is not null.
            - The startup info of this process tells to not show console window and to not redirect the standard output.
            </remarks>
        </member>
        <member name="P:Au.AOutput.IgnoreConsole">
            <summary>
            If true, Write and related functions in console process don't not use the console window. Then everything is like in non-console process.
            </summary>
            <seealso cref="P:Au.AOutput.RedirectConsoleOutput"/>
            <seealso cref="P:Au.AOutput.RedirectDebugOutput"/>
        </member>
        <member name="M:Au.AOutput.Clear">
            <summary>
            Clears the output window or console text (if <see cref="P:Au.AOutput.IsWritingToConsole"/>) or log file (if <see cref="P:Au.AOutput.LogFile"/> not null).
            </summary>
        </member>
        <member name="M:Au.AOutput.Write(System.String)">
            <summary>
            Writes text + <c>"\r\n"</c> to the output window or console (if <see cref="P:Au.AOutput.IsWritingToConsole"/>) or log file (if <see cref="P:Au.AOutput.LogFile"/> not null).
            </summary>
            <param name="value">
            Text.
            If "" or null, writes empty line.
            </param>
            <remarks>
            Can display links, colors, images, etc. More info: [](xref:print_tags).
            </remarks>
            <seealso cref="M:Au.AStatic.Print(System.String)"/>
            <seealso cref="M:Au.AStatic.Print(System.Object)"/>
            <seealso cref="M:Au.AStatic.Print``1(System.Collections.Generic.IEnumerable{``0})"/>
            <seealso cref="M:Au.AStatic.Print(System.Object,System.Object,System.Object[])"/>
        </member>
        <member name="P:Au.AOutput.Writer">
            <summary>
            Gets or sets object that actually writes text when is called <see cref="M:Au.AOutput.Write(System.String)"/>, <see cref="M:Au.AStatic.Print(System.String)"/> and similar functions.
            </summary>
            <remarks>
            If you want to redirect, modify or just monitor output text, use code like in the example. It is known as "output redirection".
            Redirection is applied to whole process, not just this thread.
            Redirection affects <see cref="M:Au.AOutput.Write(System.String)"/>, <see cref="M:Au.AStatic.Print(System.String)"/> and similar functions, also <see cref="P:Au.AOutput.RedirectConsoleOutput"/> and <see cref="P:Au.AOutput.RedirectDebugOutput"/>. It does not affect <see cref="M:Au.AOutput.WriteDirectly(System.String)"/> and <see cref="M:Au.AOutput.Clear"/>.
            Don't call <see cref="M:Au.AOutput.Write(System.String)"/>, <see cref="M:Au.AStatic.Print(System.String)"/> etc in method <b>WriteLine</b> of your writer class. It would call itself and create stack overflow. But you can call <see cref="M:Au.AOutput.WriteDirectly(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            [STAThread]
            static void Main()
            {
            	AOutput.Writer = new TestOutputWriter();
            
            	Print("test");
            }
            
            class TestOutputWriter :TextWriter
            {
            	public override void WriteLine(string value) { AOutput.WriteDirectly("redir: " + value); }
            	public override Encoding Encoding => Encoding.Unicode;
            }
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AOutput._OutputWriter">
            <summary>
            Our default writer class for the Writer property.
            </summary>
        </member>
        <member name="M:Au.AOutput.WriteDirectly(System.String)">
            <summary>
            Writes string value + "\r\n" to the output window or console (if <see cref="P:Au.AOutput.IsWritingToConsole"/>) or log file (if <see cref="P:Au.AOutput.LogFile"/> not null).
            Unlike <see cref="M:Au.AOutput.Write(System.String)"/>, <see cref="M:Au.AStatic.Print(System.String)"/> etc, the string is not passed to <see cref="P:Au.AOutput.Writer"/>.
            </summary>
        </member>
        <member name="P:Au.AOutput.RedirectConsoleOutput">
            <summary>
            Let <b>Console.WriteX</b> methods in non-console process write to the same destination as <see cref="M:Au.AOutput.Write(System.String)"/> etc.
            </summary>
            <remarks>
            <b>Console.Write</b> will write line, like <b>Console.WriteLine</b>.
            <b>Console.Clear</b> will not clear output; it will throw exception.
            </remarks>
        </member>
        <member name="P:Au.AOutput.RedirectDebugOutput">
            <summary>
            Let <b>Debug.WriteX</b> and <b>Trace.WriteX</b> methods write to the same destination as <see cref="M:Au.AOutput.Write(System.String)"/> etc.
            </summary>
            <remarks>
            Tip: To write to the output window even in console process, set <c>AOutput.IgnoreConsole=true;</c> before calling this method first time.
            </remarks>
        </member>
        <member name="P:Au.AOutput.LogFile">
            <summary>
            Sets log file path.
            When set (not null), text passed to <see cref="M:Au.AOutput.Write(System.String)"/>, <see cref="M:Au.AStatic.Print(System.String)"/> and similar functions will be written to the file. Assuming that <see cref="P:Au.AOutput.Writer"/> is not changed.
            If value is null - restores default behavior.
            </summary>
            <remarks>
            The first <see cref="M:Au.AOutput.Write(System.String)"/> etc call (in this process) creates or opens the file and deletes old content if the file already exists.
            
            Also supports mailslots. For <b>LogFile</b> use mailslot name, as documented in <msdn>CreateMailslot</msdn>. Multiple processes can use the same mailslot.
            </remarks>
            <exception cref="T:System.ArgumentException">The 'set' function throws this exception if the value is not full path and not null.</exception>
        </member>
        <member name="P:Au.AOutput.LogFileTimestamp">
            <summary>
            Let Write etc also add current time when using log file (see <see cref="P:Au.AOutput.LogFile"/>).
            The time is local, not UTC.
            </summary>
        </member>
        <member name="M:Au.AOutput._LogFile.Open">
            <summary>
            Opens LogFile file handle for writing.
            Uses CREATE_ALWAYS, GENERIC_WRITE, FILE_SHARE_READ.
            </summary>
        </member>
        <member name="M:Au.AOutput._LogFile.WriteLine(System.String)">
            <summary>
            Writes s + "\r\n" and optionally timestamp.
            </summary>
            <remarks>
            If fails to write to file: Sets LogFile=null, which closes file handle. Writes a warning and s to the output window or console.
            </remarks>
        </member>
        <member name="M:Au.AOutput._LogFile.Clear">
            <summary>
            Sets file size = 0.
            </summary>
        </member>
        <member name="M:Au.AOutput._LogFile.Close">
            <summary>
            Closes file handle.
            </summary>
        </member>
        <member name="M:Au.AOutput.LibCreateFile(System.String,System.Boolean)">
            <summary>
            Calls Api.CreateFile to open file or mailslot.
            </summary>
            <param name="name">File path or mailslot name.</param>
            <param name="openExisting">Use OPEN_EXISTING. If false, uses CREATE_ALWAYS.</param>
        </member>
        <member name="T:Au.AOutput.QM2">
            
        </member>
        <member name="P:Au.AOutput.QM2.UseQM2">
            <summary>
            Sets to use QM2 as the output server.
            </summary>
        </member>
        <member name="M:Au.AOutput.QM2.Clear">
            <summary>
            Clears QM2 output pane.
            </summary>
        </member>
        <member name="M:Au.AOutput.QM2.Write(System.Object)">
            <summary>
            Writes line to QM2.
            </summary>
        </member>
        <member name="M:Au.AOutput.QM2._WriteToQM2(System.String)">
            <param name="s">If null, clears output.</param>
        </member>
        <member name="T:Au.AOutputServer">
            <summary>
            Receives messages sent by <see cref="M:Au.AOutput.Write(System.String)"/> and related methods (<b>Print</b> etc).
            </summary>
            <remarks>
            If server is global, clients can be multiple processes, including this. Else only this process.
            Works asynchronously, to make writing messages faster.
            When a client writes a message, the message arrives to the server with some delay and is placed in a queue.
            You then can get/remove messages from the queue (call <see cref="M:Au.AOutputServer.GetMessage(Au.Types.OutServMessage@)"/>) and display them in a window (for example).
            You can be notified about new messages.
            
            Recommended setup (see example):
            1. When your application starts, create an <b>AOutputServer</b> instance and assign to a static variable. Call <see cref="M:Au.AOutputServer.Start"/>.
            2. When your application creates its output window, call <see cref="M:Au.AOutputServer.SetNotifications(System.Action,System.Windows.Forms.Control)"/> to register callback function.
            3. In the callback function get/remove/display all new messages.
            4. Call <see cref="M:Au.AOutputServer.Stop"/> when closing the window.
            </remarks>
            <example>
            Simple program with output window.
            <code><![CDATA[
            class OutputFormExample :Form
            {
            	TextBox _tb;
            
            	public OutputFormExample()
            	{
            		_tb = new TextBox();
            		_tb.ReadOnly = true;
            		_tb.Multiline = true;
            		_tb.ScrollBars = ScrollBars.Both;
            		_tb.WordWrap = false;
            		_tb.Dock = DockStyle.Fill;
            		_tb.TabStop = false;
            		this.Controls.Add(_tb);
            
            		_os.SetNotifications(_ProcessMessages, this);
            	}
            
            	void _ProcessMessages()
            	{
            		while(_os.GetMessage(out var m)) {
            			switch(m.Type) {
            			case OutServMessageType.Clear:
            				_tb.Clear();
            				break;
            			case OutServMessageType.Write:
            				//_tb.AppendText(m.Text);
            				_tb.AppendText($"{DateTime.FromFileTimeUtc(m.TimeUtc).ToLocalTime()}  {m.Caller}  {m.Text}");
            				break;
            			}
            		}
            	}
            
            	static AOutputServer _os = new AOutputServer(isGlobal: false);
            
            	[STAThread]
            	public static void Main()
            	{
            		_os.Start();
            
            		//test Print and Clear, before and after creating window
            		AOutput.IgnoreConsole = true;
            		Print("test before setting notifications");
            		Task.Run(() => { 1.s(); Print("test after"); 1.s(); AOutput.Clear(); 1.s(); Print("test after Clear"); });
            
            		Application.Run(new OutputFormExample());
            		_os.Stop();
            	}
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AOutputServer.#ctor(System.Boolean)">
            <param name="isGlobal">
            If true, will receive output from all processes that don't have local server.
            </param>
        </member>
        <member name="M:Au.AOutputServer.Start">
            <summary>
            Starts server.
            Returns false if server already exists (if global - in any process).
            </summary>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.AOutputServer.Stop">
            <summary>
            Stops server.
            </summary>
        </member>
        <member name="M:Au.AOutputServer.Finalize">
            <summary>
            Calls Stop.
            </summary>
        </member>
        <member name="M:Au.AOutputServer.SetNotifications(System.Action,System.Windows.Forms.Control)">
            <summary>
            Sets callback function, to be notified about server events.
            </summary>
            <param name="cbFunc">
            Callback function's delegate. Called when one or more messages are available.
            It should call <see cref="M:Au.AOutputServer.GetMessage(Au.Types.OutServMessage@)"/> until it returns false.
            See example in class help.
            </param>
            <param name="c">A control or form. The callback function will be called in its thread. If null, the callback function will be called in other thread.</param>
        </member>
        <member name="M:Au.AOutputServer.LibLocalWrite(System.String,System.Int64,System.String)">
            <summary>
            Adds s directly to _messages and sets timer.
            If s is null, it is 'Clear' command.
            Else if !NoNewline, appends "\r\n".
            Used with local server only.
            </summary>
        </member>
        <member name="M:Au.AOutputServer.GetMessage(Au.Types.OutServMessage@)">
            <summary>
            Gets next message and removes from the queue.
            Returns false if there are no messages.
            </summary>
            <remarks>
            Messages are added to an internal queue when clients call <see cref="M:Au.AOutput.Write(System.String)"/> etc. They contain the text, time, etc. This function gets the oldest message and removes it from the queue.
            </remarks>
        </member>
        <member name="P:Au.AOutputServer.MessageCount">
            <summary>
            Gets the count of messages in the queue.
            </summary>
        </member>
        <member name="P:Au.AOutputServer.NoNewline">
            <summary>
            Let messages don't end with "\r\n".
            </summary>
            <remarks>
            This can be used for performance, to avoid string copying when using local server. Does not affect performance of global server.
            </remarks>
        </member>
        <member name="P:Au.AOutputServer.LibMailslotName">
            <summary>
            Gets mailslot name like <c>@"\\.\mailslot\Au.AOutput\" + sessionId</c>.
            </summary>
        </member>
        <member name="P:Au.AOutputServer.LibTimerName">
            <summary>
            Gets waitable timer name like "timer.Au.AOutput".
            </summary>
        </member>
        <member name="T:Au.AOutputServer.LibSharedMemoryData">
            <summary>
            Shared memory variables. Used with global server only.
            </summary>
        </member>
        <member name="T:Au.AScreen">
            <summary>
            Used to specify a screen (aka display, monitor) using index, window, control, <see cref="T:Au.AAcc"/>, point, rectangle, <see cref="T:System.Windows.Forms.Screen"/>, <see cref="F:Au.AScreen.OfActiveWindow"/> or <see cref="F:Au.AScreen.OfMouse"/>.
            </summary>
            <remarks>
            Used mostly for function parameters. The caller can specify screen index (int), window (AWnd etc), <see cref="T:System.Windows.Forms.Screen"/> object, etc. There are implicit conversion operators from these types. The <b>AScreen</b> variable holds the specified value. When the function needs screen properties, it calls <see cref="M:Au.AScreen.GetScreen"/> to get <see cref="T:System.Windows.Forms.Screen"/> object corresponding that value at that time.
            </remarks>
        </member>
        <member name="M:Au.AScreen.op_Implicit(System.Windows.Forms.Screen)~Au.AScreen">
            <summary>
            Creates variable that holds <see cref="T:System.Windows.Forms.Screen"/> object. If invalid, will be used the primary screen.
            </summary>
        </member>
        <member name="M:Au.AScreen.op_Implicit(System.Int32)~Au.AScreen">
            <summary>
            Creates variable that holds screen index. Later will be called <see cref="M:Au.AScreen.ScreenFromIndex(System.Int32)"/>.
            </summary>
            <param name="screenIndex">See <see cref="M:Au.AScreen.ScreenFromIndex(System.Int32)"/>.</param>
        </member>
        <member name="M:Au.AScreen.op_Implicit(Au.AWnd)~Au.AScreen">
            <summary>
            Creates variable that holds window handle. Later will be called <see cref="M:Au.AScreen.ScreenFromWindow(Au.AWnd)"/>. If invalid, will be used the primary screen.
            </summary>
        </member>
        <member name="M:Au.AScreen.op_Implicit(System.Windows.Forms.Control)~Au.AScreen">
            <summary>
            Creates variable that holds <see cref="T:System.Windows.Forms.Control"/>. Later will be called <see cref="M:System.Windows.Forms.Screen.FromControl(System.Windows.Forms.Control)"/>.
            </summary>
        </member>
        <member name="M:Au.AScreen.op_Implicit(System.Windows.Window)~Au.AScreen">
            <summary>
            Creates variable that holds <see cref="T:System.Windows.Window"/>. Later will be called <see cref="M:Au.AScreen.ScreenFromWindow(Au.AWnd)"/>.
            </summary>
        </member>
        <member name="M:Au.AScreen.op_Implicit(Au.Types.POINT)~Au.AScreen">
            <summary>
            Creates variable that holds <see cref="T:Au.Types.POINT"/>. Later will be called <see cref="M:System.Windows.Forms.Screen.FromPoint(System.Drawing.Point)"/>.
            </summary>
        </member>
        <member name="M:Au.AScreen.op_Implicit(Au.Types.RECT)~Au.AScreen">
            <summary>
            Creates variable that holds <see cref="T:Au.Types.RECT"/>. Later will be called <see cref="M:System.Windows.Forms.Screen.FromRectangle(System.Drawing.Rectangle)"/>.
            </summary>
        </member>
        <member name="M:Au.AScreen.op_Implicit(Au.AAcc)~Au.AScreen">
            <summary>
            Creates variable that holds <see cref="T:Au.AAcc"/>. Later will be called <see cref="M:System.Windows.Forms.Screen.FromRectangle(System.Drawing.Rectangle)"/>.
            </summary>
        </member>
        <member name="F:Au.AScreen.Primary">
            <summary>
            Screen index of the primary screen. Value 0.
            Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            </summary>
        </member>
        <member name="F:Au.AScreen.OfMouse">
            <summary>
            Special screen index to specify the screen of the mouse pointer. Value -1.
            </summary>
        </member>
        <member name="F:Au.AScreen.OfActiveWindow">
            <summary>
            Special screen index to specify the screen of the active window. Value -2.
            </summary>
        </member>
        <member name="F:Au.AScreen.NonPrimary1">
            <summary>
            Screen index of the first non-primary screen. Value 1.
            Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            </summary>
        </member>
        <member name="F:Au.AScreen.NonPrimary2">
            <summary>
            Screen index of the second non-primary screen. Value 2.
            Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            </summary>
        </member>
        <member name="M:Au.AScreen.ScreenFromIndex(System.Int32)">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object from screen index.
            </summary>
            <param name="screenIndex">
            Values greater than 0 are used for non-primary screens: 1 - first non-primary, 2 second...
            Also can be <see cref="F:Au.AScreen.Primary"/> (0), <see cref="F:Au.AScreen.OfMouse"/> (-1), <see cref="F:Au.AScreen.OfActiveWindow"/> (-2).
            If invalid, prints warning and gets the primary screen.
            </param>
            <remarks>
            Uses <see cref="P:System.Windows.Forms.Screen.AllScreens"/> to get screen indices. They may not match the indices that you can see in Windows Settings.
            </remarks>
        </member>
        <member name="M:Au.AScreen.ScreenFromWindow(Au.AWnd)">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object of the screen that contains the specified window (the biggest part of it) or is nearest to it.
            </summary>
            <remarks>
            If the window handle is 0 or invalid, gets the primary screen. <see cref="M:System.Windows.Forms.Screen.FromHandle(System.IntPtr)"/> would return an invalid object.
            </remarks>
        </member>
        <member name="M:Au.AScreen.GetScreen">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object from the value stored in this variable (screen index, window handle, etc).
            If the value is null or invalid or fails, gets the primary screen.
            </summary>
            <remarks>
            Uses <see cref="P:System.Windows.Forms.Screen.AllScreens"/> to get screen indices. They may not match the indices that you can see in Windows Settings.
            </remarks>
        </member>
        <member name="P:Au.AScreen.Value">
            <summary>
            Gets the value as object.
            </summary>
        </member>
        <member name="P:Au.AScreen.IsNull">
            <summary>
            true if this variable does not have a value.
            </summary>
        </member>
        <member name="P:Au.AScreen.PrimaryWidth">
            <summary>
            Gets primary screen width.
            </summary>
        </member>
        <member name="P:Au.AScreen.PrimaryHeight">
            <summary>
            Gets primary screen height.
            </summary>
        </member>
        <member name="P:Au.AScreen.PrimaryRect">
            <summary>
            Gets primary screen rectangle.
            </summary>
        </member>
        <member name="M:Au.AScreen.GetRect(Au.AScreen,System.Boolean)">
            <summary>
            Gets screen rectangle.
            </summary>
            <param name="screen">Screen index etc. If default - primary screen.</param>
            <param name="workArea">Get work area rectangle.</param>
        </member>
        <member name="P:Au.AScreen.PrimaryWorkArea">
            <summary>
            Gets primary screen work area.
            </summary>
        </member>
        <member name="M:Au.AScreen.IsInAnyScreen(Au.Types.POINT)">
            <summary>
            Returns true if point p is in some screen.
            </summary>
        </member>
        <member name="M:Au.AScreen.IsInAnyScreen(Au.Types.RECT)">
            <summary>
            Returns true if rectangle r intersects with some screen.
            </summary>
        </member>
        <member name="M:Au.AScreen.IsInAnyScreen(Au.AWnd)">
            <summary>
            Returns true if rectangle of window w intersects with some screen.
            </summary>
        </member>
        <member name="T:Au.AWinImage">
            <summary>
            Captures, finds and clicks images and colors in windows.
            </summary>
            <remarks>
            An image is any visible rectangular part of a window. A color is any visible pixel (the same as image of size 1x1).
            A <b>AWinImage</b> variable holds results of <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/> and similar functions (rectangle etc).
            </remarks>
        </member>
        <member name="M:Au.AWinImage.LoadImage(System.String)">
            <summary>
            Loads image from file, string or resource.
            </summary>
            <param name="image">See <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>.</param>
            <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
            <exception cref="T:System.ArgumentException">Bad image format (the image cannot be loaded as Bitmap). Or Invalid Base64 string.</exception>
            <exception cref="T:System.Exception">Depending on <i>image</i> string format, exceptions of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>, <see cref="M:System.Drawing.Bitmap.#ctor(System.IO.Stream)"/>, <see cref="M:Au.Util.AConvert.Decompress(System.Byte[],System.Int32,System.Int32)"/>.</exception>
            <remarks>
            <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/> uses this function when <i>image</i> argument type is string. More info there.
            </remarks>
        </member>
        <member name="P:Au.AWinImage.Rect">
            <summary>
            Gets location of the found image, relative to the search area.
            </summary>
            <remarks>
            Relative to the window/control client area (if area type is AWnd), accessible object (if AAcc), image (if Bitmap) or screen (if RECT).
            More info: <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>.
            </remarks>
        </member>
        <member name="P:Au.AWinImage.RectInScreen">
            <summary>
            Gets location of the found image in screen coordinates.
            </summary>
            <remarks>
            Slower than <see cref="P:Au.AWinImage.Rect"/>.
            </remarks>
        </member>
        <member name="P:Au.AWinImage.MatchIndex">
            <summary>
            Gets 0-based index of current matching image instance.
            </summary>
            <remarks>
            Can be useful in <i>also</i> callback functions.
            When the <i>image</i> argument is a list of images, <b>MatchIndex</b> starts from 0 for each list image.
            </remarks>
        </member>
        <member name="P:Au.AWinImage.ListIndex">
            <summary>
            When the <i>image</i> argument is a list of images, gets 0-based index of the list image.
            </summary>
        </member>
        <member name="M:Au.AWinImage.Skip(System.Int32)">
            <summary>
            Can be used in <i>also</i> callback function to skip n matching images. Example: <c>also: o => o.Skip(n)</c>.
            </summary>
            <param name="n">How many matching images to skip.</param>
        </member>
        <member name="M:Au.AWinImage.ToString">
            
        </member>
        <member name="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})">
            <summary>
            Finds image(s) or color(s) displayed in window or other area.
            </summary>
            <returns>
            Returns a <see cref="T:Au.AWinImage"/> object that contains the rectangle of the found image and can click it etc.
            Returns null if not found. See example.
            </returns>
            <param name="area">
            Where to search. Can be a window/control, accessible object, another image or a rectangle in screen.
            - <see cref="T:Au.AWnd"/> - window or control. The search area is its client area.
            - <see cref="T:Au.AAcc"/> - accessible object.
            - <see cref="T:System.Drawing.Bitmap"/> - another image. These flags are invalid: <see cref="F:Au.Types.WIFlags.WindowDC"/>, <see cref="F:Au.Types.WIFlags.PrintWindow"/>.
            - <see cref="T:Au.Types.RECT"/> - a rectangle area in screen. These flags are invalid: <see cref="F:Au.Types.WIFlags.WindowDC"/>, <see cref="F:Au.Types.WIFlags.PrintWindow"/>.
            - <see cref="T:Au.Types.WIArea"/> - can contain AWnd, AAcc or Bitmap. Also allows to specify a rectangle in it, which makes the search area smaller and the function faster. Example: <c>AWinImage.Find((w, (left, top, width, height)), "image.png");</c>.
            </param>
            <param name="image">
            Image or color to find. Can be of type:
            - string - path of .png or .bmp file.
            <br/>If not full path, uses <see cref="P:Au.AFolders.ThisAppImages"/>.
            <br/>If the file does not exist, looks in resources of apdomain's entry assembly. For example, looks for Project.Properties.Resources.X if file <c>@"C:\X.png"</c> not found.
            - string that starts with <c>"image:"</c> or <c>"~:"</c> - Base64-encoded .png or .bmp image embedded in script.
            <br/>If <c>"image:"</c>, it is .png file data, else it is compressed .bmp file data.
            <br/>Can be created with function Au.Controls.ImageUtil.ImageToString (in Au.Controls.dll).
            - int, ColorInt or Color - color. Int must be in 0xRRGGBB format. Alpha is not used.
            - <see cref="T:System.Drawing.Bitmap"/> - image object in memory.
            - IEnumerable of string, int/ColorInt/Color, Bitmap or object - multiple images or colors. Action - find any. To create a different action can be used callback function (parameter <i>also</i>).
            
            Icons are not supported directly, but you can use <see cref="M:Au.AIcon.GetFileIconImage(System.String,System.Int32,Au.Types.GIFlags)"/> or <see cref="M:Au.AIcon.HandleToImage(System.IntPtr,System.Boolean)"/>.
            </param>
            <param name="flags"></param>
            <param name="colorDiff">Maximal allowed color difference. Use to to find images that have slightly different colors than the specified image. Can be 0 - 250, but should be as small as possible. Applied to each color component (red, green, blue) of each pixel.</param>
            <param name="also">
            Callback function. Called for each found image instance and receives its rectangle, match index and list index. Can return one of <see cref="T:Au.Types.WIAlso"/> values.
            
            Examples:
            - Skip some matching images if some condition if false: <c>also: o => condition ? WIAlso.OkReturn : WIAlso.FindOther</c>
            - Skip n matching images: <c>also: o => o.Skip(n)</c>
            - Get rectangles etc of all matching images: <c>also: o => { list.Add(o); return false; }</c>. Don't use this code in 'wait' functions.
            - Get rectangles etc of all matching images and stop waiting: <c>also: o => { list.Add(o); o.Found = true; return false; }</c>
            - Do different actions depending on which list images found: <c>var found = new BitArray(images.Length); AWinImage.Find(w, images, also: o => { found[o.ListIndex] = true; return WIAlso.OkFindMoreOfList; }); if(found[0]) Print(0); if(found[1]) Print(1);</c>
            </param>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (the <i>area</i> argument).</exception>
            <exception cref="T:System.ArgumentException">
            - An argument is of unsupported type or is/contains a null/invalid value.
            - Image or area is a bottom-up Bitmap object (see <see cref="P:System.Drawing.Imaging.BitmapData.Stride"/>). Such bitmaps are unusual in .NET (GDI+), but can be created by <b>Image.FromHbitmap</b> (instead use <see cref="M:Au.AWinImage.BitmapFromHbitmap(System.IntPtr)"/>).
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The specified file does not exist.</exception>
            <exception cref="T:System.Exception">Depending on <i>image</i> string format, exceptions of <see cref="M:System.Drawing.Image.FromFile(System.String)"/>, <see cref="M:System.Drawing.Bitmap.#ctor(System.IO.Stream)"/>, <see cref="M:Au.Util.AConvert.Decompress(System.Byte[],System.Int32,System.Int32)"/>.</exception>
            <exception cref="T:Au.Types.AuException">Something failed.</exception>
            <remarks>
            To create code for this function, use dialog "Find image or color in window". It is form <b>Au.Tools.FormAWinImage</b> in Au.Tools.dll.
            
            The speed mostly depends on:
            1. The size of the search area. Use the smallest possible area (control or accessible object or rectangle in window like <c>(w, rectangle)</c>).
            2. Flags <see cref="F:Au.Types.WIFlags.WindowDC"/> (makes faster), <see cref="F:Au.Types.WIFlags.PrintWindow"/>. The speed depends on window.
            3. Video driver. Can be much slower if incorrect, generic or virtual PC driver is used. The above flags should help.
            4. <i>colorDiff</i>. Should be as small as possible.
            
            If flag <see cref="F:Au.Types.WIFlags.WindowDC"/> or <see cref="F:Au.Types.WIFlags.PrintWindow"/> not used, the search area must be visible on the screen, because this function then gets pixels from the screen.
            
            Can find only images that exactly match the specified image. With <i>colorDiff</i> can find images with slightly different colors and brightness. Cannot find images with different shapes.
            
            Transparent and partially transparent pixels are ignored. For example, when you capture a non-rectangular area image, the image actually is rectangular, but pixels outside of its captured area are transparent and therefore not compared. Also you can draw transparent areas with an image editor that supports it, for example Paint.NET.
            
            This function is not the best way to find objects when the script is intended for long use or for use on multiple computers or must be very reliable. Because it may fail to find the image after are changed some settings - system theme, application theme, text size (DPI), font smoothing (if the image contains text), etc. Also are possible various unexpected temporary conditions that may distort or hide the image, for example adjacent window shadow, a tooltip or some temporary window. If possible, in such scripts instead use other functions, eg find control or accessible object.
            </remarks>
            <example>
            Code created with dialog "Find image or color in window".
            <code><![CDATA[
            var w = AWnd.Find("Window Name").OrThrow();
            string image = "image:iVBORw0KGgoAAAANSUhEUgAAABYAAAANCAYAAACtpZ5jAAAAAXNSR0IArs4c...";
            var wi = AWinImage.Find(w, image).OrThrow();
            wi.Click();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWinImage.Wait(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})">
            <summary>
            Finds image(s) or color(s) displayed in window or other area. Waits until found.
            More info: <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>.
            </summary>
            <returns>Returns <see cref="T:Au.AWinImage"/> object containing the rectangle of the found image. On timeout returns null if <i>secondsTimeout</i> is negative; else exception.</returns>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>.</exception>
        </member>
        <member name="M:Au.AWinImage.WaitNot(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})">
            <summary>
            Waits until image(s) or color(s) is not displayed in window or other area.
            More info: <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>.</exception>
        </member>
        <member name="M:Au.AWinImage.WaitChanged(System.Double,Au.Types.WIArea,Au.Types.WIFlags,System.Int32)">
            <summary>
            Waits until something visually changes in window or other area.
            More info: <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (the area argument), or the window closed while waiting.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>.</exception>
            <remarks>
            The same as <see cref="M:Au.AWinImage.WaitNot(System.Double,Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>, but instead of <i>image</i> parameter this function captures the area image at the beginning.
            </remarks>
        </member>
        <member name="M:Au.AWinImage.Capture(Au.Types.RECT)">
            <summary>
            Creates image from a rectangle of screen pixels.
            </summary>
            <param name="rect">A rectangle in screen coordinates.</param>
            <exception cref="T:System.ArgumentException">Empty rectangle.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size (with*height*4 bytes).</exception>
            <remarks>
            PixelFormat is always Format32bppRgb.
            </remarks>
            <example>
            <code><![CDATA[
            var file = AFolders.Temp + "notepad.png";
            AWnd w = AWnd.Find("* Notepad");
            w.Activate();
            using(var b = AWinImage.Capture(w.Rect)) { b.Save(file); }
            AExec.Run(file);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWinImage.Capture(Au.AWnd,Au.Types.RECT,System.Boolean)">
            <summary>
            Creates image from a rectangle of window client area pixels.
            </summary>
            <param name="w">Window or control.</param>
            <param name="rect">A rectangle in w client area coordinates. Use <c>w.ClientRect</c> to get whole client area.</param>
            <param name="usePrintWindow">Use flag <see cref="F:Au.Types.WICFlags.PrintWindow"/>.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid w.</exception>
            <exception cref="T:System.ArgumentException">Empty rectangle.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size (with*height*4 bytes).</exception>
            <remarks>
            How this is different from <see cref="M:Au.AWinImage.Capture(Au.Types.RECT)"/>:
            1. Gets pixels from window's device context (DC), not from screen DC, unless the Aero theme is turned off (on Windows 7). The window can be under other windows. The image can be different.
            2. If the window is partially or completely transparent, gets non-transparent image.
            3. Does not work with Windows Store app windows, Chrome and some other windows. Creates black image.
            4. If the window is DPI-scaled, captures its non-scaled view. And <i>rect</i> must contain non-scaled coordinates.
            </remarks>
        </member>
        <member name="M:Au.AWinImage.Capture(System.Collections.Generic.List{Au.Types.POINT})">
            <summary>
            Creates image from a non-rectangular area of screen pixels.
            </summary>
            <param name="outline">The outline (shape) of the area in screen. If single element, captures single pixel.</param>
            <exception cref="T:System.ArgumentException"><i>outline</i> is null or has 0 elements.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size.</exception>
            <remarks>
            PixelFormat is always Format32bppRgb.
            </remarks>
        </member>
        <member name="M:Au.AWinImage.Capture(Au.AWnd,System.Collections.Generic.List{Au.Types.POINT},System.Boolean)">
            <summary>
            Creates image from a non-rectangular area of window client area pixels.
            </summary>
            <param name="w">Window or control.</param>
            <param name="outline">The outline (shape) of the area in w client area coordinates. If single element, captures single pixel.</param>
            <param name="usePrintWindow">Use flag <see cref="F:Au.Types.WICFlags.PrintWindow"/>.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid <i>w</i>.</exception>
            <exception cref="T:System.ArgumentException"><i>outline</i> is null or has 0 elements.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of this size.</exception>
            <remarks>More info: <see cref="M:Au.AWinImage.Capture(Au.AWnd,Au.Types.RECT,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:Au.AWinImage.BitmapFromHbitmap(System.IntPtr)">
            <summary>
            Creates Bitmap from a GDI bitmap.
            </summary>
            <param name="hbitmap">GDI bitmap handle. This function makes its copy.</param>
            <remarks>
            How this function is different from <see cref="M:System.Drawing.Image.FromHbitmap(System.IntPtr)"/>:
            1. Image.FromHbitmap usually creates bottom-up bitmap, which is incompatible with <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>. This function creates normal top-down bitmap, like <c>new Bitmap(...)</c>, <c>Bitmap.FromFile(...)</c> etc do.
            2. This function always creates bitmap of PixelFormat Format32bppRgb.
            </remarks>
            <exception cref="T:Au.Types.AuException">Failed. For example hbitmap is default(IntPtr).</exception>
            <exception cref="T:System.Exception">Exceptions of Bitmap(int, int, PixelFormat) constructor.</exception>
        </member>
        <member name="M:Au.AWinImage.CaptureUI(Au.Types.WICResult@,Au.Types.WICFlags,Au.Types.AnyWnd)">
            <summary>
            Creates image from a user-selected area of screen pixels. Or gets single pixel color, or just rectangle.
            Returns false if cancelled.
            </summary>
            <param name="result">Receives results.</param>
            <param name="flags"></param>
            <param name="toolWindow">Owner window. Temporarily hides it and its owner windows.</param>
            <remarks>
            Gets all screen pixels and shows in a full-screen topmost window, where the user can select an area.
            </remarks>
        </member>
        <member name="T:Au.Resources.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Au.Resources.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Au.Resources.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Au.Resources.Resources.red_cross_cursor">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="T:Au.ACsv">
            <summary>
            Parses and composes CSV text. Stores CSV table data in memory as a <b>List</b> of string arrays.
            </summary>
            <remarks>
            CSV is a text format used to store a single table of data in human-readable/editable way.
            It is a list of lines (called rows or records) containing one or more values (called fields or cells) separated by a separator character.
            There is no strictly defined CSV standard. <b>ACsv</b> uses these rules:
            	Fields containg separator characters (default ','), quote characters (default '"') and multiple lines are enclosed in quote characters. Example: "ab, cd".
            	Each quote character in such fields is escaped (replaced) with two quote characters. Example: "ab ""cd"" ef".
            	If a field value starts or ends with ASCII space or tab characters, it is enclosed in quote characters. Example: " ab ". Or use parameter <i>trimSpaces</i> false when parsing.
            	Rows in CSV text can have different field count. All rows in in-memory CSV table have equal field count.
            </remarks>
        </member>
        <member name="M:Au.ACsv.#ctor">
            <summary>
            Initializes new <see cref="T:Au.ACsv"/> variable that can be used to add rows.
            To create new variables from CSV text, file or dictionary, instead use static functions, for example <see cref="M:Au.ACsv.Parse(System.String,System.Char,System.Char,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Au.ACsv.Data">
            <summary>
            Gets the internal <b>List</b> containing rows as string arrays.
            </summary>
            <remarks>
            It's not a copy; changing it will change the data of this <see cref="T:Au.ACsv"/> variable.
            You can do anything with the <b>List</b>. For example, sort it, find rows containing certain field values, get/set field values directly, add/remove rows directly.
            All row arrays have <b>Length</b> equal to <see cref="P:Au.ACsv.ColumnCount"/>, and it must remain so; you can change <b>Length</b>, but then need to call <c>ColumnCount=newLength</c>.
            </remarks>
            <example>
            <code><![CDATA[
            x.Data.Sort((a,b) => string.CompareOrdinal(a[0], b[0]));
            ]]></code>
            </example>
        </member>
        <member name="P:Au.ACsv.Separator">
            <summary>
            Sets or gets the field separator character used when composing CSV text.
            Initially it is ','.
            </summary>
        </member>
        <member name="P:Au.ACsv.Quote">
            <summary>
            Sets or gets the quote character used when composing CSV text.
            Initially it is '"'.
            </summary>
        </member>
        <member name="M:Au.ACsv.Parse(System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            Parses CSV string and creates new <see cref="T:Au.ACsv"/> variable that contains all data in internal <b>List</b> of string arrays.
            </summary>
            <param name="csv">
            CSV text.
            If rows in CSV text have different field count, the longest row sets the <see cref="P:Au.ACsv.ColumnCount"/> property and lenghts of all row arrays; array elements of missing CSV fields will be null.
            </param>
            <param name="separator">Field separator character used in CSV text. Default ','.</param>
            <param name="quote">Character used in CSV text to enclose some fields. Default '"'.</param>
            <param name="trimSpaces">Ignore ASCII space and tab characters surrounding fields in CSV text. Default true.</param>
            <exception cref="T:System.FormatException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
        </member>
        <member name="M:Au.ACsv.ToString">
            <summary>
            Composes CSV text from the internal <b>List</b> of string arrays.
            </summary>
            <remarks>
            Depends on these properties: <see cref="P:Au.ACsv.Separator"/> (initially ','), <see cref="P:Au.ACsv.Quote"/> (initially '"').
            </remarks>
        </member>
        <member name="P:Au.ACsv.RowCount">
            <summary>
            Gets or sets row count.
            The 'get' function returns the <b>Count</b> property of the internal <b>List</b> of string arrays.
            The 'set' function can add new rows or remove rows at the end.
            </summary>
        </member>
        <member name="P:Au.ACsv.ColumnCount">
            <summary>
            Gets or sets column count.
            The 'get' function returns the length of all string arrays in the internal <b>List</b>.
            The 'set' function can add new columns or remove columns at the right.
            </summary>
        </member>
        <member name="P:Au.ACsv.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets a field.
            </summary>
            <param name="row">0-based row index. With the 'set' function it can be negative or equal to <see cref="P:Au.ACsv.RowCount"/>; then adds new row.</param>
            <param name="column">0-based column index. With the 'set' function it can be &gt;= <see cref="P:Au.ACsv.ColumnCount"/> and &lt; 1000; then sets <c>ColumnCount = column + 1</c>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Au.ACsv.Item(System.Int32)">
            <summary>
            Gets or sets fields in a row.
            </summary>
            <param name="row">0-based row index. With the 'set' function it can be negative or equal to <see cref="P:Au.ACsv.RowCount"/>; then adds new row.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            The 'get' function gets the row array. It's not a copy; changing its elements will change the data of this <see cref="T:Au.ACsv"/> variable.
            The 'set' function sets the row array. Does not copy the array, unless its <b>Length</b> is less than <see cref="P:Au.ACsv.ColumnCount"/>.
            </remarks>
        </member>
        <member name="M:Au.ACsv.AddRow(System.String[])">
            <summary>
            Adds new row and sets its fields.
            </summary>
            <param name="fields">Row fields. Can be a string array or multiple string arguments. Does not copy the array, unless its <b>Length</b> is less than <see cref="P:Au.ACsv.ColumnCount"/>. Adds new columns if array <b>Length</b> (or the number of string arguments) is greater than ColumnCount.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.ACsv.InsertRow(System.Int32,System.String[])">
            <summary>
            Inserts new row and sets its fields.
            </summary>
            <param name="index">0-based row index. If negative or equal to <see cref="P:Au.ACsv.RowCount"/>, adds to the end.</param>
            <param name="fields">Row fields. Can be a string array or multiple string arguments. Does not copy the array, unless its <b>Length</b> is less than <see cref="P:Au.ACsv.ColumnCount"/>. Adds new columns if array <b>Length</b> (or the number of string arguments) is greater than ColumnCount.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.ACsv.InsertRow(System.Int32)">
            <summary>
            Inserts new empty row.
            </summary>
            <param name="index">0-based row index. If negative or equal to <see cref="P:Au.ACsv.RowCount"/>, adds to the end.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.ACsv.RemoveRow(System.Int32,System.Int32)">
            <summary>
            Removes one or more rows.
            </summary>
            <param name="index">0-based row index.</param>
            <param name="count">How many rows to remove, default 1.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Au.ACsv.Load(System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            Loads and parses a CSV file.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.</param>
            <param name="separator">Field separator character used in CSV text. Default ','.</param>
            <param name="quote">Character used in CSV text to enclose some fields. Default '"'.</param>
            <param name="trimSpaces">Ignore ASCII space and tab characters surrounding fields in CSV text. Default true.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.ReadAllText(System.String)"/>.</exception>
            <exception cref="T:System.FormatException">Invalid CSV, eg contains incorrectly enclosed fields.</exception>
            <remarks>
            Calls <see cref="M:System.IO.File.ReadAllText(System.String)"/> and <see cref="M:Au.ACsv.Parse(System.String,System.Char,System.Char,System.Boolean)"/>. Also uses <see cref="M:Au.AFile.WaitIfLocked(System.Action,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.ACsv.Save(System.String,System.Boolean)">
            <summary>
            Composes CSV and saves to file.
            </summary>
            <param name="file">File. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>. The file can exist or not; this function overwrites it.</param>
            <param name="backup">Create backup file named file + "~backup".</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>.</exception>
            <remarks>
            Calls <see cref="M:Au.ACsv.ToString"/> and <see cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>. Also uses <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.ACsv.FromDictionary(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Creates 2-column CSV table from dictionary keys and values of type string.
            </summary>
            <param name="d"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.ACsv.FromDictionary``1(System.Collections.Generic.Dictionary{System.String,``0},System.Func{``0,System.String})">
            <summary>
            Creates 2-column CSV table from dictionary keys and values of any type, using a callback function to convert values to string.
            </summary>
            <param name="d"></param>
            <param name="valueToString">Callback function that converts value of type T to string.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Au.ACsv.FromDictionary``1(System.Collections.Generic.Dictionary{System.String,``0},System.Int32,System.Action{``0,System.String[]})">
            <summary>
            Creates CSV table of any column count from dictionary keys and values of any type, using a callback function to convert values to cell strings.
            </summary>
            <param name="d"></param>
            <param name="columnCount">CSV column count. Must be 2 or more.</param>
            <param name="valueToCells">Callback function that converts value of type T to one or more strings and puts them in row array elements starting from index 1. At index 0 is key.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">columnCount less than 2.</exception>
        </member>
        <member name="M:Au.ACsv.ToDictionary(System.Boolean,System.Boolean)">
            <summary>
            Creates dictionary from this 2-column CSV table.
            </summary>
            <param name="ignoreCase">Case-insensitive dictionary keys.</param>
            <param name="ignoreDuplicates">Don't throw exception if column 0 contains duplicate strings. Replace old value with new value.</param>
            <exception cref="T:System.InvalidOperationException"><b>ColumnCount</b> not 2.</exception>
            <exception cref="T:System.ArgumentException">Column 0 contains duplicate strings.</exception>
        </member>
        <member name="M:Au.ACsv.ToDictionary``1(System.Boolean,System.Boolean,System.Func{System.String[],``0})">
            <summary>
            Creates dictionary from this CSV table of any column count, using a callback function to convert cell strings to dictionary values of any type.
            </summary>
            <param name="ignoreCase">Case-insensitive dictionary keys.</param>
            <param name="ignoreDuplicates">Don't throw exception if column 0 contains duplicate strings. Replace old value with new value.</param>
            <param name="rowToValue">Callback function that converts one or more cell strings to single value of type T. The array is whole row; element 0 is key, and usually is not used.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"><b>ColumnCount</b> less than 2.</exception>
            <exception cref="T:System.ArgumentException">Column 0 contains duplicate strings.</exception>
        </member>
        <member name="M:Au.ACsv.SetInt(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets an int number field.
            </summary>
            <param name="row"><see cref="P:Au.ACsv.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.ACsv.Item(System.Int32,System.Int32)"/></param>
            <param name="value">The number.</param>
            <param name="hex">Let the number be in hexadecimal format, like 0x3A.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.ACsv.GetInt(System.Int32,System.Int32)">
            <summary>
            Gets an int number field.
            </summary>
            <param name="row"><see cref="P:Au.ACsv.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.ACsv.Item(System.Int32,System.Int32)"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.ACsv.SetDouble(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets a double number field.
            </summary>
            <param name="row"><see cref="P:Au.ACsv.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.ACsv.Item(System.Int32,System.Int32)"/></param>
            <param name="value">The number.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.ACsv.GetDouble(System.Int32,System.Int32)">
            <summary>
            Gets a double number field.
            </summary>
            <param name="row"><see cref="P:Au.ACsv.Item(System.Int32,System.Int32)"/></param>
            <param name="column"><see cref="P:Au.ACsv.Item(System.Int32,System.Int32)"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Au.AExtString">
            <summary>
            Adds extension methods for <see cref="T:System.String"/>.
            </summary>
            <remarks>
            Some .NET <see cref="T:System.String"/> methods use <see cref="F:System.StringComparison.CurrentCulture"/> by default, while others use ordinal or invariant comparison. It is confusing (difficult to remember), dangerous (easy to make bugs), slower and rarely useful.
            Microsoft recommends to specify <b>StringComparison.Ordinal[IgnoreCase]</b> explicitly. See https://msdn.microsoft.com/en-us/library/ms973919.aspx.
            This class adds ordinal comparison versions of these methods. Same or similar name, for example <b>Ends</b> for <b>EndsWith</b>.
            This class also adds more methods.
            You also can find string functions in other classes of this library, including <see cref="T:Au.Util.AStringUtil"/>, <see cref="T:Au.ARegex"/>, <see cref="T:Au.AChar"/>, <see cref="T:Au.APath"/>, <see cref="T:Au.ACsv"/>, <see cref="T:Au.AKeys.More"/>, <see cref="T:Au.Util.AConvert"/>, <see cref="T:Au.Util.AHash"/>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.Eq(System.String,System.String,System.Boolean)">
            <summary>
            Compares this and other string. Returns true if equal.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="s">Other string. Can be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
            <seealso cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
            <seealso cref="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Au.AExtString.Eq(System.String,System.Boolean,System.String[])">
            <summary>
            Compares this strings with multiple strings.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="strings">Other strings. Strings can be null.</param>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Eq(System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            Compares part of this string with other string. Returns true if equal.
            </summary>
            <param name="t">This string.</param>
            <param name="startIndex">Offset in this string. If invalid, returns false.</param>
            <param name="s">Other string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
            <seealso cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
            <seealso cref="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Au.AExtString.Eq(System.String,System.Int32,System.Boolean,System.String[])">
            <summary>
            Compares part of this string with multiple strings.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <param name="t">This string.</param>
            <param name="startIndex">Offset in this string. If invalid, returns false.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="strings">Other strings.</param>
            <exception cref="T:System.ArgumentNullException">A string in <i>strings</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Eqi(System.String,System.String)">
            <summary>
            Compares this and other string ignoring case (case-insensitive). Returns true if equal.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="s">Other string. Can be null.</param>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Ends(System.String,System.String,System.Boolean)">
            <summary>
            Compares the end of this string with other string. Returns true if equal.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Other string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Ends(System.String,System.Boolean,System.String[])">
            <summary>
            Compares the end of this string with multiple strings.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <param name="t">This string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="strings">Other strings.</param>
            <exception cref="T:System.ArgumentNullException">A string in <i>strings</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Ends(System.String,System.Char)">
            <summary>
            Returns true if this string ends with the specified character.
            </summary>
            <param name="t">This string.</param>
            <param name="c">The character.</param>
        </member>
        <member name="M:Au.AExtString.Starts(System.String,System.String,System.Boolean)">
            <summary>
            Compares the beginning of this string with other string. Returns true if equal.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Other string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Starts(System.String,System.Boolean,System.String[])">
            <summary>
            Compares the beginning of this string with multiple strings.
            Returns 1-based index of matching string, or 0 if none.
            </summary>
            <param name="t">This string.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="strings">Other strings.</param>
            <exception cref="T:System.ArgumentNullException">A string in <i>strings</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Starts(System.String,System.Char)">
            <summary>
            Returns true if this string starts with the specified character.
            </summary>
            <param name="t">This string.</param>
            <param name="c">The character.</param>
        </member>
        <member name="M:Au.AExtString.Find(System.String,System.String,System.Boolean)">
            <summary>
            Finds substring in this string. Returns its 0-based index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Subtring to find.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Find(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Finds substring in part of this string. Returns its 0-based index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Subtring to find.</param>
            <param name="startIndex">The search start index.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startIndex</i>.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Find(System.String,System.String,System.Range,System.Boolean)">
            <summary>
            Finds substring in part of this string. Returns its 0-based index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Subtring to find.</param>
            <param name="range">The search range.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <remarks>
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.FindAny(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Finds the first character specified in <i>chars</i>. Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <param name="startOfRange">The start index of the search range. Default 0.</param>
            <param name="endOfRange">The end index of the search range. If -1 (default), the length of this string.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startOfRange</i> or <i>endOfRange</i>.</exception>
        </member>
        <member name="M:Au.AExtString.FindNot(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Finds the first character not specified in <i>chars</i>. Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <param name="startOfRange">The start index of the search range. Default 0.</param>
            <param name="endOfRange">The end index of the search range. If -1 (default), the length of this string.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startOfRange</i> or <i>endOfRange</i>.</exception>
        </member>
        <member name="M:Au.AExtString.IndexOfNot(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Finds the first character not specified in <i>chars</i>. Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.AExtString.LastIndexOfNot(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Finds the last character not specified in <i>chars</i>. Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.AExtString.FindLastAny(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Finds the last character specified in <i>chars</i> (searches right to left). Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <param name="startOfRange">The start index of the search range. Default 0.</param>
            <param name="endOfRange">The end index of the search range. If -1 (default), the length of this string.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startOfRange</i> or <i>endOfRange</i>.</exception>
        </member>
        <member name="M:Au.AExtString.FindLastNot(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Finds the last character not specified in <i>chars</i> (searches right to left). Returns its index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters.</param>
            <param name="startOfRange">The start index of the search range. Default 0.</param>
            <param name="endOfRange">The end index of the search range. If -1 (default), the length of this string.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startOfRange</i> or <i>endOfRange</i>.</exception>
        </member>
        <member name="M:Au.AExtString.Trim(System.String,System.String)">
            <summary>
            Removes specified characters from the start and end of this string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters to remove.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.AExtString.TrimStart(System.String,System.String)">
            <summary>
            Removes specified characters from the start of this string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters to remove.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.AExtString.TrimEnd(System.String,System.String)">
            <summary>
            Removes specified characters from the end of this string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="chars">Characters to remove.</param>
            <exception cref="T:System.ArgumentNullException"><i>chars</i> is null.</exception>
        </member>
        <member name="M:Au.AExtString.FindWord(System.String,System.String,System.Nullable{System.Range},System.Boolean,System.String)">
            <summary>
            Finds whole word. Returns its 0-based index, or -1 if not found.
            </summary>
            <param name="t">This string.</param>
            <param name="s">Subtring to find.</param>
            <param name="range">The search range.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="otherWordChars">Additional word characters, for which <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns false. For example "_".</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <remarks>
            If <i>s</i> starts with a word character finds substring that is not preceded by a word character.
            If <i>s</i> ends with a word character, finds substring that is not followed by a word character.
            Word characters are those for which <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns true plus those specified in <i>otherWordChars</i>.
            Uses ordinal comparison (does not depend on current culture/locale).
            </remarks>
        </member>
        <member name="M:Au.AExtString.Lenn(System.String)">
            <summary>
            Returns <see cref="P:System.String.Length"/>. Returns 0 if this string is null.
            </summary>
            <param name="t">This string.</param>
        </member>
        <member name="M:Au.AExtString.AsSpan(System.String,System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Creates a new read-only span of this string using tuple (int start, int end).
            </summary>
            <seealso cref="M:Au.AExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/>
        </member>
        <member name="M:Au.AExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})">
            <summary>
            This function can be used with foreach to split this string into substrings as start/end offsets.
            </summary>
            <param name="t">This string.</param>
            <param name="separators">Characters that delimit the substrings. Or one of <see cref="T:Au.Types.SegSep"/> constants.</param>
            <param name="flags"></param>
            <param name="range">Part of this string to split.</param>
            <example>
            <code><![CDATA[
            string s = "one * two three ";
            foreach(var t in s.Segments(" ")) Print(t);
            foreach(var t in s.Segments(SegSep.Word, SegFlags.NoEmpty)) Print(t);
            ]]></code>
            </example>
            <seealso cref="M:Au.AExtString.SegSplit(System.String,System.String,Au.Types.SegFlags,System.Int32,System.Nullable{System.Range})"/>
            <seealso cref="M:Au.AExtString.SegLines(System.String,System.Boolean,System.Int32,System.Nullable{System.Range})"/>
            <seealso cref="M:Au.AExtString.AsSpan(System.String,System.ValueTuple{System.Int32,System.Int32})"/>
        </member>
        <member name="M:Au.AExtString.SegSplit(System.String,System.String,Au.Types.SegFlags,System.Int32,System.Nullable{System.Range})">
            <summary>
            Splits this string into substrings using the specified separators.
            </summary>
            <param name="t">This string.</param>
            <param name="separators">A string containing characters that delimit substrings. Or one of <see cref="T:Au.Types.SegSep"/> constants.</param>
            <param name="maxCount">The maximal number of substrings to get. If negative, gets all. Else if there are more substrings, the last element will contain single substring, unlike with <see cref="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)"/>.</param>
            <param name="flags"></param>
            <param name="range">Part of this string to split.</param>
            <seealso cref="M:Au.AExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/>
            <seealso cref="M:Au.AExtString.SegLines(System.String,System.Boolean,System.Int32,System.Nullable{System.Range})"/>
            <seealso cref="T:Au.Types.SegParser"/>
            <seealso cref="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)"/>
            <seealso cref="M:System.String.Join(System.Char,System.Object[])"/>
        </member>
        <member name="M:Au.AExtString.SegLines(System.String,System.Boolean,System.Int32,System.Nullable{System.Range})">
            <summary>
            Splits this string into lines using separators "\r\n", "\n", "\r".
            </summary>
            <param name="t">This string.</param>
            <param name="noEmptyLines">Don't need empty lines.</param>
            <param name="maxCount">The maximal number of substrings to get. If negative, gets all. Else if there are more lines, the last element will contain single line, unlike with <see cref="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)"/></param>
            <param name="range">Part of this string to split.</param>
            <seealso cref="M:Au.AExtString.Segments(System.String,System.String,Au.Types.SegFlags,System.Nullable{System.Range})"/>
            <seealso cref="F:Au.Types.SegSep.Line"/>
        </member>
        <member name="M:Au.AExtString.LineCount(System.String,System.Boolean)">
            <summary>
            Returns the number of lines.
            Counts line separators "\r\n", "\n", "\r".
            </summary>
            <param name="t">This string.</param>
            <param name="preferMore">Add 1 if the string ends with a line separator or its length is 0.</param>
            <seealso cref="M:Au.Util.AStringUtil.LineAndColumn(System.String,System.Int32,System.Int32@,System.Int32@)"/>
        </member>
        <member name="M:Au.AExtString.Lower(System.String)">
            <summary>
            Converts this string to lower case.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <remarks>
            Calls <see cref="M:System.String.ToLowerInvariant"/>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.Upper(System.String)">
            <summary>
            Converts this string to upper case.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <remarks>
            Calls <see cref="M:System.String.ToUpperInvariant"/>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.Upper(System.String,Au.Types.SUpper,System.Globalization.CultureInfo)">
            <summary>
            Converts this string or only the first character to upper case or all words to title case.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="how"></param>
            <param name="culture">Culture, for example <c>CultureInfo.CurrentCulture</c>. If null (default) uses invariant culture.</param>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to int number and gets the number end index.
            Returns the number, or 0 if fails to convert.
            </summary>
            <param name="t">This string.</param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="numberEndIndex">Receives offset in this string where the number part ends. If fails to convert, receives 0.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
            <remarks>
            Fails to convert when string is null, "", does not begin with a number or the number is too big.
            
            Unlike <b>int.Parse</b> and <b>Convert.ToInt32</b>:
            	The number in string can be followed by more text, like <c>"123text"</c>.
            	Has <i>startIndex</i> parameter that allows to get number from middle, like <c>"text123text"</c>.
            	Gets the end of the number part.
            	No exception when cannot convert.
            	The number can be decimal (like <c>"123"</c>) or hexadecimal (like <c>"0x1A"</c>); don't need separate flags for each style.
            	Faster.
            
            The number in string can start with ASCII whitespace (spaces, newlines, etc), like <c>" 5"</c>.
            The number in string can be with <c>"-"</c> or <c>"+"</c>, like <c>"-5"</c>, but not like <c>"- 5"</c>.
            Fails if the number is greater than +- <b>uint.MaxValue</b> (0xffffffff).
            The return value becomes negative if the number is greater than <b>int.MaxValue</b>, for example <c>"0xffffffff"</c> is -1, but it becomes correct if assigned to uint (need cast).
            Does not support non-integer numbers; for example, for <c>"3.5E4"</c> returns 3 and sets <c>numberEndIndex=startIndex+1</c>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to int number.
            Returns the number, or 0 if fails to convert.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.Int32@,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to int number and gets the number end index.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="numberEndIndex">Receives offset in this string where the number part ends. If fails to convert, receives 0.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.Int32@,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to int number.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.UInt32@,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to uint number and gets the number end index.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.UInt32@,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to uint number.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.Int64@,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to long number and gets the number end index.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.Int64@,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to long number.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.UInt64@,System.Int32,System.Int32@,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to ulong number and gets the number end index.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToInt(System.String,System.UInt64@,System.Int32,Au.Types.STIFlags)">
            <summary>
            Converts part of this string to ulong number.
            Returns false if fails.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>startIndex</i> is less than 0 or greater than string length.</exception>
        </member>
        <member name="M:Au.AExtString.ToNumber(System.String,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to double number.
            Returns the number, or 0 if fails to convert.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            Fails if the string is null or "" or isn't a valid floating-point number.
            Examples of valid numbers: "12", " -12.3 ", ".12", "12.", "12E3", "12.3e-45", "1,234.5" (with style <c>NumberStyles.Float | NumberStyles.AllowThousands</c>). String like "2text" is invalid, unless range is <c>0..1</c>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.ToNumber(System.String,System.Double@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to double number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.ToNumber(System.String,System.Single@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to float number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.ToNumber(System.String,System.Int32@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to int number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Int32.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.ToNumber(System.String,System.UInt32@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to uint number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.UInt32.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt32@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.ToNumber(System.String,System.Int64@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to long number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.Int64.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.ToNumber(System.String,System.UInt64@,System.Nullable{System.Range},System.Globalization.NumberStyles)">
            <summary>
            Converts this string or its part to ulong number.
            Returns false if fails.
            </summary>
            <param name="t">This string. Can be null.</param>
            <param name="result">Receives the result number.</param>
            <param name="range">Part of this string or null (default).</param>
            <param name="style">The permitted number format in the string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid <i>style</i>.</exception>
            <remarks>
            Calls <see cref="M:System.UInt64.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.UInt64@)"/> with <see cref="T:System.Globalization.CultureInfo"/> <b>InvariantCulture</b>.
            </remarks>
        </member>
        <member name="M:Au.AExtString.ReplaceAt(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Replaces part of this string with other string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="startIndex">Offset in this string.</param>
            <param name="count">Count of characters to replace.</param>
            <param name="s">The replacement string.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>startIndex</i> or <i>count</i>.</exception>
        </member>
        <member name="M:Au.AExtString.RemoveSuffix(System.String,System.Int32)">
            <summary>
            Removes <i>count</i> characters from the end of this string.
            Returns the result string.
            </summary>
            <param name="t">This string.</param>
            <param name="count">Count of characters to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.AExtString.RemoveSuffix(System.String,System.String,System.Boolean)">
            <summary>
            Removes <i>suffix</i> string from the end.
            Returns the result string. Returns this string if does not end with <i>suffix</i>.
            </summary>
            <param name="t">This string.</param>
            <param name="suffix">Substring to remove.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <exception cref="T:System.ArgumentNullException"><i>suffix</i> is null.</exception>
        </member>
        <member name="M:Au.AExtString.RemoveSuffix(System.String,System.Char)">
            <summary>
            Removes <i>suffix</i> character from the end.
            Returns the result string. Returns this string if does not end with <i>suffix</i>.
            </summary>
            <param name="t">This string.</param>
            <param name="suffix">Character to remove.</param>
            <exception cref="T:System.ArgumentNullException"><i>suffix</i> is null.</exception>
        </member>
        <member name="M:Au.AExtString.Limit(System.String,System.Int32,System.Boolean)">
            <summary>
            If this string is longer than <i>limit</i>, returns its substring 0 to <i>limit</i>-1 with appended '' character.
            Else returns this string.
            </summary>
            <param name="t">This string.</param>
            <param name="limit">Maximal length of the result string. If less than 1, is used 1.</param>
            <param name="middle">Let "" be in middle. For example it is useful when the string is a path, to avoid removing filename.</param>
        </member>
        <member name="M:Au.AExtString.Escape(System.String,System.Int32,System.Boolean)">
            <summary>
            Replaces unsafe characters with C# escape sequences.
            If the string contains these characters, replaces and returns new string. Else returns this string.
            </summary>
            <param name="t">This string.</param>
            <param name="limit">If the final string is longer than <i>limit</i>, get its substring 0 to <i>limit</i>-1 with appended '' character. The enclosing "" are not counted.</param>
            <param name="quote">Enclose in "".</param>
            <remarks>
            Replaces these characters: <c>'\\'</c>, <c>'\"'</c>, <c>'\t'</c>, <c>'\n'</c>, <c>'\r'</c> and all in range 0-31.
            </remarks>
        </member>
        <member name="M:Au.AExtString.Unescape(System.String,System.String@)">
            <summary>
            Replaces C# escape sequences to characters in this string.
            Returns true if successful. Returns false if the string contains an invalid or unsupported escape sequence.
            </summary>
            <param name="t">This string.</param>
            <param name="result">Receives the result string. It is this string if there are no escape sequences or if fails.</param>
            <remarks>
            Supports all escape sequences of <see cref="M:Au.AExtString.Escape(System.String,System.Int32,System.Boolean)"/>: \\ \" \t \n \r \0 \uXXXX.
            Does not support \a \b \f \v \' \xXXXX \UXXXXXXXX.
            </remarks>
        </member>
        <member name="M:Au.AExtString.RegexIsMatch(System.String,System.String,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns true if this string matches PCRE regular expression <i>rx</i>.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string. If null, returns false.</param>
            <param name="rx">Regular expression.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexMatch(System.String,System.String,Au.Types.RXMatch@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns true if this string matches PCRE regular expression <i>rx</i>.
            Gets match info as <see cref="T:Au.Types.RXMatch"/>.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string. If null, returns false.</param>
            <param name="rx">Regular expression.</param>
            <param name="result">Receives match info.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexMatch(System.String,System.String,System.Int32,System.String@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns true if this string matches PCRE regular expression <i>rx</i>.
            Gets whole match or some group, as string.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.MatchS(System.String,System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string. If null, returns false.</param>
            <param name="rx">Regular expression.</param>
            <param name="group">Group number (1-based index) of result. If 0 (default) - whole match.</param>
            <param name="result">Receives the match value.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexMatch(System.String,System.String,System.Int32,Au.Types.RXGroup@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns true if this string matches PCRE regular expression <i>rx</i>.
            Gets whole match or some group, as index and length.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.MatchG(System.String,Au.Types.RXGroup@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string. If null, returns false.</param>
            <param name="rx">Regular expression.</param>
            <param name="group">Group number (1-based index) of result. If 0 (default) - whole match.</param>
            <param name="result">Receives match info.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexFindAll(System.String,System.String,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds all match instances of PCRE regular expression <i>rx</i>.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXMatch"/>&gt; object that can be used with foreach.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.FindAll(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexFindAll(System.String,System.String,Au.Types.RXMatch[]@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds all match instances of PCRE regular expression <i>rx</i>. Gets array of <see cref="T:Au.Types.RXMatch"/>.
            Returns true if found 1 or more matches.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.FindAll(System.String,Au.Types.RXMatch[]@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="result">Receives all found matches.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexFindAll(System.String,System.String,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds all match instances of PCRE regular expression <i>rx</i>.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXGroup"/>&gt; object that can be used with foreach.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.FindAllS(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="group">Group number (1-based index) of results. If 0 (default) - whole match.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexFindAll(System.String,System.String,System.Int32,System.String[]@,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds all match instances of PCRE regular expression <i>rx</i>. Gets array of strings.
            Returns true if found 1 or more matches.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.FindAllS(System.String,System.String[]@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="group">Group number (1-based index) of results. If 0 (default) - whole match.</param>
            <param name="result">Receives all found matches.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexReplace(System.String,System.String,System.String,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <i>rx</i>.
            Returns the result string.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.Replace(System.String,System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="repl">Replacement pattern.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexReplace(System.String,System.String,System.String,System.String@,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <i>rx</i>.
            Returns the number of replacements made.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.Replace(System.String,System.String,System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="repl">Replacement pattern.</param>
            <param name="result">The result string.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexReplace(System.String,System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <i>rx</i>. Uses a callback function.
            Returns the result string.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="replFunc">Callback function that receives found matches and returns replacements.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexReplace(System.String,System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Finds and replaces all match instances of PCRE regular expression <i>rx</i>. Uses a callback function.
            Returns the number of replacements made.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="replFunc">Callback function that receives found matches and returns replacements.</param>
            <param name="result">The result string.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString.RegexSplit(System.String,System.String,System.Int32,Au.Types.RXFlags,System.Nullable{System.Range})">
            <summary>
            Returns array of substrings delimited by PCRE regular expression <i>rx</i> matches.
            Parameters etc are of <see cref="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)"/> and <see cref="M:Au.ARegex.Split(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            Examples in <see cref="T:Au.ARegex"/> class help.
            </summary>
            <param name="t">This string.</param>
            <param name="rx">Regular expression.</param>
            <param name="maxCount">The maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="flags"></param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or used a PARTIAL_ flag.</exception>
            <exception cref="T:Au.Types.AuException">Failed (unlikely).</exception>
        </member>
        <member name="M:Au.AExtString._RegexCache.AddOrGet(System.String,Au.Types.RXFlags)">
            <summary>
            If rx/flags is in the cache, returns the cached code.
            Else compiles rx/flags, adds to the cache and returns the code.
            </summary>
            <param name="rx"></param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or failed to compile it for some other reason.</exception>
        </member>
        <member name="M:Au.AExtString.Like(System.String,System.String,System.Boolean)">
            <summary>
            Compares this string with a string that possibly contains wildcard characters.
            Returns true if the strings match.
            </summary>
            <param name="t">This string. If null, returns false. If "", returns true if pattern is "" or "*".</param>
            <param name="pattern">String that possibly contains wildcard characters. Cannot be null. If "", returns true if this string is "". If "*", always returns true except when this string is null.</param>
            <param name="ignoreCase">Case-insensitive.</param>
            <remarks>
            Wildcard characters:
            
            Character | Will match | Examples
            | - | - | - |
            | * | Zero or more of any characters. | <c>"start*"</c>, <c>"*end"</c>, <c>"*middle*"</c>
            | ? | Any single character. | <c>"date ????-??-??"</c>
            
            There are no escape sequences for * and ? characters.
            
            Uses ordinal comparison, ie does not depend on current culture.
            
            Much faster than regular expression.
            
            See also: [](xref:wildcard_expression).
            </remarks>
            <example>
            <code><![CDATA[
            string s = @"C:\abc\mno.xyz";
            if(s.Like(@"C:\abc\mno.xyz")) Print("matches whole text (no wildcard characters)");
            if(s.Like(@"C:\abc\*")) Print("starts with");
            if(s.Like(@"*.xyz")) Print("ends with");
            if(s.Like(@"*mno*")) Print("contains");
            if(s.Like(@"C:\*.xyz")) Print("starts and ends with");
            if(s.Like(@"?:*")) Print("any character, : and possibly more text");
            ]]></code>
            </example>
            <seealso cref="T:Au.AWildex"/>
        </member>
        <member name="M:Au.AExtString.Like(System.String,System.Boolean,System.String[])">
            <summary>
            Calls <see cref="M:Au.AExtString.Like(System.String,System.String,System.Boolean)"/> for each wildcard pattern specified in the argument list until it returns true.
            Returns 1-based index of matching pattern, or 0 if none.
            </summary>
            <param name="t"></param>
            <param name="ignoreCase">Case-insensitive.</param>
            <param name="patterns">One or more wildcard strings. The array and strings cannot be null.</param>
        </member>
        <member name="T:Au.ARegex">
            <summary>
            PCRE regular expression.
            </summary>
            <remarks>
            PCRE is a regular expression library: <see href="https://www.pcre.org/"/>.
            PCRE regular expression syntax: <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">full</see>, <see href="https://www.pcre.org/current/doc/html/pcre2syntax.html">short</see>.
            Some websites with tutorials and info: <see href="http://www.rexegg.com/">rexegg</see>, <see href="https://www.regular-expressions.info/">regular-expressions.info</see>.
            
            This class is an alternative to the .NET <see cref="T:System.Text.RegularExpressions.Regex"/> class. The regular expression syntax is similar. PCRE has some features unavailable in .NET, and vice versa. In most cases PCRE is about 2 times faster. You can use any of these classes. Functions of <see cref="T:Au.AAcc"/> class support only PCRE.
            
            Terms used in this documentation and in names of functions and types:
            - <i>regular expression</i> - regular expression string. Also known as <i>pattern</i>.
            - <i>subject string</i> - the string in which to search for the regular expression. Also known as <i>input string</i>.
            - <i>match</i> - the part (substring) of the subject string that matches the regular expression.
            - <i>groups</i> - regular expression parts enclosed in (). Except non-capturing parts, like (?:...) and (?options). Also known as <i>capturing group</i>, <i>capturing subpattern</i>. Often term <i>group</i> also is used for group matches.
            - <i>group match</i> - the part (substring) of the subject string that matches the group. Also known as <i>captured substring</i>.
            
            This library uses an unmanaged code dll AuCpp.dll that contains PCRE code. This class is a managed wrapper for it. The main PCRE API functions used by this class are <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2_compile and pcre2_match</see>. The <b>ARegex</b> constructor calls <b>pcre2_compile</b> and stores the compiled code in the variable. Other <b>ARegex</b> functions call <b>pcre2_match</b>. Compiling to native code (JIT) is not supported.
            
            An <b>ARegex</b> variable can be used by multiple threads simultaneously.
            
            Also there are several <b>String</b> extension methods that use this class. The string variable is the subject string. These methods create and use cached <b>ARegex</b> instances for speed. The <b>ARegex</b> constructor does not use caching.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22, three333,four"; //subject string
            var x = new ARegex(@"\b(\w+?)(\d+)\b"); //regular expression
             
             Print("//IsMatch:");
            Print(x.IsMatch(s));
             
             Print("//Match:");
            if(x.Match(s, out var m)) Print(m.Value, m[1].Value, m[2].Value);
             
             Print("//FindAll with foreach:");
            foreach(var v in x.FindAll(s)) Print(v.Value, v[1].Value, v[2].Value);
             Print("//FindAllS, get only strings of group 2:");
            Print(x.FindAllS(s, 2));
             
             Print("//Replace:");
            Print(x.Replace(s, "'$2$1'"));
             Print("//Replace with callback:");
            Print(x.Replace(s, o => o.Value.Upper()));
             Print("//Replace with callback and ExpandReplacement:");
            Print(x.Replace(s, o => { if(o.Length > 5) return o.ExpandReplacement("'$2$1'"); else return o[1].Value; }));
             
             Print("//Split:");
            Print(new ARegex(@" *, *").Split(s));
            ]]></code>
             Examples with <b>String</b> extension methods. 
            <code><![CDATA[
            var s = "one two22, three333,four"; //subject string
            var rx = @"\b(\w+?)(\d+)\b"; //regular expression
             
             Print("//RegexIsMatch:");
            Print(s.RegexIsMatch(rx));
             
             Print("//RegexMatch:");
            if(s.RegexMatch(rx, out var m)) Print(m.Value, m[1].Value, m[2].Value);
             
             Print("//RegexMatch, get only string:");
            if(s.RegexMatch(rx, 0, out var s0)) Print(s0);
             Print("//RegexMatch, get only string of group 1:");
            if(s.RegexMatch(rx, 1, out var s1)) Print(s1);
             
             Print("//RegexFindAll with foreach:");
            foreach(var v in s.RegexFindAll(rx)) Print(v.Value, v[1].Value, v[2].Value);
             
             Print("//RegexFindAll with foreach, get only strings:");
            foreach(var v in s.RegexFindAll(rx, 0)) Print(v);
             Print("//RegexFindAll with foreach, get only strings of group 2:");
            foreach(var v in s.RegexFindAll(rx, 2)) Print(v);
             
             Print("//RegexFindAll, get array:");
            if(s.RegexFindAll(rx, out var am)) foreach(var k in am) Print(k.Value, k[1].Value, k[2].Value);
             
             Print("//RegexFindAll, get array of strings:");
            if(s.RegexFindAll(rx, 0, out var av)) Print(av);
             Print("//RegexFindAll, get array of group 2 strings:");
            if(s.RegexFindAll(rx, 2, out var ag)) Print(ag);
             
             Print("//RegexReplace:");
            Print(s.RegexReplace(rx, "'$2$1'"));
             
             Print("//RegexReplace with callback:");
            Print(s.RegexReplace(rx, o => o.Value.Upper()));
             Print("//RegexReplace with callback and ExpandReplacement:");
            Print(s.RegexReplace(rx, o => { if(o.Length > 5) return o.ExpandReplacement("'$2$1'"); else return o[1].Value; }));
             
             Print("//RegexReplace, get replacement count:");
            if(0 != s.RegexReplace(rx, "'$2$1'", out var s2)) Print(s2);
             
             Print("//RegexReplace with callback, get replacement count:");
            if(0 != s.RegexReplace(rx, o => o.Value.Upper(), out var s3)) Print(s3);
             
             Print("//RegexSplit:");
            Print(s.RegexSplit(@" *, *"));
            ]]></code></example>
        </member>
        <member name="M:Au.ARegex.#ctor(System.String,Au.Types.RXFlags)">
            <summary>
            Compiles regular expression string.
            </summary>
            <param name="rx">Regular expression. Cannot be null.</param>
            <param name="flags">
            Options.
            Default 0. Flag UTF is implicitly added if <i>rx</i> contains non-ASCII characters and there is no flag NEVER_UTF.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid regular expression. Or failed to compile it for some other reason (unlikely).</exception>
            <remarks>
            Calls PCRE API function <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2_compile</see>.
            
            PCRE regular expression syntax: <see href="https://www.pcre.org/current/doc/html/pcre2pattern.html">full</see>, <see href="https://www.pcre.org/current/doc/html/pcre2syntax.html">short</see>.
            
            Examples in class help: <see cref="T:Au.ARegex"/>.
            </remarks>
        </member>
        <member name="M:Au.ARegex.Finalize">
            
        </member>
        <member name="P:Au.ARegex.Callout">
            <summary>
            Sets callout callback function.
            </summary>
            <value>Callback delegate (eg lambda) or null.</value>
            <remarks>
            Callouts can be used to: 1. Track the matching progress. 2. Get all instances of a group that can match multiple times. 3. Evaluate and reject some matches or match parts. 4. Etc.
            The callback function is called by <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>, <see cref="M:Au.ARegex.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>, <see cref="M:Au.ARegex.FindAll(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>, <see cref="M:Au.ARegex.Replace(System.String,System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>, <see cref="M:Au.ARegex.Split(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/> and similar functions, when they reach callout points in regular expression. To insert callout points use (?C), (?C1), (?C2), (?C'name') etc or pass flag AUTO_CALLOUT to the constructor.
            More info in PCRE help topic <see href="https://www.pcre.org/current/doc/html/pcre2callout.html">pcre2callout</see>.
            See also: <see href="http://www.rexegg.com/pcre-callouts.html"/>
            </remarks>
            <example>
            Track the matching progress.
            <code><![CDATA[
            var s = "text <a href='url'>link</a> text";
            var rx = @"(?C1)<a (?C2)href='.+?'>(?C3)[^<]*(?C4)</a>";
            var x = new ARegex(rx);
            x.Callout = o => { Print(o.callout_number, o.current_position, s.Substring(o.start_match, o.current_position), rx.Substring(o.pattern_position, o.next_item_length)); };
            Print(x.IsMatch(s));
            ]]></code>
            Track the matching progress with flag AUTO_CALLOUT.
            <code><![CDATA[
            var s = "one 'two' three";
            var rx = @"'(.+?)'";
            var x = new ARegex(rx, RXFlags.AUTO_CALLOUT);
            x.Callout = o => Print(o.current_position, o.pattern_position, rx.Substring(o.pattern_position, o.next_item_length));
            Print(x.IsMatch(s));
            ]]></code>
            Get all instances of a group that can match multiple times.
            <code><![CDATA[
            var s = "BEGIN 111 2222 333 END";
            var x = new ARegex(@"^(\w+) (?:(\d+) (?C1))+(\w+)$");
            var a = new List<string>();
            x.Callout = o => a.Add(o.LastGroupValue);
            if(!x.Match(s, out var m)) { Print("no match"); return; }
            Print(m[1]);
            Print(a); //all numbers. m[2] contains only the last number.
            Print(m[3]);
            ]]></code>
            Evaluate and reject some matches or match parts. This code rejects matches longer than 5.
            <code><![CDATA[
            var s = "one 123-5 two 12-456 three 1-34 four";
            var x = new ARegex(@"\b\d+-\d+\b(?C1)");
            x.Callout = o => { int len = o.current_position - o.start_match; /*Print(len);*/ if(len > 5) o.Result = 1; };
            Print(x.FindAllS(s));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.GroupNumberFromName(System.String)">
            <summary>
            Finds a named group and returns its 1-based index.
            Returns -1 if not found.
            </summary>
            <param name="groupName">
            Group name.
            In regular expression, to set name of group <c>(text)</c>, use <c>(?&lt;NAME&gt;text)</c>.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">More than 1 group have this name.</exception>
            <seealso cref="M:Au.Types.RXMatch.GroupNumberFromName(System.String)"/>
            <seealso cref="M:Au.Types.RXMatch.GroupNumberFromName(System.String,System.Boolean@)"/>
        </member>
        <member name="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns true if string <i>s</i> matches this regular expression.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="range">
            The start and end indexes (offsets) in the subject string. If null (default), uses whole string.
            Examples: <c>i..j</c> (from i to j), <c>i..</c> (from i to the end of the subject string), <c>..j</c> (from 0 to j).
            The subject part before the start index is not ignored if regular expression starts with a lookbehind assertion or anchor, eg <c>^</c> or <c>\b</c> or <c>(?&lt;=...)</c>. Instead of <c>^</c> you can use <c>\G</c>. More info in PCRE documentation topic <see href="https://www.pcre.org/current/doc/html/pcre2api.html">pcre2api</see>, chapter "The string to be matched by pcre2_match()".
            The subject part after the end index is always ignored.
            </param>
            <param name="matchFlags">Options.
            The same options also can be set in <b>ARegex</b> constructor's <i>flags</i>. Constructor's flags and <i>matchFlags</i> are added, which means that <i>matchFlags</i> cannot unset flags set by constructor.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            Print(x.IsMatch(s));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns true if string <i>s</i> matches this regular expression.
            Gets match info as <see cref="T:Au.Types.RXMatch"/>.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives match info. Read more in Remarks.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            If full match, returns true, and <i>result</i> contains the match and all groups that exist in the regular expressions.
            If partial match, returns true, and <i>result</i> contains the match without groups. Partial match is possible if used a PARTIAL_ flag.
            If no match, returns false, and <i>result</i> normally is null. But if a mark is available, <i>result</i> is an object with two valid properties - <see cref="P:Au.Types.RXMatch.Exists"/> (false) and <see cref="P:Au.Types.RXMatch.Mark"/>; other properties have undefined values or throw exception.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            if(x.Match(s, out var m)) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.MatchG(System.String,Au.Types.RXGroup@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns true if string <i>s</i> matches this regular expression.
            Gets whole match or some group, as <see cref="T:Au.Types.RXGroup"/> (index, length, value).
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives match info.</param>
            <param name="group">
            Group number (1-based index) of result. If 0 (default) - whole match.
            See also <see cref="M:Au.ARegex.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.ARegex.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            If full match, returns true, and <i>result</i> contains the match or the specifed group.
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag. Then cannot get groups, therefore <i>group</i> should be 0.
            If no match, returns false, and <i>result</i> is empty.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            if(x.MatchG(s, out var g)) Print(g.Value, g.Start);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.MatchS(System.String,System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns true if string <i>s</i> matches this regular expression.
            Gets whole match or some group, as string.
            </summary>
            <param name="s">
            Subject string.
            If null, always returns false, even if the regular expression matches empty string.
            </param>
            <param name="result">Receives the match value.</param>
            <param name="group">
            Group number (1-based index) of result. If 0 (default) - whole match.
            See also <see cref="M:Au.ARegex.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is a simplified version of <see cref="M:Au.ARegex.Match(System.String,Au.Types.RXMatch@,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/> and <see cref="M:Au.ARegex.MatchG(System.String,Au.Types.RXGroup@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.
            If full match, returns true, and <i>result</i> contains the value of the match or of the specifed group.
            If partial match, returns true too. Partial match is possible if used a PARTIAL_ flag. Then cannot get groups, therefore <i>group</i> should be 0.
            If no match, returns false, and <i>result</i> is null.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            if(x.MatchS(s, out var v)) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.FindAll(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXMatch"/>&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            foreach(var m in x.FindAll(s)) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.FindAll(System.String,Au.Types.RXMatch[]@,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression. Gets array of <see cref="T:Au.Types.RXMatch"/>.
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            if(!x.FindAll(s, out var a)) { Print("not found"); return; }
            foreach(var m in a) Print(m.Value, m[1].Value, m[2].Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.FindAllG(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;<see cref="T:Au.Types.RXGroup"/>&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.ARegex.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new ARegex(@"\b\w+\b");
            foreach(var g in x.FindAllG(s)) Print(g.Start, g.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.FindAllG(System.String,Au.Types.RXGroup[]@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression. Gets array of <see cref="T:Au.Types.RXGroup"/> (index, length, value).
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.ARegex.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new ARegex(@"\b\w+\b");
            if(!x.FindAllG(s, out var a)) { Print("not found"); return; }
            foreach(var g in a) Print(g.Start, g.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.FindAllS(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression.
            Returns a lazy IEnumerable&lt;string&gt; object that can be used with foreach.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.ARegex.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new ARegex(@"\b\w+\b");
            foreach(var v in x.FindAllS(s)) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.FindAllS(System.String,System.String[]@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds all match instances of the regular expression. Gets array of strings.
            Returns true if found 1 or more matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="result">Receives all found matches.</param>
            <param name="group">
            Group number (1-based index) of results. If 0 (default) - whole match.
            See also <see cref="M:Au.ARegex.GroupNumberFromName(System.String)"/>.
            </param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>group</i> or <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <example>
            <code><![CDATA[
            var s = "one two three";
            var x = new ARegex(@"\b\w+\b");
            if(!x.FindAllS(s, out var a)) { Print("not found"); return; }
            foreach(var v in a) Print(v);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.Replace(System.String,System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds and replaces all match instances of the regular expression.
            Returns the result string.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also: replaces $* with the name of the last encountered mark; replaces ${+func} with the return value of a function registered with <see cref="M:Au.ARegex.AddReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.String})"/>.
            </param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            s = x.Replace(s, "'$2$1'");
            Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.Replace(System.String,System.String,System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds and replaces all match instances of the regular expression.
            Returns the number of replacements made. Returns the result string through an out parameter.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="repl">
            Replacement pattern.
            Can consist of any combination of literal text and substitutions like $1.
            Supports .NET regular expression substitution syntax. See <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>. Also: replaces $* with the name of the last encountered mark; replaces ${+func} with the return value of a function registered with <see cref="M:Au.ARegex.AddReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.String})"/>.
            </param>
            <param name="result">The result string. Can be <i>s</i>.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            if(0 == x.Replace(s, "'$2$1'", out s)) Print("not found");
            else Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds and replaces all match instances of the regular expression. Uses a callback function.
            Returns the result string.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            s = x.Replace(s, o => o.Value.Upper());
            Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.Replace(System.String,System.Func{Au.Types.RXMatch,System.String},System.String@,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Finds and replaces all match instances of the regular expression. Uses a callback function.
            Returns the number of replacements made. Returns the result string through an out parameter.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <param name="result">The result string. Can be <i>s</i>.</param>
            <param name="maxCount">The maximal count of replacements to make. If -1 (default), replaces all.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one two22 three333 four";
            var x = new ARegex(@"\b(\w+?)(\d+)\b");
            if(0 == x.Replace(s, o => o.Value.Upper(), out s)) Print("not found");
            else Print(s);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.AddReplaceFunc(System.String,System.Func{Au.Types.RXMatch,System.String})">
            <summary>
            Adds or replaces a function that is called when a regular expression replacement string contains ${+name}.
            </summary>
            <param name="name">A string used to identify the function. Can contain any characters except '}'.</param>
            <param name="replFunc">
            Callback function's delegate, eg lambda. Called for each found match. Returns the replacement.
            In the callback function you can use <see cref="M:Au.Types.RXMatch.ExpandReplacement(System.String)"/>.
            </param>
            <remarks>
            Can be used when there is no way to use <b>Replace</b> overloads with a <i>replFunc</i> parameter. For example in Find/Replace UI.
            </remarks>
            <example>
            Create new script in the Au editor and add this code. In Properties set role editorExtension. Run.
            Then in the Find pane in the replacement field you can use <c>${+Upper}</c> and <c>${+Lower}</c>.
            <code><![CDATA[
            ARegex.AddReplaceFunc("Upper", m => m.Value.Upper()); //make uppercase
            ARegex.AddReplaceFunc("Lower", m => m.Value.Lower()); //make lowercase
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.Split(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns array of substrings delimited by regular expression matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="maxCount">The maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            Element 0 of the returned array is <i>s</i> substring until the first match of the regular expression, element 1 is substring between the first and second match, and so on. If no matches, the array contains single element and it is <i>s</i>.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one, two,three , four";
            var x = new ARegex(@" *, *");
            var a = x.Split(s);
            for(int i = 0; i < a.Length; i++) Print(i, a[i]);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.SplitG(System.String,System.Int32,System.Nullable{System.Range},Au.Types.RXMatchFlags)">
            <summary>
            Returns <see cref="T:Au.Types.RXGroup"/> array of substrings delimited by regular expression matches.
            </summary>
            <param name="s">Subject string. Cannot be null.</param>
            <param name="maxCount">The maximal count of substrings to get. The last substring contains the unsplit remainder of the subject string. If 0 (default) or negative, gets all.</param>
            <param name="range">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <param name="matchFlags">See <see cref="M:Au.ARegex.IsMatch(System.String,System.Nullable{System.Range},Au.Types.RXMatchFlags)"/>.</param>
            <exception cref="T:System.ArgumentNullException"><i>s</i> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <i>range</i>.</exception>
            <exception cref="T:System.ArgumentException">1. Used a PARTIAL_ flag. 2. The regular expression contains <c>(?=...\K)</c>.</exception>
            <exception cref="T:Au.Types.AuException">The PCRE API function <b>pcre2_match</b> failed. Unlikely.</exception>
            <remarks>
            Element 0 of the returned array is <i>s</i> substring until the first match of the regular expression, element 1 is substring between the first and second match, and so on. If no matches, the array contains single element and it is <i>s</i>.
            
            This function is similar to <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var s = "one, two,three , four";
            var x = new ARegex(@" *, *");
            var a = x.SplitG(s);
            foreach(var v in a) Print(v.Start, v.Value);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ARegex.EscapeQE(System.String,System.Boolean)">
            <summary>
            Encloses string in <c>\Q</c> <c>\E</c> if it contains metacharacters <c>\^$.[|()?*+{</c> or if <i>always</i> == true.
            </summary>
            <param name="s"></param>
            <param name="always">Enclose always, even if the string does not contain metacharacters. Should be true if the regular expression in which this string will be used has option "extended", because then whitespace is ignored and # is a special character too.</param>
            <remarks>
            Such enclosed substring in a regular expression is interpreted as a literal string.
            This function also escapes \E, so that it does not end the literal string.
            </remarks>
        </member>
        <member name="T:Au.Util.AStringUtil">
            <summary>
            Miscellaneous rarely used string functions. Parsing etc.
            </summary>
        </member>
        <member name="M:Au.Util.AStringUtil.IsAscii(System.String)">
            <summary>
            Returns true if string is "" or contains only ASCII characters.
            </summary>
        </member>
        <member name="M:Au.Util.AStringUtil.ParseParam3Stars(System.String@,System.String[])">
            <summary>
            Parses a function parameter that can optionally have a "***name " prefix, like "***id 100".
            Returns: 0 - s does not start with "***"; i+1 - s starts with "***names[i] "; -1 - s is invalid.
            </summary>
            <param name="s">Parameter. If starts with "***" and is valid, receives the 'value' part; else unchanged. Can be null.</param>
            <param name="names">List of supported 'name'.</param>
            <remarks>
            Used to parse parameters like <i>name</i> of <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.Util.AStringUtil.RemoveUnderlineAmpersand(System.String)">
            <summary>
            Removes '&amp;' characters from string.
            Replaces "&amp;&amp;" with "&amp;".
            Returns new string if s has '&amp;' characters, else returns s.
            </summary>
            <remarks>
            Character '&amp;' is used to underline next character in displayed text of dialog controls and menu items. Two '&amp;' are used to display single '&amp;'.
            The underline is displayed when using the keyboard (eg Alt key) to select dialog controls and menu items.
            </remarks>
        </member>
        <member name="M:Au.Util.AStringUtil.CommandLineFromArray(System.String[])">
            <summary>
            Converts array of command line arguments to string that can be passed to a "start process" function, for example <see cref="M:Au.AExec.Run(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)"/>, <see cref="M:System.Diagnostics.Process.Start"/>.
            Returns null if a is null or has 0 elements.
            </summary>
            <param name="a"></param>
        </member>
        <member name="M:Au.Util.AStringUtil.CommandLineToArray(System.String)">
            <summary>
            Parses command line arguments.
            Calls API <msdn>CommandLineToArgvW</msdn>.
            Returns empty array if s is null or "".
            </summary>
        </member>
        <member name="M:Au.Util.AStringUtil.ParseIntAndString(System.String,System.Int32@,System.String@,System.Int32,Au.Types.STIFlags)">
            <summary>
            If string contains a number at startIndex, gets that number as int, also gets the string part that follows it, and returns true.
            For example, for string "25text" or "25 text" gets num = 25, tail = "text".
            Everything else is the same as with <see cref="M:Au.AExtString.ToInt(System.String,System.Int32,System.Int32@,Au.Types.STIFlags)"/>.
            </summary>
            <param name="s"></param>
            <param name="num">Receives the number. Receives 0 if no number.</param>
            <param name="tail">Receives the string part that follows the number, or "". Receives null if no number. Can be this variable.</param>
            <param name="startIndex">Offset in this string where to start parsing.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Au.Util.AStringUtil.StringToIntArray(System.String)">
            <summary>
            Creates int[] from string containing space-separated numbers, like "4 100 -8 0x10".
            </summary>
            <param name="s">Decimal or/and hexadecimal numbers separated by single space. If null or "", returns empty array.</param>
            <remarks>
            For vice versa use <c>string.Join(" ", array)</c>.
            </remarks>
        </member>
        <member name="M:Au.Util.AStringUtil.LineAndColumn(System.String,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Converts character index in string to line index and character index in that line.
            </summary>
            <param name="s"></param>
            <param name="index">Character index in string <i>s</i>.</param>
            <param name="lineIndex">Receives 0-based line index.</param>
            <param name="indexInLine">Receives 0-based character index in that line.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Util.AStringUtil.LevenshteinDistance(System.String,System.String)">
            <summary>
            Calculates the Levenshtein distance between two strings, which tells how much they are different.
            </summary>
            <remarks>
            It is the number of character edits (removals, inserts, replacements) that must occur to get from string s1 to string s2.
            Can be used to measure similarity and match approximate strings with fuzzy logic.
            Uses code and info from <see href="https://www.dotnetperls.com/levenshtein"/>.
            </remarks>
        </member>
        <member name="M:Au.Util.AStringUtil.CommonPrefix(System.String,System.String)">
            <summary>
            Returns the number of characters common to the start of each string.
            </summary>
        </member>
        <member name="M:Au.Util.AStringUtil.CommonSuffix(System.String,System.String)">
            <summary>
            Returns the number of characters common to the end of each string.
            </summary>
        </member>
        <member name="T:Au.Util.AConvert">
            <summary>
            Data conversion functions - compress, hex-encode, Base64, UTF8.
            </summary>
            <seealso cref="T:Au.Util.AHash"/>
            <seealso cref="T:Au.Util.AHash.MD5"/>
        </member>
        <member name="M:Au.Util.AConvert.HexEncode(System.Void*,System.Int32,System.Boolean)">
            <summary>
            Converts binary data stored in any memory to hex-encoded string.
            </summary>
            <param name="data">The data. Can be any valid memory of specified size, for example a struct address.</param>
            <param name="size">data memory size (bytes).</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
        </member>
        <member name="M:Au.Util.AConvert.HexEncode(System.Byte[],System.Boolean)">
            <summary>
            Converts byte[] to hex-encoded string.
            </summary>
            <param name="a">The data.</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
            <remarks>
            The result string length is 2 * array length.
            In most cases it's better to use <see cref="M:System.Convert.ToBase64String(System.Byte[])"/>, then result is 4/3 of array length. Both functions are fast.
            </remarks>
        </member>
        <member name="M:Au.Util.AConvert.HexEncode``1(``0,System.Boolean)">
            <summary>
            Converts a struct variable to hex-encoded string.
            </summary>
            <param name="x">Variable.</param>
            <param name="upperCase">Let the hex string contain A-F, not a-f.</param>
        </member>
        <member name="M:Au.Util.AConvert.HexDecode(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts hex-encoded string to binary data as byte[].
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Hex-encoded data.</param>
            <remarks>
            Skips spaces and other non-hex-digit characters. Example: "01 23 46 67" is the same as "01234667".
            The number of hex-digit characters should be divisible by 2, else the last character is ignored.
            </remarks>
        </member>
        <member name="M:Au.Util.AConvert.HexDecode(System.ReadOnlySpan{System.Char},System.Void*,System.Int32)">
            <summary>
            Converts hex-encoded string to binary data. Stores it in caller's memory buffer.
            Returns the number of bytes stored in <i>decoded</i> memory. It is equal or less than <c>Math.Min(bufferSize, encoded.Length/2)</c>.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Hex-encoded data.</param>
            <param name="decoded">Memory buffer for the result.</param>
            <param name="bufferSize">The max number of bytes that can be written to the <i>decoded</i> memory buffer.</param>
            <remarks>
            Skips spaces and other non-hex-digit characters. Example: "01 23 46 67" is the same as "01234667".
            The number of hex-digit characters should be divisible by 2, else the last character is ignored.
            </remarks>
        </member>
        <member name="M:Au.Util.AConvert.HexDecode``1(System.ReadOnlySpan{System.Char},``0@)">
            <summary>
            Converts hex-encoded string to a struct variable.
            Returns false if decoded size != <c>sizeof(T)</c>.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <param name="decoded">The result variable.</param>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlEncode(System.Byte[])">
            <summary>
            Converts byte[] to Base64-encoded string that can be used in URLs and file names.
            </summary>
            <param name="bytes">Data to encode.</param>
            <remarks>Like <see cref="M:System.Convert.ToBase64String(System.Byte[])"/>, but instead of '/' and '+' uses '_' and '-'.</remarks>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlEncode(System.Void*,System.Int32)">
            <summary>
            Converts binary data stored in any memory to Base64-encoded string that can be used in URLs and file names.
            </summary>
            <param name="bytes">Data to encode.</param>
            <param name="length">Number of bytes to encode.</param>
            <remarks>Instead of '/' and '+' uses '_' and '-'.</remarks>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlEncode``1(``0)">
            <summary>
            Converts a struct variable to Base64-encoded string that can be used in URLs and file names.
            </summary>
            <param name="x">Variable.</param>
            <remarks>Instead of '/' and '+' uses '_' and '-'.</remarks>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlEncodeLength(System.Int32)">
            <summary>
            Gets Base64-encoded string length for non-encoded length.
            It is <c>(length + 2) / 3 * 4</c>.
            </summary>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlDecodeLength(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets decoded data length from Base64-encoded string length.
            It is <c>(int)(len * 3L / 4)</c> minus the number of padding '=' characters (max 2).
            </summary>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlDecode(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts string containing Base64-encoded data to byte[]. Supports standard encoding and URL-safe encoding.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <remarks>Like <see cref="M:System.Convert.FromBase64String(System.String)"/>, but the string can optionally contain '_' and '-' instead of '/' and '+'.</remarks>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)"/>.</exception>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlDecode(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Int32@)">
            <summary>
            Converts string containing Base64-encoded data to bytes and stores in memory of a Span variable. Supports standard encoding and URL-safe encoding.
            Returns false if the encoded string is invalid or the buffer is too small.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <param name="decoded">Memory buffer for the result.</param>
            <param name="decodedLength"></param>
            <remarks>The string can optionally contain '_' and '-' instead of '/' and '+'.</remarks>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlDecode(System.ReadOnlySpan{System.Char},System.Void*,System.Int32,System.Int32@)">
            <summary>
            Converts string containing Base64-encoded data to bytes and stores in any memory. Supports standard encoding and URL-safe encoding.
            Returns false if the encoded string is invalid or the buffer is too small.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <param name="decoded">Memory buffer for the result.</param>
            <param name="bufferSize">The max number of bytes that can be written to the <i>decoded</i> memory buffer.</param>
            <param name="decodedLength">Receives the number of bytes written to the <i>decoded</i> memory buffer.</param>
            <remarks>The string can optionally contain '_' and '-' instead of '/' and '+'.</remarks>
        </member>
        <member name="M:Au.Util.AConvert.Base64UrlDecode``1(System.ReadOnlySpan{System.Char},``0@)">
            <summary>
            Converts string containing Base64-encoded data to a struct variable. Supports standard encoding and URL-safe encoding.
            Returns false if the encoded string is invalid or decoded size != <c>sizeof(T)</c>.
            </summary>
            <param name="encoded">String or char[] or span of string/array/memory containing Base64-encoded data.</param>
            <param name="decoded">The result variable.</param>
            <remarks>The string can optionally contain '_' and '-' instead of '/' and '+'.</remarks>
        </member>
        <member name="M:Au.Util.AConvert.Compress(System.Byte[])">
            <summary>
            Compresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            </summary>
            <param name="data"></param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
        </member>
        <member name="M:Au.Util.AConvert.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            Returns byte[] containing decompressed data.
            </summary>
            <param name="compressedData">Compressed data.</param>
            <param name="index">Start index of compressed data in the compressedData array.</param>
            <param name="count">Length of compressed data in the compressedData array.</param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
        </member>
        <member name="M:Au.Util.AConvert.Decompress(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompresses data using <see cref="T:System.IO.Compression.DeflateStream"/>.
            Writes the decompressed data to a caller-provided memory stream.
            </summary>
            <param name="streamForDecompressedData">A memory stream where this function will write decompressed data. See example.</param>
            <param name="compressedData">Compressed data.</param>
            <param name="index">Start index of compressed data in the compressedData array.</param>
            <param name="count">Length of compressed data in the compressedData array.</param>
            <exception cref="T:System.Exception">Exceptions of DeflateStream.</exception>
            <example>
            This code is used by the other Decompress overload.
            <code><![CDATA[
            using var stream = new MemoryStream();
            Decompress(stream, compressedData, index, count);
            return stream.ToArray();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.AConvert.ToUtf8(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Converts string to UTF-8 byte[]. Appends "\0" or some other string.
            </summary>
            <param name="chars">String or char[] or span of string/array/memory.</param>
            <param name="append">An optional ASCII string to append. For example "\0" (default) or "\r\n" or null.</param>
            <exception cref="T:System.ArgumentException"><i>append</i> contains non-ASCII characters.</exception>
        </member>
        <member name="M:Au.Util.AConvert.FromUtf8(System.Byte*,System.Int32)">
            <summary>
            Converts UTF8 string to C# string (which is UTF16).
            The terminating '\0' character is not included in the returned string.
            </summary>
            <param name="utf8">UTF8 string. If null, returns null.</param>
            <param name="length">Length of <i>utf8</i>. If negative, the function finds length; then <i>utf8</i> must be '\0'-terminated.</param>
        </member>
        <member name="T:Au.Util.ACursor">
            <summary>
            Helps to load cursors, etc.
            </summary>
        </member>
        <member name="M:Au.Util.ACursor.LoadCursorFromFile(System.String,System.Int32)">
            <summary>
            Loads cursor from file.
            Returns null if fails.
            </summary>
            <param name="file">.cur or .ani file. If not full path, uses <see cref="P:Au.AFolders.ThisAppImages"/>.</param>
            <param name="size">Width and height. If 0, uses system default size, which depends on DPI (the "text size" system setting).</param>
            <remarks>
            This function exists because <see cref="T:System.Windows.Forms.Cursor"/> constructors don't support colors, ani cursors and custom size.
            </remarks>
        </member>
        <member name="M:Au.Util.ACursor.HandleToCursor(System.IntPtr,System.Boolean)">
            <summary>
            Converts unmanaged cursor to Cursor object.
            Returns null if hCur is default(IntPtr).
            </summary>
            <param name="hCursor">Cursor handle.</param>
            <param name="destroyCursor">If true (default), the returned variable owns the unmanaged cursor and destroys it when disposing. If false, the returned variable just uses the unmanaged cursor and will not destroy; if need, the caller later should destroy it with API <msdn>DestroyCursor</msdn>.</param>
        </member>
        <member name="M:Au.Util.ACursor.LoadCursorFromMemory(System.Byte[],System.Int32)">
            <summary>
            Creates cursor from cursor file data in memory, for example from a managed resource.
            Returns null if fails.
            </summary>
            <param name="cursorData">Data of .cur or .ani file.</param>
            <param name="size">Width and height. If 0, uses system default size, which depends on DPI (the "text size" system setting).</param>
            <remarks>
            This function exists because <see cref="T:System.Windows.Forms.Cursor"/> constructors don't support colors, ani cursors and custom size.
            </remarks>
        </member>
        <member name="M:Au.Util.ACursor.HashCursor(System.IntPtr)">
            <summary>
            Calculates 64-bit FNV1 hash of a mouse cursor's mask bitmap.
            Returns 0 if fails.
            </summary>
            <param name="hCursor">Native cursor handle. See <see cref="M:Au.Util.ACursor.GetCurrentCursor(System.IntPtr@)"/>.</param>
        </member>
        <member name="M:Au.Util.ACursor.GetCurrentCursor(System.IntPtr@)">
            <summary>
            Gets the native handle of the current mouse cursor.
            Returns false if the cursor is currently invisible.
            </summary>
            <remarks>
            It is the system cursor, not the cursor of this thread.
            Don't destroy the cursor.
            </remarks>
        </member>
        <member name="T:Au.Util.ADisableFsRedirection">
            <summary>
            Temporarily disables file system redirection, to allow this 32-bit process access the 64-bit System32 directory.
            </summary>
        </member>
        <member name="M:Au.Util.ADisableFsRedirection.Disable">
            <summary>
            If <see cref="P:Au.AVersion.Is32BitProcessAnd64BitOS"/>, calls API <msdn>Wow64DisableWow64FsRedirection</msdn>, which disables file system redirection.
            The caller can call this without checking OS and process bitness. This function checks it and it is fast.
            Always call <see cref="M:Au.Util.ADisableFsRedirection.Revert"/> or <b>Dispose</b>, for example use <b>finally</b> or <b>using</b> statement. Not calling it is more dangerous than a memory leak. It is not called by GC.
            </summary>
        </member>
        <member name="M:Au.Util.ADisableFsRedirection.Revert">
            <summary>
            If redirected, calls API <msdn>Wow64RevertWow64FsRedirection</msdn>.
            </summary>
        </member>
        <member name="M:Au.Util.ADisableFsRedirection.IsSystem64PathIn32BitProcess(System.String)">
            <summary>
            Returns true if <see cref="P:Au.AVersion.Is32BitProcessAnd64BitOS"/> is true and path starts with <see cref="P:Au.AFolders.System"/>.
            Most such paths are redirected, therefore you may want to disable redirection with this class.
            </summary>
            <param name="path">Normalized path. This function does not normalize. Also it is unaware of <c>@"\\?\"</c>.</param>
        </member>
        <member name="M:Au.Util.ADisableFsRedirection.GetNonRedirectedSystemPath(System.String,System.Boolean)">
            <summary>
            If <see cref="P:Au.AVersion.Is32BitProcessAnd64BitOS"/> is true and path starts with <see cref="P:Au.AFolders.System"/>, replaces that path part with <see cref="P:Au.AFolders.SystemX64"/>.
            It disables redirection to <see cref="P:Au.AFolders.SystemX86"/> for that path.
            </summary>
            <param name="path">Normalized path. This function does not normalize. Also it is unaware of <c>@"\\?\"</c>.</param>
            <param name="ifExistsOnlyThere">Don't replace path if the file or directory exists in the redirected folder or does not exist in the non-redirected folder.</param>
        </member>
        <member name="M:Au.Util.ADisableFsRedirection.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.ADisableFsRedirection.Revert"/>.
            </summary>
        </member>
        <member name="T:Au.Util.ADpi">
            <summary>
            Functions for high-DPI screen support.
            </summary>
            <remarks>
            High DPI is when in Windows Settings is set display text size other than 100%.
            Currently this class and this library don't support multiple screens that have different DPI. The Windows OS supports it since version 8.1.
            </remarks>
        </member>
        <member name="P:Au.Util.ADpi.BaseDPI">
            <summary>
            Gets DPI of the primary screen.
            </summary>
            <remarks>
            On newer Windows versions, users can change DPI without logoff-logon. This function gets the setting that was after logon.
            </remarks>
        </member>
        <member name="P:Au.Util.ADpi.SmallIconSize">
            <summary>
            Gets small icon size that depends on DPI of the primary screen.
            Width and Height are <see cref="P:Au.Util.ADpi.BaseDPI"/>/6, which is 16 if DPI is 96 (100%).
            </summary>
        </member>
        <member name="M:Au.Util.ADpi.ScaleInt(System.Int32)">
            <summary>
            If <see cref="P:Au.Util.ADpi.BaseDPI"/> is more than 96, returns stretched i.
            Else returns i.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Au.Util.ADpi.ScaleSize(Au.Types.SIZE)">
            <summary>
            If <see cref="P:Au.Util.ADpi.BaseDPI"/> is more than 96, returns scaled (stretched) z.
            Else returns z.
            Note: for images use <see cref="M:Au.Util.ADpi.ImageSize(System.Drawing.Image)"/>.
            </summary>
            <param name="z"></param>
        </member>
        <member name="M:Au.Util.ADpi.ImageSize(System.Drawing.Image)">
            <summary>
            If <see cref="P:Au.Util.ADpi.BaseDPI"/> is more than 96 and image resolution is different, returns scaled (stretched) image.Size.
            Else returns image.Size.
            </summary>
            <param name="image"></param>
        </member>
        <member name="T:Au.Util.ADragDrop">
            <summary>
            Drag-drop functions.
            </summary>
        </member>
        <member name="M:Au.Util.ADragDrop.SimpleDragDrop(Au.Types.AnyWnd,Au.Types.MButtons,System.Action{Au.Util.ADragDrop.MsgArgs})">
            <summary>
            Simple non-OLE drag operation.
            Returns true if dropped, false if cancelled.
            </summary>
            <param name="window">Window or control that owns the drag operation.</param>
            <param name="mouseButton">Mouse button that is used for the drag operation: Left, Right.</param>
            <param name="onMouseKeyMessage">Callback function, called on each received mouse/key message. Optional.</param>
        </member>
        <member name="T:Au.Util.ADragDrop.MsgArgs">
            <summary>
            <see cref="M:Au.Util.ADragDrop.SimpleDragDrop(Au.Types.AnyWnd,Au.Types.MButtons,System.Action{Au.Util.ADragDrop.MsgArgs})"/> callback function arguments.
            </summary>
        </member>
        <member name="F:Au.Util.ADragDrop.MsgArgs.Msg">
            <summary>
            Current message retrieved by API <msdn>GetMessage</msdn>.
            API <msdn>MSG</msdn>.
            </summary>
        </member>
        <member name="F:Au.Util.ADragDrop.MsgArgs.Cursor">
            <summary>
            The callback function can set this to temporarily set cursor.
            </summary>
        </member>
        <member name="M:Au.Util.ADragDrop.MsgArgs.Stop">
            <summary>
            The callback function can call this to end the operation.
            </summary>
        </member>
        <member name="T:Au.Util.AFonts">
            <summary>
            Provides various versions of standard font.
            </summary>
            <remarks>
            Extends <see cref="T:System.Drawing.SystemFonts"/>. Much faster.
            The properties return non-cached <b>Font</b> objects. It's safe to dispose them. It's OK to not dispose (GC will do; GDI+ fonts don't use much unmanaged memory). They are cloned from a single cached <see cref="P:System.Drawing.SystemFonts.MessageBoxFont"/>.
            </remarks>
        </member>
        <member name="F:Au.Util.AFonts._regularCached">
            <summary>
            The cached font from which are cloned other fonts.
            Use carefully, to avoid accidental disposing.
            </summary>
        </member>
        <member name="P:Au.Util.AFonts.Regular">
            <summary>
            Standard font used by most windows and controls.
            On Windows 10 it is "Segoe UI" 9 by default.
            Gets new object each time.
            </summary>
        </member>
        <member name="P:Au.Util.AFonts.Bold">
            <summary>
            Bold version of <see cref="P:Au.Util.AFonts.Regular"/> font.
            Gets new object each time.
            </summary>
        </member>
        <member name="M:Au.Util.AFonts.OfSize(System.Int32)">
            <summary>
            Different size version of <see cref="P:Au.Util.AFonts.Regular"/> font.
            Gets new object each time.
            </summary>
        </member>
        <member name="M:Au.Util.AFonts.OfStyle(System.Drawing.FontStyle)">
            <summary>
            Different style version of <see cref="P:Au.Util.AFonts.Regular"/> font.
            Gets new object each time.
            </summary>
        </member>
        <member name="M:Au.Util.AFonts.OfSizeStyle(System.Int32,System.Drawing.FontStyle)">
            <summary>
            Different style and size version of <see cref="P:Au.Util.AFonts.Regular"/> font.
            Gets new object each time.
            </summary>
        </member>
        <member name="T:Au.Util.AGC">
            <summary>
            <see cref="T:System.GC"/> extensions.
            </summary>
        </member>
        <member name="M:Au.Util.AGC.AddObjectMemoryPressure(System.Object,System.Int32)">
            <summary>
            Calls <see cref="M:System.GC.AddMemoryPressure(System.Int64)"/>. Later, when object <i>obj</i> is garbage-collected, will call <see cref="M:System.GC.RemoveMemoryPressure(System.Int64)"/>.
            </summary>
            <param name="obj">An object of any type.</param>
            <param name="size">Unmanaged memory size. It is passed to <b>GC.AddMemoryPressure</b> and <b>GC.RemoveMemoryPressure</b>.</param>
        </member>
        <member name="T:Au.Util.AHash">
            <summary>
            Data hash functions.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1(System.String)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1(System.Char*,System.Int32)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1(System.Byte[])">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1(System.Byte*,System.Int32)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1``1(``0)">
            <summary>
            32-bit FNV-1 hash.
            Useful for fast hash table and checksum use, not cryptography. Similar to CRC32; faster but creates more collisions.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1Long(System.String)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1Long(System.Char*,System.Int32)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1Long(System.Byte[])">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1Long(System.Byte*,System.Int32)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fnv1Long``1(``0)">
            <summary>
            64-bit FNV-1 hash.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fast(System.Char*,System.Int32)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Fast(System.String)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            </summary>
            <param name="s">The string to hash. Can be null.</param>
        </member>
        <member name="M:Au.Util.AHash.Fast(System.String,System.Int32,System.Int32)">
            <summary>
            FNV-1 hash, modified to make faster with long strings (then takes every n-th character).
            This overload hashes a substring.
            </summary>
            <param name="s">The string containing the substring. Can be null/"" if other parameters are 0.</param>
            <param name="startIndex">Start of substring in s.</param>
            <param name="count">Length of substring.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:Au.Util.AHash.MD5">
            <summary>
            Computes MD5 hash of some data.
            Multiple datas can be hashed, producing single result.
            Call <b>Add</b> one or more times. Finally use <see cref="P:Au.Util.AHash.MD5.Hash"/> to get result.
            </summary>
            <remarks>
            Faster than the .NET MD5 hash functions.
            </remarks>
        </member>
        <member name="P:Au.Util.AHash.MD5.IsEmpty">
            <summary>
            true if no data was added.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.MD5.Add(System.Void*,System.Int32)">
            <summary>Adds data.</summary>
            <exception cref="T:System.ArgumentNullException">data is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">size &lt; 0.</exception>
        </member>
        <member name="M:Au.Util.AHash.MD5.Add``1(``0)">
            <summary>Adds data.</summary>
        </member>
        <member name="M:Au.Util.AHash.MD5.Add(System.Byte[])">
            <summary>Adds data.</summary>
            <exception cref="T:System.ArgumentNullException">data is null.</exception>
        </member>
        <member name="M:Au.Util.AHash.MD5.Add(System.String)">
            <summary>Adds data.</summary>
            <exception cref="T:System.ArgumentNullException">data is null.</exception>
            <remarks>Adds UTF8 bytes, not UTF16 characters.</remarks>
        </member>
        <member name="P:Au.Util.AHash.MD5.Hash">
            <summary>
            Computes final hash of datas added with <b>Add</b>.
            </summary>
            <exception cref="T:System.InvalidOperationException"><b>Add</b> was not called.</exception>
            <remarks>
            Resets state, so that if <b>Add</b> called again, it will start adding new datas.
            </remarks>
        </member>
        <member name="T:Au.Util.AHash.MD5Result">
            <summary>
            Result of <see cref="P:Au.Util.AHash.MD5.Hash"/>.
            It is 16 bytes stored in 2 long fields r1 and r2.
            If need, can be converted to byte[] with <see cref="M:Au.Util.AHash.MD5Result.ToArray"/> or to hex string with <see cref="M:Au.Util.AHash.MD5Result.ToString"/>.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.MD5Result.ToString">
            <summary>
            Converts this to hex string of Length = 32.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.MD5Result.ToArray">
            <summary>
            Converts this to byte[16].
            </summary>
        </member>
        <member name="M:Au.Util.AHash.MD5Result.FromString(System.ReadOnlySpan{System.Char},Au.Util.AHash.MD5Result@)">
            <summary>
            Creates <b>MD5Result</b> from hex string returned by <see cref="M:Au.Util.AHash.MD5Result.ToString"/>.
            Returns false if <i>encoded</i> is invalid.
            </summary>
        </member>
        <member name="M:Au.Util.AHash.Crypto(System.Byte[],System.String)">
            <summary>
            Computes binary data hash using the specified cryptographic algorithm.
            </summary>
            <param name="a"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". See <see cref="T:System.Security.Cryptography.CryptoConfig"/>.</param>
        </member>
        <member name="M:Au.Util.AHash.Crypto(System.String,System.String)">
            <summary>
            Computes string hash using the specified cryptographic algorithm.
            </summary>
            <param name="s"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". See <see cref="T:System.Security.Cryptography.CryptoConfig"/>.</param>
            <remarks>Uses UTF8 bytes, not UTF16 bytes.</remarks>
        </member>
        <member name="M:Au.Util.AHash.CryptoHex(System.Byte[],System.String)">
            <summary>
            Computes binary data hash using the specified cryptographic algorithm and converts to hex string.
            </summary>
            <param name="a"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". See <see cref="T:System.Security.Cryptography.CryptoConfig"/>.</param>
        </member>
        <member name="M:Au.Util.AHash.CryptoHex(System.String,System.String)">
            <summary>
            Computes string hash using the specified cryptographic algorithm and converts to hex string.
            </summary>
            <param name="s"></param>
            <param name="algorithm">Algorithm name, eg "SHA256". See <see cref="T:System.Security.Cryptography.CryptoConfig"/>.</param>
            <remarks>Uses UTF8 bytes, not UTF16 bytes.</remarks>
        </member>
        <member name="T:Au.Util.AHelp">
            <summary>
            Static functions to open a help topic etc.
            </summary>
        </member>
        <member name="M:Au.Util.AHelp.AuHelp(System.String)">
            <summary>
            Opens an Au library help topic onine.
            </summary>
            <param name="topic">Topic file name, like "Au.AAcc.Find" or "AAcc.Find" or "articles/Wildcard expression".</param>
        </member>
        <member name="M:Au.Util.AHelp.AuHelpUrl(System.String)">
            <summary>
            Gets URL of an Au library help topic.
            </summary>
            <param name="topic">Topic file name, like "Au.AAcc.Find" or "AAcc.Find" or "articles/Wildcard expression".</param>
        </member>
        <member name="T:Au.Util.AJit">
            <summary>
            JIT-compiles methods.
            </summary>
        </member>
        <member name="M:Au.Util.AJit.Compile(System.Type,System.String)">
            <summary>
            JIT-compiles method.
            Uses <b>RuntimeHelpers.PrepareMethod</b>.
            </summary>
            <param name="type">Type containing the method.</param>
            <param name="method">Method name.</param>
            <exception cref="T:System.ArgumentException">Method does not exist.</exception>
            <exception cref="T:System.Reflection.AmbiguousMatchException">Multiple overloads exist.</exception>
        </member>
        <member name="M:Au.Util.AJit.Compile(System.Type,System.String[])">
            <summary>
            JIT-compiles multiple methods of same type.
            Uses <b>RuntimeHelpers.PrepareMethod</b>.
            </summary>
            <param name="type">Type containing the methods.</param>
            <param name="methods">Method names.</param>
            <exception cref="T:System.ArgumentException">Method does not exist.</exception>
        </member>
        <member name="T:Au.Util.AMemory">
            <summary>
            Allocates memory from native heap of this process using heap API.
            Uses the common heap of this process, API <msdn>GetProcessHeap</msdn>.
            Usually slightly faster than Marshal class functions.
            </summary>
        </member>
        <member name="M:Au.Util.AMemory.Alloc(Au.Types.LPARAM,System.Boolean)">
            <summary>
            Allocates new memory block and returns its address.
            Calls API <msdn>HeapAlloc</msdn>.
            </summary>
            <param name="size">Byte count.</param>
            <param name="zeroInit">Set all bytes = 0. If false (default), the memory is uninitialized, ie random byte values. Slower when true.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably size is too big.</exception>
            <remarks>The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.Util.AMemory.Free(System.Void*)"/> when done or <see cref="M:Au.Util.AMemory.ReAlloc(System.Void*,Au.Types.LPARAM,System.Boolean)"/> if need to resize it without losing data.</remarks>
        </member>
        <member name="M:Au.Util.AMemory.ReAlloc(System.Void*,Au.Types.LPARAM,System.Boolean)">
            <summary>
            Reallocates a memory block to make it bigger or smaller.
            Returns its address, which in most cases is different than the old memory block address.
            Preserves data in Math.Min(old size, new size) bytes of old memory (copies from old memory if need).
            Calls API <msdn>HeapReAlloc</msdn> or <msdn>HeapAlloc</msdn>.
            </summary>
            <param name="mem">Old memory address. If null, allocates new memory like Alloc.</param>
            <param name="size">New byte count.</param>
            <param name="zeroInit">When size is growing, set all added bytes = 0. If false (default), the added memory is uninitialized, ie random byte values. Slower when true.</param>
            <exception cref="T:System.OutOfMemoryException">Failed. Probably size is too big.</exception>
            <remarks>The memory is unmanaged and will not be freed automatically. Always call <see cref="M:Au.Util.AMemory.Free(System.Void*)"/> when done or ReAlloc if need to resize it without losing data.</remarks>
        </member>
        <member name="M:Au.Util.AMemory.Free(System.Void*)">
            <summary>
            Frees a memory block.
            Does nothing if mem is null.
            Calls API <msdn>HeapFree</msdn>.
            </summary>
        </member>
        <member name="T:Au.Util.AMemoryArray">
            <summary>
            Allocates memory buffers that can be used with API functions and not only.
            Can allocate arrays of any value type - char[], byte[] etc.
            </summary>
            <example>
            <code><![CDATA[
            class Example
            {
            	public static void Test()
            	{
            		AWnd w = AWnd.FindFast(null, "Notepad");
            		string s = GetWndText(w);
            		Print(s);
            	}
            
            	public static string GetWndText(AWnd w)
            	{
            		for(int na = 300; ; na *= 2) {
            			var b = _GetCharBuffer(ref na);
            			int nr = GetWindowText(w, b, na);
            			if(nr < na - 1) return (nr > 0) ? b.ToString(nr) : "";
            		}
            	}
            
            	//this variable manages the buffer
            	[ThreadStatic] static WeakReference<char[]> t_char;
            
            	//a helper method
            	static Au.Util.AMemoryArray.CharBuffer _GetCharBuffer(ref int n) { var r = Au.Util.AMemoryArray.Get(n, ref t_char); n = r.Length - 1; return r; }
            
            	//we use this API in this example
            	[DllImport("user32.dll", EntryPoint = "GetWindowTextW")]
            	static extern int GetWindowText(AWnd hWnd, [Out] char[] lpString, int nMaxCount);
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.AMemoryArray.Get``1(System.Int32,System.WeakReference{``0[]}@)">
            <summary>
            Allocates new or gets "cached" array of type T of length n or more.
            The returned array is managed by a WeakReference&lt;T[]&gt; variable provided by the caller. Its contents is undefined.
            </summary>
            <typeparam name="T">Any simple value type, for example char, byte, RECT.</typeparam>
            <param name="n">
            How many elements you need.
            If array in the WeakReference variable is null or too small, creates new array and stores it there.
            For byte[] and char[] types actually allocates Math.Max(n, 300)+1 elements. The 300 is to avoid future reallocations. The +1 can be used for example for '\0' character at the end of string.</param>
            <param name="weakReference">
            A reference to a WeakReference variable that manages the returned array. If null, this function will create it.
            The variable should be [ThreadStatic] static. Or can be a non-static field of a long-living object. Must not be simply static, it's not thread-safe (unless locked).
            </param>
            <remarks>
            Used to avoid creating much garbage when array allocations are needed frequently. Also is faster than code like <c>var b=new byte[1000]</c> or StringBuilder.
            The WeakReference variable allows the array to be garbage-collected if it is not used when GC runs. It is automatic and safe. Next time this function will create new array.
            Actually this function is a wrapper for WeakReference&lt;T[]&gt; functions TryGetTarget/SetTarget. Makes it easier to use.
            </remarks>
        </member>
        <member name="T:Au.Util.AMemoryArray.CharBuffer">
            <summary>
            Provides functions to convert char[] to string easily.
            Assign char[] and call the ToString functions. Example: <see cref="T:Au.Util.AMemoryArray"/>.
            </summary>
        </member>
        <member name="F:Au.Util.AMemoryArray.CharBuffer.A">
            <summary>
            The array that is stored in this variable.
            </summary>
        </member>
        <member name="M:Au.Util.AMemoryArray.CharBuffer.op_Implicit(Au.Util.AMemoryArray.CharBuffer)~System.Char[]">
            
        </member>
        <member name="M:Au.Util.AMemoryArray.CharBuffer.op_Implicit(System.Char[])~Au.Util.AMemoryArray.CharBuffer">
            
        </member>
        <member name="M:Au.Util.AMemoryArray.CharBuffer.ToString">
            <summary>
            Converts the array, which contains native '\0'-terminated UTF-16 string, to String.
            Unlike code <c>new string(charArray)</c>, gets array part until '\0' character, not whole array.
            </summary>
        </member>
        <member name="M:Au.Util.AMemoryArray.CharBuffer.ToString(System.Int32)">
            <summary>
            Converts the array, which contains native UTF-16 string of n length, to String.
            Uses <c>new string(A, 0, n)</c>, which throws exception if the array is null or n is invalid.
            </summary>
            <param name="n">String length.</param>
        </member>
        <member name="M:Au.Util.AMemoryArray.CharBuffer.LibToStringFromAnsi(System.Int32,System.Text.Encoding)">
            <summary>
            Converts the buffer, which contains native ANSI string of n length, to String.
            </summary>
            <param name="n">String length.</param>
            <param name="enc">If null, uses system's default ANSI encoding.</param>
        </member>
        <member name="T:Au.Util.AMemoryBitmap">
            <summary>
            Creates and manages native bitmap handle and memory DC (GDI device context).
            The bitmap is selected in the DC.
            </summary>
        </member>
        <member name="P:Au.Util.AMemoryBitmap.Hdc">
            <summary>
            DC handle.
            </summary>
        </member>
        <member name="P:Au.Util.AMemoryBitmap.Hbitmap">
            <summary>
            Bitmap handle.
            </summary>
        </member>
        <member name="M:Au.Util.AMemoryBitmap.#ctor">
            <summary>
            Does nothing. Later you can call Create or Attach.
            </summary>
        </member>
        <member name="M:Au.Util.AMemoryBitmap.#ctor(System.Int32,System.Int32)">
            <summary>
            Calls <see cref="M:Au.Util.AMemoryBitmap.Create(System.Int32,System.Int32)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">width or height is less than 1.</exception>
            <exception cref="T:Au.Types.AuException">Failed. Probably there is not enough memory for bitmap of specified size (need with*height*4 bytes).</exception>
        </member>
        <member name="M:Au.Util.AMemoryBitmap.Dispose">
            <summary>
            Deletes the bitmap and DC.
            </summary>
        </member>
        <member name="M:Au.Util.AMemoryBitmap.Finalize">
            
        </member>
        <member name="M:Au.Util.AMemoryBitmap.GetHdc">
            
        </member>
        <member name="M:Au.Util.AMemoryBitmap.ReleaseHdc">
            
        </member>
        <member name="M:Au.Util.AMemoryBitmap.Delete">
            <summary>
            Deletes the bitmap and DC.
            </summary>
        </member>
        <member name="M:Au.Util.AMemoryBitmap.Create(System.Int32,System.Int32)">
            <summary>
            Creates new memory DC and bitmap of specified size and selects it into the DC.
            Returns false if failed.
            In any case deletes previous bitmap and DC.
            </summary>
            <param name="width">Width, pixels. Must be &gt; 0.</param>
            <param name="height">Height, pixels. Must be &gt; 0.</param>
        </member>
        <member name="M:Au.Util.AMemoryBitmap.Attach(System.IntPtr)">
            <summary>
            Sets this variable to manage an existing bitmap.
            Selects the bitmap into a memory DC.
            Deletes previous bitmap and DC.
            </summary>
            <param name="hBitmap">Native bitmap handle.</param>
        </member>
        <member name="M:Au.Util.AMemoryBitmap.Detach">
            <summary>
            Deletes memory DC, clears this variable and returns its bitmap (native bitmap handle).
            The returned bitmap is not selected into a DC. Will need to delete it with API DeleteObject.
            </summary>
        </member>
        <member name="T:Au.Util.AMenuItemInfo">
            <summary>
            Gets item id, text and other info of a classic popup menu.
            </summary>
        </member>
        <member name="M:Au.Util.AMenuItemInfo.FromXY(Au.Types.POINT,Au.AWnd,System.Int32)">
            <summary>
            Gets info of a menu item from point.
            Returns null if fails, eg the point is not in the menu or the window is hung.
            </summary>
            <param name="pScreen">Point in screen coordinates.</param>
            <param name="w">Popup menu window, class name "#32768".</param>
            <param name="msTimeout">Timeout (ms) to use when the window is busy or hung.</param>
        </member>
        <member name="M:Au.Util.AMenuItemInfo.FromXY(System.Int32)">
            <summary>
            Gets info of a menu item from mouse.
            Returns null if fails, eg the point is not in a menu or the window is hung.
            </summary>
            <param name="msTimeout">Timeout (ms) to use when the window is busy or hung.</param>
        </member>
        <member name="P:Au.Util.AMenuItemInfo.MenuHandle">
            <summary>
            Gets the popup menu handle.
            </summary>
        </member>
        <member name="P:Au.Util.AMenuItemInfo.ItemId">
            <summary>
            Gets menu item id.
            </summary>
        </member>
        <member name="P:Au.Util.AMenuItemInfo.OwnerWindow">
            <summary>
            Gets the owner window of the popup menu.
            </summary>
        </member>
        <member name="P:Au.Util.AMenuItemInfo.IsSystem">
            <summary>
            true if it is a system menu, eg when right-clicked the title bar of a window.
            </summary>
        </member>
        <member name="M:Au.Util.AMenuItemInfo.GetText(System.Boolean,System.Boolean)">
            <summary>
            Gets menu item text.
            Returns null if failed.
            </summary>
            <param name="removeHotkey">If contains '\t' character, get substring before it.</param>
            <param name="removeAmp">Call <see cref="M:Au.Util.AStringUtil.RemoveUnderlineAmpersand(System.String)"/>.</param>
        </member>
        <member name="M:Au.Util.AMenuItemInfo.GetText(System.IntPtr,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets menu item text.
            Returns null if failed.
            </summary>
            <param name="menuHandle"></param>
            <param name="id"></param>
            <param name="byIndex">id is 0-based index. For example you can use it to get text of a submenu-item, because such items usually don't have id.</param>
            <param name="removeHotkey">If contains '\t' character, get substring before it.</param>
            <param name="removeAmp">Call <see cref="M:Au.Util.AStringUtil.RemoveUnderlineAmpersand(System.String)"/>.</param>
        </member>
        <member name="T:Au.Util.AMessageLoop">
            <summary>
            A message loop, alternative to Application.Run which does not support nested loops.
            </summary>
        </member>
        <member name="M:Au.Util.AMessageLoop.Loop">
            <summary>
            Runs a message loop.
            </summary>
        </member>
        <member name="M:Au.Util.AMessageLoop.Stop">
            <summary>
            Ends the message loop, causing <see cref="M:Au.Util.AMessageLoop.Loop"/> to return.
            </summary>
        </member>
        <member name="T:Au.Util.ARecording">
            <summary>
            Functions for keyboard/mouse/etc recorder tools.
            </summary>
        </member>
        <member name="M:Au.Util.ARecording.MouseToString(System.Collections.Generic.IEnumerable{System.UInt32},System.Boolean)">
            <summary>
            Converts multiple recorded mouse movements to string for <see cref="M:Au.AMouse.MoveRecorded(System.String,System.Double)"/>.
            </summary>
            <param name="recorded">
            List of x y distances from previous.
            The first distance is from the mouse position before the first movement; at run time it will be distance from <see cref="P:Au.AMouse.LastXY"/>.
            To create uint value from distance dx dy use this code: <c>AMath.MakeUint(dx, dy)</c>.
            </param>
            <param name="withSleepTimes">
            <i>recorded</i> also contains sleep times (milliseconds) alternating with distances.
            It must start with a sleep time. Example: {time1, dist1, time2, dist2}. Another example: {time1, dist1, time2, dist2, time3}. This is invalid: {dist1, time1, dist2, time2}.
            </param>
        </member>
        <member name="T:Au.Util.AResources">
            <summary>
            Functions to work with managed resources.
            </summary>
        </member>
        <member name="M:Au.Util.AResources.GetAppResource(System.String)">
            <summary>
            Gets an Image or other object from managed resources of the app assembly (exe file).
            Returns null if not found.
            </summary>
            <param name="name">Resource name, like "example", not like "Project.Properties.Resources.example".</param>
            <remarks>
            Uses <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)"/>.
            The Image is not cached. Will need to Dispose.
            </remarks>
        </member>
        <member name="P:Au.Util.AResources.AppResourcesName">
            <summary>
            Full name of embedded resources file, like "Project.Properties.Resources.resources".
            Set this property once before calling <see cref="M:Au.Util.AResources.GetAppResource(System.String)"/>.
            If not set, it will look for resource where name ends with ".Resources.resources". If there is no such resources, uses the first.
            To see embedded resource file names you can use this code: <c>Print(System.Reflection.Assembly.GetEntryAssembly().GetManifestResourceNames()</c>.
            </summary>
        </member>
        <member name="M:Au.Util.AResources.LibGetAppResourceManager(System.Globalization.CultureInfo@)">
            <summary>
            Gets ResourceManager of the process entry assembly.
            Returns null if fails or if the assembly does not have resources.
            Note: if the assembly contains multiple embedded .resource files, may need to set <see cref="P:Au.Util.AResources.AppResourcesName"/> before.
            </summary>
        </member>
        <member name="T:Au.Util.ASecurity">
            <summary>
            Security-related functions, such as enabling privileges.
            </summary>
        </member>
        <member name="M:Au.Util.ASecurity.SetPrivilege(System.String,System.Boolean)">
            <summary>
            Enables or disables a privilege for this process.
            Returns false if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="privilegeName"></param>
            <param name="enable"></param>
        </member>
        <member name="T:Au.Util.ATreeBase`1">
            <summary>
            Base class for tree classes.
            The tree can be loaded/saved as XML.
            </summary>
            <remarks>
            Implemented in the same way as <see cref="T:System.Xml.Linq.XContainer"/>.
            </remarks>
            <example>
            Shows how to declare an ATreeBase-derived class, load tree of nodes from an XML file, print descendant nodes, save the tree to an XML file.
            <code><![CDATA[
            /*/ r System.Xml */
            using System.Xml;
            
            class MyTree :Au.Util.ATreeBase<MyTree>
            {
            	public string Name { get; set; }
            	public int Id { get; private set; }
            	public bool IsFolder { get; private set; }
            
            	public MyTree(string name, int id, bool isFolder) { Name = name; Id = id; IsFolder = isFolder; }
            
            	//XML element -> MyTree object
            	MyTree(XmlReader x, MyTree parent)
            	{
            		if(parent == null) { //the root XML element
            			if(x.Name != "example") throw new ArgumentException("XML root element name must be example");
            			IsFolder = true;
            		} else {
            			switch(x.Name) {
            			case "e": break;
            			case "f": IsFolder = true; break;
            			default: throw new ArgumentException("XML element name must be e or f");
            			}
            #if true //two ways of reading attributes
            			Name = x["name"];
            			Id = x["id"].ToInt();
            #else
            			while(x.MoveToNextAttribute()) {
            				var v = x.Value;
            				switch(x.Name) {
            				case "name": Name = v; break;
            				case "id": Id = v.ToInt(); break;
            				}
            			}
            #endif
            			if(Empty(Name)) throw new ArgumentException("no name attribute in XML");
            			if(Id == 0) throw new ArgumentException("no id attribute in XML");
            		}
            	}
            
            	public static MyTree Load(string file) => XmlLoad(file, (x, p) => new MyTree(x, p));
            
            	public void Save(string file) => XmlSave(file, (x, n) => n._XmlWrite(x));
            
            	//MyTree object -> XML element
            	void _XmlWrite(XmlWriter x)
            	{
            		if(Parent == null) {
            			x.WriteStartElement("example");
            		} else {
            			x.WriteStartElement(IsFolder ? "f" : "e");
            			x.WriteAttributeString("name", Name);
            			x.WriteAttributeString("id", Id.ToString());
            		}
            	}
            
            	public override string ToString() => $"{new string(' ', Level)}{(IsFolder ? 'f' : 'e')} {Name} ({Id})";
            }
            
            static void TNodeExample()
            {
            	/*
            	<example>
            	  <e name="one" id="1" />
            	  <f name="two" id="112">
            		<e name="three" id="113" />
            		<e name="four" id="114" />
            		<f name="five" id="120">
            		  <e name="six" id="121" />
            		  <e name="seven" id="122" />
            		</f>
            	  </f>
            	  <f name="eight" id="217" />
            	  <e name="ten" id="144" />
            	</example>
            	*/
            
            	var x = MyTree.Load(@"Q:\test\example.xml");
            	foreach(MyTree n in x.Descendants(true)) Print(n);
            	//Print(x.Descendants().FirstOrDefault(k => k.Name == "seven")); //find a descendant
            	//Print(x.Descendants().Where(k => k.Level > 2)); //find some descendants
            	x.Save(@"Q:\test\example2.xml");
            }
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Util.ATreeBase`1.Parent">
            <summary>
            Returns the parent node. Can be null.
            </summary>
        </member>
        <member name="P:Au.Util.ATreeBase`1.RootAncestor">
            <summary>
            Returns the root ancestor node. Its <see cref="P:Au.Util.ATreeBase`1.Parent"/> is null.
            Returns this node if its <b>Parent</b> is null.
            </summary>
        </member>
        <member name="P:Au.Util.ATreeBase`1.Level">
            <summary>
            Gets the number of ancestors (parent, its parent and so on).
            </summary>
        </member>
        <member name="M:Au.Util.ATreeBase`1.IsDescendantOf(`0)">
            <summary>
            Returns true if this node is a descendant of node n.
            </summary>
            <param name="n">Can be null.</param>
        </member>
        <member name="M:Au.Util.ATreeBase`1.IsAncestorOf(`0)">
            <summary>
            Returns true if this node is an ancestor of node n.
            </summary>
            <param name="n">Can be null.</param>
        </member>
        <member name="P:Au.Util.ATreeBase`1.HasParent">
            <summary>
            Returns true if <see cref="P:Au.Util.ATreeBase`1.Parent"/> is not null.
            </summary>
        </member>
        <member name="P:Au.Util.ATreeBase`1.HasChildren">
            <summary>
            Returns true if this node has child nodes.
            </summary>
        </member>
        <member name="P:Au.Util.ATreeBase`1.LastChild">
            <summary>
            Gets the last child node, or null if none.
            </summary>
        </member>
        <member name="P:Au.Util.ATreeBase`1.FirstChild">
            <summary>
            Gets the first child node, or null if none.
            </summary>
        </member>
        <member name="P:Au.Util.ATreeBase`1.Next">
            <summary>
            Gets next sibling node, or null if none.
            </summary>
        </member>
        <member name="P:Au.Util.ATreeBase`1.Previous">
            <summary>
            Gets previous sibling node, or null if none.
            </summary>
            <remarks>
            Can be slow if there are many siblings. This class does not have a 'previous' field and therefore has to walk the linked list of siblings.
            </remarks>
        </member>
        <member name="P:Au.Util.ATreeBase`1.Index">
            <summary>
            Returns 0-based index of this node in parent.
            Returns -1 if no parent.
            </summary>
            <remarks>
            Can be slow if there are many siblings. This class does not have an 'index' field and therefore has to walk the linked list of siblings.
            </remarks>
        </member>
        <member name="M:Au.Util.ATreeBase`1.AddChild(`0,System.Boolean)">
            <summary>
            Adds node n to this node as a child.
            </summary>
            <param name="n"></param>
            <param name="first">Insert n as the first child node. If false (default), appends to the end.</param>
            <exception cref="T:System.ArgumentException">n is null, or has parent (need to <see cref="M:Au.Util.ATreeBase`1.Remove"/> at first), or is this node, or an ancestor of this node.</exception>
        </member>
        <member name="M:Au.Util.ATreeBase`1.AddSibling(`0,System.Boolean)">
            <summary>
            Inserts node n before or after this node as a sibling.
            </summary>
            <param name="n"></param>
            <param name="after">Insert n after this node. If false (default), inserts before this node.</param>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.Util.ATreeBase`1.AddChild(`0,System.Boolean)"/>.</exception>
            <exception cref="T:System.InvalidOperationException">This node does not have parent (<see cref="P:Au.Util.ATreeBase`1.Parent"/> is null).</exception>
        </member>
        <member name="M:Au.Util.ATreeBase`1.Remove">
            <summary>
            Removes this node from its parent.
            </summary>
            <remarks>
            After removing, the <see cref="P:Au.Util.ATreeBase`1.Parent"/> property is null.
            Does nothing if <b>Parent</b> is null.
            </remarks>
        </member>
        <member name="M:Au.Util.ATreeBase`1.Ancestors(System.Boolean,System.Boolean)">
            <summary>
            Gets ancestor nodes (parent, its parent and so on).
            The order is from <see cref="P:Au.Util.ATreeBase`1.Parent"/> to <see cref="P:Au.Util.ATreeBase`1.RootAncestor"/>.
            </summary>
            <param name="andSelf">Include this node.</param>
            <param name="noRoot">Don't include <see cref="P:Au.Util.ATreeBase`1.RootAncestor"/>.</param>
        </member>
        <member name="M:Au.Util.ATreeBase`1.AncestorsReverse(System.Boolean,System.Boolean)">
            <summary>
            Gets ancestor nodes in reverse order than <see cref="M:Au.Util.ATreeBase`1.Ancestors(System.Boolean,System.Boolean)"/>.
            </summary>
            <param name="andSelf">Include this node. Default false.</param>
            <param name="noRoot">Don't include <see cref="P:Au.Util.ATreeBase`1.RootAncestor"/>.</param>
        </member>
        <member name="M:Au.Util.ATreeBase`1.Children(System.Boolean)">
            <summary>
            Gets all direct child nodes.
            </summary>
            <param name="andSelf">Include this node. Default false.</param>
        </member>
        <member name="M:Au.Util.ATreeBase`1.Descendants(System.Boolean)">
            <summary>
            Gets all descendant nodes (direct children, their children and so on).
            </summary>
            <param name="andSelf">Include this node. Default false.</param>
        </member>
        <member name="T:Au.Util.ATreeBase`1.XmlNodeReader">
            <summary>
            Used with <see cref="M:Au.Util.ATreeBase`1.XmlLoad(System.String,Au.Util.ATreeBase{`0}.XmlNodeReader)"/>
            </summary>
        </member>
        <member name="T:Au.Util.ATreeBase`1.XmlNodeWriter">
            <summary>
            Used with <see cref="M:Au.Util.ATreeBase`1.XmlSave(System.String,Au.Util.ATreeBase{`0}.XmlNodeWriter,System.Xml.XmlWriterSettings,System.Collections.Generic.IEnumerable{`0})"/>
            </summary>
        </member>
        <member name="M:Au.Util.ATreeBase`1.XmlLoad(System.String,Au.Util.ATreeBase{`0}.XmlNodeReader)">
            <summary>
            Loads XML file and creates tree of nodes from it.
            Returns the root node.
            </summary>
            <param name="file">XML file. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.</param>
            <param name="nodeReader">Callback function that reads current XML element and creates/returns new node. See example.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.XmlReader.Create(System.String)"/>.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
            <example><see cref="T:Au.Util.ATreeBase`1"/></example>
        </member>
        <member name="M:Au.Util.ATreeBase`1.XmlLoad(System.Xml.XmlReader,Au.Util.ATreeBase{`0}.XmlNodeReader)">
            <summary>
            Reads XML and creates tree of nodes.
            Returns the root node.
            </summary>
            <param name="x"></param>
            <param name="nodeReader"></param>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
            <remarks>More info: <see cref="M:Au.Util.ATreeBase`1.XmlLoad(System.String,Au.Util.ATreeBase{`0}.XmlNodeReader)"/>.</remarks>
            <example><see cref="T:Au.Util.ATreeBase`1"/></example>
        </member>
        <member name="M:Au.Util.ATreeBase`1.XmlSave(System.String,Au.Util.ATreeBase{`0}.XmlNodeWriter,System.Xml.XmlWriterSettings,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Saves tree of nodes (this and descendants) to an XML file.
            </summary>
            <param name="file">XML file. Must be full path. Can contain environment variables etc, see <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.</param>
            <param name="nodeWriter">Callback function that writes node's XML start element (see <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/>) and attributes (see <see cref="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String)"/>). Must not write children and end element. Also should not write value, unless your reader knows how to read it.</param>
            <param name="sett">XML formatting settings. Optional.</param>
            <param name="children">If not null, writes these nodes as if they were children of this node.</param>
            <exception cref="T:System.ArgumentException">Not full path.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:System.Xml.XmlWriter.Create(System.String)"/> and other <b>XmlWriter</b> methods.</exception>
            <remarks>
            Uses <see cref="M:Au.AFile.Save(System.String,System.Action{System.String},System.Boolean,System.String,System.Int32)"/>. It ensures that existing file data is not damaged on exception etc.
            </remarks>
            <example><see cref="T:Au.Util.ATreeBase`1"/></example>
        </member>
        <member name="M:Au.Util.ATreeBase`1.XmlSave(System.Xml.XmlWriter,Au.Util.ATreeBase{`0}.XmlNodeWriter,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Writes tree of nodes (this and descendants) to an <see cref="T:System.Xml.XmlWriter"/>.
            </summary>
            <param name="x"></param>
            <param name="nodeWriter"></param>
            <param name="children"></param>
            <remarks>More info: <see cref="M:Au.Util.ATreeBase`1.XmlSave(System.String,Au.Util.ATreeBase{`0}.XmlNodeWriter,System.Xml.XmlWriterSettings,System.Collections.Generic.IEnumerable{`0})"/>.</remarks>
            <exception cref="T:System.Exception">Exceptions of <b>XmlWriter</b> methods.</exception>
            <example><see cref="T:Au.Util.ATreeBase`1"/></example>
        </member>
        <member name="T:Au.Util.AWaitableTimer">
            <summary>
            Wraps a waitable timer handle.
            </summary>
            <remarks>
            More info: API <msdn>CreateWaitableTimer</msdn>.
            </remarks>
        </member>
        <member name="M:Au.Util.AWaitableTimer.Create(System.Boolean,System.String)">
            <summary>
            Calls API <msdn>CreateWaitableTimer</msdn> and creates an AWaitableTimer object that wraps the timer handle.
            </summary>
            <param name="manualReset"></param>
            <param name="timerName">Timer name. If a timer with this name already exists, opens it if possible. If null, creates unnamed timer.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, a non-timer kernel object with this name already exists.</exception>
        </member>
        <member name="M:Au.Util.AWaitableTimer.Open(System.String,System.UInt32,System.Boolean,System.Boolean)">
            <summary>
            Calls API <msdn>OpenWaitableTimer</msdn> and creates an AWaitableTimer object that wraps the timer handle.
            </summary>
            <param name="timerName">Timer name. Fails if it does not exist; to open-or-create use <see cref="M:Au.Util.AWaitableTimer.Create(System.Boolean,System.String)"/>.</param>
            <param name="access">.See <msdn>Synchronization Object Security and Access Rights</msdn>. The default value TIMER_MODIFY_STATE|SYNCHRONIZE allows to set and wait.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, a non-timer kernel object with this name already exists.</exception>
            <param name="inheritHandle"></param>
            <param name="noException">If fails, return null, don't throw exception. Supports <see cref="T:Au.ALastError"/>.</param>
            <exception cref="T:Au.Types.AuException">Failed. For example, the timer does not exist.</exception>
        </member>
        <member name="M:Au.Util.AWaitableTimer.Set(System.Int64,System.Int32)">
            <summary>
            Calls API <msdn>SetWaitableTimer</msdn>.
            Returns false if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="dueTime">
            The time after which the state of the timer is to be set to signaled. It is relative time (from now).
            If positive, in milliseconds. If negative, in 100 nanosecond intervals (microseconds*10), see <msdn>FILETIME</msdn>.
            Also can be 0, to set minimal time.</param>
            <param name="period">The period of the timer, in milliseconds. If 0, the timer is signaled once. If greater than 0, the timer is periodic.</param>
            <exception cref="T:System.OverflowException">dueTime*10000 is greater than long.MaxValue.</exception>
        </member>
        <member name="M:Au.Util.AWaitableTimer.SetAbsolute(System.DateTime,System.Int32)">
            <summary>
            Calls API <msdn>SetWaitableTimer</msdn>.
            Returns false if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="dueTime">The UTC date/time at which the state of the timer is to be set to signaled.</param>
            <param name="period">The period of the timer, in milliseconds. If 0, the timer is signaled once. If greater than 0, the timer is periodic.</param>
        </member>
        <member name="T:Au.Util.AWinFormsControlNames">
            <summary>
            Gets programming names of .NET Windows Forms controls.
            </summary>
            <remarks>
            Usually each control has a unique name. It is useful to identify controls without a classic name/text.
            The control id of these controls is not useful, it is not constant.
            </remarks>
        </member>
        <member name="M:Au.Util.AWinFormsControlNames.Dispose">
            
        </member>
        <member name="M:Au.Util.AWinFormsControlNames.#ctor(Au.AWnd)">
            <summary>
            Prepares to get control names.
            </summary>
            <param name="w">Any top-level or child window of that process.</param>
            <exception cref="T:Au.Types.AuWndException">w invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed to allocate process memory (see <see cref="T:Au.AProcessMemory"/>) needed to get control names, usually because of [](xref:uac).</exception>
        </member>
        <member name="M:Au.Util.AWinFormsControlNames.GetControlName(Au.AWnd)">
            <summary>
            Gets control name.
            Returns null if fails or the name is empty.
            </summary>
            <param name="c">The control. Can be a top-level window too. Must be of the same process as the window specified in the constructor.</param>
        </member>
        <member name="M:Au.Util.AWinFormsControlNames.IsWinFormsControl(Au.AWnd)">
            <summary>
            Returns true if window class name starts with "WindowsForms".
            Usually it means that we can get Windows Forms control name of w and its child controls.
            </summary>
            <param name="w">The window. Can be top-level or control.</param>
        </member>
        <member name="M:Au.Util.AWinFormsControlNames.GetSingleControlName(Au.AWnd)">
            <summary>
            Gets the programming name of a Windows Forms control.
            Returns null if it is not a Windows Forms control or if fails.
            </summary>
            <param name="c">The control. Can be top-level window too.</param>
            <remarks>This function is easy to use and does not throw excaptions. However, when you need names of multiple controls of a single window, better create an AWinFormsControlNames instance (once) and for each control call its GetControlNameOrText method, it will be faster.</remarks>
        </member>
        <member name="T:Au.Util.LibScreenDC">
            <summary>
            Helps to get and release screen DC with the 'using(...){...}' pattern.
            Uses API GetDC and ReleaseDC.
            </summary>
        </member>
        <member name="T:Au.Util.LibWindowDC">
            <summary>
            Helps to get and release window DC with the 'using(...){...}' pattern.
            Uses API GetDC and ReleaseDC.
            If w is default(AWnd), gets screen DC.
            </summary>
        </member>
        <member name="T:Au.Util.LibCompatibleDC">
            <summary>
            Helps to create and delete screen DC with the 'using(...){...}' pattern.
            Uses API CreateCompatibleDC and DeleteDC.
            </summary>
        </member>
        <member name="T:Au.Util.LibNativeFont">
            <summary>
            Creates and manages native font handle.
            </summary>
        </member>
        <member name="P:Au.Util.LibNativeFont.RegularCached">
            <summary>
            Cached standard font used by most windows and controls.
            On Windows 10 it is "Segoe UI" 9 by default.
            </summary>
        </member>
        <member name="P:Au.Util.LibNativeFont.BoldCached">
            <summary>
            Cached standard bold font used by most windows and controls.
            </summary>
        </member>
        <member name="P:Au.Util.LibNativeFont.Verdana9Cached">
            <summary>
            Cached font "Verdana" 9.
            Used eg by ADialog for input Edit control.
            </summary>
        </member>
        <member name="T:Au.Util.IconsAsync">
            <summary>
            Gets file icons asynchronously.
            </summary>
            <remarks>
            Use to avoid waiting until all icons are extracted before displaying them in a UI (menu etc).
            Instead you show the UI without icons, and then asynchronously receive icons when they are extracted.
            At first call <see cref="M:Au.Util.IconsAsync.Add(System.String,System.Object)"/> (for each file) or <see cref="M:Au.Util.IconsAsync.AddRange(System.Collections.Generic.IEnumerable{Au.Util.IconsAsync.Item})"/>. Then call <see cref="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)"/>.
            Create a callback function of type <see cref="T:Au.Util.IconsAsync.Callback"/> and pass its delegate to <b>GetAllAsync</b>.
            </remarks>
            <seealso cref="T:Au.AIconCache"/>
        </member>
        <member name="M:Au.Util.IconsAsync.Add(System.String,System.Object)">
            <summary>
            Adds a file path to an internal collection.
            </summary>
            <param name="file">File path etc. See <see cref="M:Au.AIcon.GetFileIcon(System.String,System.Int32,Au.Types.GIFlags)"/>.</param>
            <param name="obj">Something to pass to your callback function together with icon handle for this file.</param>
        </member>
        <member name="M:Au.Util.IconsAsync.AddRange(System.Collections.Generic.IEnumerable{Au.Util.IconsAsync.Item})">
            <summary>
            Adds multiple file paths to an internal collection.
            The same as calling <see cref="M:Au.Util.IconsAsync.Add(System.String,System.Object)"/> multiple times.
            This function copies the list.
            </summary>
        </member>
        <member name="P:Au.Util.IconsAsync.Count">
            <summary>
            Gets the number of added items.
            <see cref="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)"/> sets it = 0.
            </summary>
        </member>
        <member name="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)">
            <summary>
            Starts getting icons of added files.
            </summary>
            <param name="callback">A callback function delegate.</param>
            <param name="iconSize">Icon width and height. Also can be enum <see cref="T:Au.Types.IconSize"/>, cast to int.</param>
            <param name="flags"><see cref="T:Au.Types.GIFlags"/></param>
            <param name="objCommon">Something to pass to callback functions.</param>
            <remarks>
            After this function returns, icons are asynchronously extracted with <see cref="M:Au.AIcon.GetFileIconHandle(System.String,System.Int32,Au.Types.GIFlags)"/>, and callback called with icon handle (or default(IntPtr) if failed).
            The callback is called in this thread. This thread must have a message loop (eg Application.Run).
            If you'll need more icons, you can add more files and call this function again with the same <b>IconsAsync</b> instance, even if getting old icons if still not finished.
            </remarks>
        </member>
        <member name="M:Au.Util.IconsAsync.Clear">
            <summary>
            Clears the internal collection of file paths added with Add().
            </summary>
        </member>
        <member name="M:Au.Util.IconsAsync.Cancel">
            <summary>
            Stops getting icons and calling callback functions.
            </summary>
        </member>
        <member name="M:Au.Util.IconsAsync.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.IconsAsync.Cancel"/>.
            </summary>
        </member>
        <member name="M:Au.Util.IconsAsync.Finalize">
            
        </member>
        <member name="T:Au.Util.IconsAsync.Item">
            <summary>
            For <see cref="M:Au.Util.IconsAsync.AddRange(System.Collections.Generic.IEnumerable{Au.Util.IconsAsync.Item})"/>. 
            </summary>
        </member>
        <member name="T:Au.Util.IconsAsync.Result">
            <summary>
            For <see cref="T:Au.Util.IconsAsync.Callback"/>. 
            </summary>
        </member>
        <member name="F:Au.Util.IconsAsync.Result.file">
            <summary>file passed to <see cref="M:Au.Util.IconsAsync.Add(System.String,System.Object)"/>.</summary>
        </member>
        <member name="F:Au.Util.IconsAsync.Result.obj">
            <summary>obj passed to <see cref="M:Au.Util.IconsAsync.Add(System.String,System.Object)"/>.</summary>
        </member>
        <member name="F:Au.Util.IconsAsync.Result.hIcon">
            <summary>Icon handle. To get managed object from it, use <b>AIcon.HandleToX</b> functions; else finally call <see cref="M:Au.AIcon.DestroyIconHandle(System.IntPtr)"/>. Can be default(IntPtr).</summary>
        </member>
        <member name="M:Au.Util.IconsAsync.Result.#ctor(System.String,System.Object)">
            <summary>Icon converted to Image object, if used IconFlags.NeedImage and the thread pool decided to convert handle to Image. You should call Dispose() when finished using it. Can be null.</summary>
        </member>
        <member name="T:Au.Util.IconsAsync.Callback">
            <summary>
            For <see cref="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)"/>. 
            </summary>
            <param name="result">Contains icon, as well as the input parameters.</param>
            <param name="objCommon">objCommon passed to <see cref="M:Au.Util.IconsAsync.GetAllAsync(Au.Util.IconsAsync.Callback,System.Int32,Au.Types.GIFlags,System.Object)"/>.</param>
            <param name="nLeft">How many icons is still to get. Eg 0 if this is the last icon.</param>
        </member>
        <member name="P:Au.Util.ILInstruction.RawData">
            <summary>
            Gets the raw data.
            </summary>
        </member>
        <member name="P:Au.Util.ILInstruction.Data">
            <summary>
            Gets the data.
            </summary>
        </member>
        <member name="P:Au.Util.ILInstruction.Address">
            <summary>
            Gets the address of the instruction.
            </summary>
        </member>
        <member name="P:Au.Util.ILInstruction.InstructionIndex">
            <summary>
            Gets the index of the instruction.
            </summary>
            <value>
            The index of the instruction.
            </value>
        </member>
        <member name="P:Au.Util.ILInstruction.DataValue">
            <summary>
            Gets the value as integer
            </summary>
            <value>The data value.</value>
        </member>
        <member name="P:Au.Util.ILInstruction.Length">
            <summary>
            Gets the length of the instructions and operands.
            </summary>
            <value>The length.</value>
        </member>
        <member name="T:Au.Util.ILReader">
            <summary>
            Reads IL instructions from a byte stream.
            </summary>
            <remarks>Allows generated code to be viewed without debugger or enabled debug assemblies.</remarks>
        </member>
        <member name="F:Au.Util.ILReader.instructionLookup">
            <summary>
            The _instruction lookup.
            </summary>
        </member>
        <member name="F:Au.Util.ILReader.intermediateLanguageProvider">
            <summary>
            The IL reader provider.
            </summary>
        </member>
        <member name="M:Au.Util.ILReader.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Au.Util.ILReader"/> class.
            </summary>
            <param name="method">
            The method.
            </param>
        </member>
        <member name="P:Au.Util.ILReader.Instructions">
            <summary>
            Gets the instructions.
            </summary>
            <value>The instructions.</value>
        </member>
        <member name="M:Au.Util.ILReader.CreateILReaderProvider(System.Reflection.MethodInfo)">
            <summary>
            Creates the IL reader provider.
            </summary>
            <param name="methodInfo">The MethodInfo object that represents the method to read..</param>
            <returns>
            The ILReader provider.
            </returns>
        </member>
        <member name="M:Au.Util.ILReader.IsInstructionPrefix(System.Int16)">
            <summary>
            Checks to see if the IL instruction is a prefix indicating the length of the instruction is two bytes long.
            </summary>
            <param name="value">The IL instruction as a byte.</param>
            <remarks>IL instructions can either be 1 or 2 bytes.</remarks>
            <returns>True if this IL instruction is a prefix indicating the instruction is two bytes long.</returns>
        </member>
        <member name="M:Au.Util.ILReader.GetLookupTable">
            <summary>
            The get lookup table.
            </summary>
            <returns>
            A dictionary of IL instructions.
            </returns>
        </member>
        <member name="M:Au.Util.ILReader.GetSize(System.Reflection.Emit.OperandType)">
            <summary>
            Gets the size of a operand.
            </summary>
            <param name="operandType">Defines the type of operand.</param>
            <returns>The size in bytes of the operand type.</returns>
        </member>
        <member name="T:Au.Util.LibActCtx">
            <summary>
            Activates our manifest which tells to use comctl32.dll version 6.
            The manifest is embedded in this dll, resource id 2.
            </summary>
        </member>
        <member name="T:Au.Util.LibArrayBuilder`1">
            <summary>
            Like List or StringBuilder, used as a temporary variable-size array to create final fixed-size array.
            To avoid much garbage (and many reallocations when growing), uses native memory heap. See <see cref="T:Au.Util.AMemory"/>.
            Must be explicitly disposed to free the native memory. Does not have a finalizer because is struct (to avoid garbage).
            Does not support reference types. Does not call T.Dispose.
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Ptr">
            <summary>
            Gets array memory address (address of element 0).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Count">
            <summary>
            Gets the number of elements.
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.ByteCount">
            <summary>
            Gets the number of bytes in the array (Count*sizeof(T)).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Capacity">
            <summary>
            Gets or sets the total number of elements (not bytes) the internal memory can hold without resizing.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">(the 'set' function) value less than Count. Instead use ReAlloc or Free.</exception>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Alloc(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Allocates count elements. Sets Count=count.
            Frees previously allocated memory.
            Returns memory address (address of element 0).
            </summary>
            <param name="count">Element count.</param>
            <param name="zeroInit">Set all bytes = 0. If false, the memory is uninitialized, ie random byte values. Default true. Slower when true.</param>
            <param name="noExtra">Set Capacity = count. If false, allocates more if count is less thah the minimal capacity for this type.</param>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.ReAlloc(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Adds or removes elements at the end. Sets Count=count.
            Preserves Math.Min(Count, count) existing elements.
            Returns memory address (address of element 0).
            </summary>
            <param name="count">New element count.</param>
            <param name="zeroInit">Set all added bytes = 0. If false, the added memory is uninitialized, ie random byte values. Default true. Slower when true.</param>
            <param name="noExtra">Set Capacity = count. If false, allocates more if count is less thah the minimal capacity for this type.</param>
            <remarks>
            The new memory usually is at a new location. The preserved elements are copied there.
            Sets Count=count. To allocate more memory without changing Count, change Capacity instead.
            </remarks>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Free">
            <summary>
            Frees memory. Sets Count and Capacity = 0.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.AddR(`0@)">
            <summary>
            Adds one element.
            The same as Add, but uses 'in'. Use to avoid copying values of big types.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Add(`0)">
            <summary>
            Adds one element.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.Add">
            <summary>
            Adds one zero-inited element and returns its reference.
            </summary>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1._EnsureCapacity">
            <summary>
            Capacity = Math.Max(_cap * 2, s_minCap).
            </summary>
        </member>
        <member name="P:Au.Util.LibArrayBuilder`1.Item(System.Int32)">
            <summary>
            Gets element reference.
            </summary>
            <param name="i">Element index.</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:Au.Util.LibArrayBuilder`1.ToArray">
            <summary>
            Copies elements to a new managed array.
            </summary>
        </member>
        <member name="T:Au.Util.LibAssembly">
            <summary>
            Assembly functions.
            </summary>
        </member>
        <member name="M:Au.Util.LibAssembly.LibIsLoadedFormsWpf">
            <summary>
            Returns flags for loaded assemblies: 1 System.Windows.Forms, 2 WindowsBase (WPF).
            </summary>
        </member>
        <member name="T:Au.Util.LibAssertListener">
            <summary>
            .NET Core does not show the classic Debug.Assert message box. This class shows it. Call <see cref="M:Au.Util.LibAssertListener.Setup"/> once.
            The Write[Line] and Fail methods write line to QM2.
            If debugger attached, breaks and does not show message box.
            </summary>
        </member>
        <member name="T:Au.Util.LibAttachThreadInput">
            <summary>
            Calls API <msdn>AttachThreadInput</msdn> to attach/detach thread input.
            Constructor attaches thread input of this thread to that of the specified thread. <b>Dispose</b> detaches.
            </summary>
        </member>
        <member name="M:Au.Util.LibAttachThreadInput.#ctor(System.Int32,System.Boolean@)">
            <summary>
            Attaches thread input of this thread to that of the specified thread.
            </summary>
        </member>
        <member name="M:Au.Util.LibAttachThreadInput.Dispose">
            <summary>
            Detaches thread input.
            </summary>
        </member>
        <member name="P:Au.Util.LibAttachThreadInput.IsAttached">
            <summary>
            Returns true if AttachThreadInput succeeded and this variable is not disposed.
            </summary>
        </member>
        <member name="T:Au.Util.LibCharPtr">
            <summary>
            String functions that work with unmanaged char* strings.
            See also <see cref="T:Au.Util.LibBytePtr"/>, it works with byte* strings.
            </summary>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Char*)">
            <summary>
            Gets the number of characters in p until '\0'.
            </summary>
            <param name="p">'\0'-terminated string. Can be null.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Length(System.Char*,System.Int32)">
            <summary>
            Gets the number of characters in p until '\0' or <i>max</i>.
            </summary>
            <param name="p">'\0'-terminated string. Can be null.</param>
            <param name="max">Max length to scan. Returns max if does not find '\0'.</param>
        </member>
        <member name="M:Au.Util.LibCharPtr.Eq(System.Char*,System.Int32,System.String)">
            <summary>
            Case-sensitive compares string with managed string and returns true if they are equal.
            </summary>
            <param name="p">Unmanaged string.</param>
            <param name="len">p length. Returns false if it is != s.Length.</param>
            <param name="s">Managed string.</param>
        </member>
        <member name="T:Au.Util.LibBytePtr">
            <summary>
            String functions that work with unmanaged byte* strings.
            See also <see cref="T:Au.Util.LibCharPtr"/>, it works with char* strings.
            </summary>
        </member>
        <member name="M:Au.Util.LibBytePtr.Length(System.Byte*)">
            <summary>
            Gets the number of bytes in p until '\0'.
            </summary>
            <param name="p">'\0'-terminated string. Can be null.</param>
        </member>
        <member name="M:Au.Util.LibBytePtr.Length(System.Byte*,System.Int32)">
            <summary>
            Gets the number of bytes in p until '\0' or <i>max</i>.
            </summary>
            <param name="p">'\0'-terminated string. Can be null.</param>
            <param name="max">Max length to scan. Returns max if does not find '\0'.</param>
        </member>
        <member name="M:Au.Util.LibBytePtr.AsciiStarts(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged string p starts with string s. Case-sensitive.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.Util.LibBytePtr.AsciiStartsi(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged string p starts with string s. Case-insensitive.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.Util.LibBytePtr.AsciiEq(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged string p and string s are equal. Case-sensitive.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Managed string. Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.Util.LibBytePtr.AsciiEqi(System.Byte*,System.String)">
            <summary>
            Returns true if unmanaged string p and string s are equal. Case-insensitive.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.Util.LibBytePtr.Eq(System.Byte*,System.Byte[])">
            <summary>
            Case-sensitive compares unmanaged string p with byte[] s and returns true if they are equal.
            </summary>
            <param name="p">'\0'-terminated string.</param>
            <param name="s">Managed string. Must contain only ASCII characters.</param>
        </member>
        <member name="M:Au.Util.LibBytePtr.AsciiFindChar(System.Byte*,System.Int32,System.Byte)">
            <summary>
            Finds character in string which can be binary.
            </summary>
            <param name="p"></param>
            <param name="len">Length of p to search in.</param>
            <param name="ch">ASCII character.</param>
        </member>
        <member name="M:Au.Util.LibBytePtr.AsciiFindString(System.Byte*,System.Int32,System.String)">
            <summary>
            Finds substring in string which can be binary.
            Returns -1 if not found.
            </summary>
            <param name="p"></param>
            <param name="len">Length of p to search in.</param>
            <param name="s">Substring to find. Must contain only ASCII characters.</param>
        </member>
        <member name="T:Au.Util.LibEnsureWindowsFormsSynchronizationContext">
            <summary>
            Constructor ensures that current SynchronizationContext of this thread is WindowsFormsSynchronizationContext.
            Also sets WindowsFormsSynchronizationContext.AutoInstall=false to prevent Application.DoEvents etc setting wrong context.
            Dispose() restores both if need. Does not restore context if was null.
            Example: using(new Util.LibEnsureWindowsFormsSynchronizationContext()) { ... }
            </summary>
        </member>
        <member name="M:Au.Util.LibEnsureWindowsFormsSynchronizationContext.#ctor(System.Boolean)">
            <summary>
            See class help.
            </summary>
            <param name="onlyIfAutoInstall">Do nothing if WindowsFormsSynchronizationContext.AutoInstall==false. Normally WindowsFormsSynchronizationContext.AutoInstall is true (default).</param>
        </member>
        <member name="M:Au.Util.LibEnsureWindowsFormsSynchronizationContext.EnsurePermanently">
            <summary>
            If synchronization context of this thread is null or not WindowsFormsSynchronizationContext, makes it WindowsFormsSynchronizationContext.
            Use this instead of creating instance when will not need to restore previous synchronization context.
            </summary>
            <exception cref="T:System.InvalidOperationException">This thread has a synchronization context other than WindowsFormsSynchronizationContext or null. Or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="M:Au.Util.LibProcessStarter.#ctor(System.String,System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Prepares parameters for API <msdn>CreateProcess</msdn> and similar.
            </summary>
            <param name="exe">
            Full path of program file. If not full path, uses <see cref="P:Au.AFolders.ThisApp"/>. Uses <see cref="M:Au.APath.Normalize(System.String,System.String,Au.Types.PNFlags)"/>.
            If <i>rawExe</i> true, does not use <b>Normalize</b>/<b>ThisApp</b>.
            </param>
            <param name="args">null or command line arguments.</param>
            <param name="curDir">
            Initial current directory of the new process.
            - If null, uses <c>Directory.GetCurrentDirectory()</c>.
            - Else if <i>rawCurDir</i>==true, uses raw <i>curDir</i> value.
            - Else if "", calls <c>APath.GetDirectoryPath(exe)</c>.
            - Else calls <see cref="M:Au.APath.ExpandEnvVar(System.String)"/>.
            </param>
            <param name="envVar">null or environment variables to pass to the new process together with variables of this process. Format: "var1=value1\0var2=value2\0". If ends with "\0\0", will pass only these variables.</param>
            <param name="rawExe">Don't normalize <i>exe</i>.</param>
            <param name="rawCurDir">Don't normalize <i>curDir</i>.</param>
        </member>
        <member name="M:Au.Util.LibProcessStarter.StartLL(Au.Types.Api.PROCESS_INFORMATION@,System.Boolean,System.Boolean)">
            <summary>
            Starts process using API CreateProcess or CreateProcessAsUser, without the feedback hourglass cursor.
            </summary>
            <param name="pi">Receives CreateProcessX results. Will need to close handles in pi, eg pi.Dispose.</param>
            <param name="inheritUiaccess">If this process has UAC integrity level uiAccess, let the new process inherit it.</param>
            <param name="inheritHandles">API parameter <i>bInheritHandles</i>.</param>
        </member>
        <member name="M:Au.Util.LibProcessStarter.Start(Au.Util.LibProcessStarter.Result.Need,System.Boolean)">
            <summary>
            Starts process using API CreateProcess or CreateProcessAsUser, without the feedback hourglass cursor.
            </summary>
            <param name="need">Which field to set in <b>Result</b>.</param>
            <param name="inheritUiaccess">If this process has UAC integrity level uiAccess, let the new process inherit it.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
        </member>
        <member name="M:Au.Util.LibProcessStarter.StartUserIL(Au.Util.LibProcessStarter.Result.Need)">
            <summary>
            Starts UAC Medium integrity level (IL) process from this admin process.
            </summary>
            <param name="need">Which field to set in <b>Result</b>.</param>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Actually the process will have the same IL and user session as the shell process (normally explorer).
            Fails if there is no shell process (API GetShellWindow fails) for more than 2 s from calling this func.
            Asserts and fails if this is not admin/system process. Caller should at first call <see cref="P:Au.AUac.IsAdmin"/> or <see cref="P:Au.AUac.IntegrityLevel"/>.
            </remarks>
        </member>
        <member name="T:Au.Util.LibProcessStarter.Result">
            <summary>
            Results of <see cref="T:Au.Util.LibProcessStarter"/> functions.
            </summary>
        </member>
        <member name="T:Au.Util.LibProcessStarter.Result.Need">
            <summary>
            Which field to set.
            </summary>
        </member>
        <member name="T:Au.Util.LibProcessStarter._NetProcessObject">
            <summary>
            Creates new .NET Process object with attached handle and/or id.
            </summary>
        </member>
        <member name="P:Au.Util.LibProcessStarter._NetProcessObject.IsFast">
            <summary>
            Returns true if can create such object in a fast/reliable way. Else <see cref="M:Au.Util.LibProcessStarter._NetProcessObject.Create(System.IntPtr,System.Int32)"/> will use Process.GetProcessById.
            It depends on .NET framework version, because uses private methods of Process class through reflection.
            </summary>
        </member>
        <member name="M:Au.Util.LibProcessStarter._NetProcessObject.Create(System.IntPtr,System.Int32)">
            <summary>
            Creates new .NET Process object with attached handle and/or id.
            Can be specified both handle and id, or one of them (then .NET will open process or get id from handle when need).
            </summary>
        </member>
        <member name="M:Au.Util.LibProcessStarter._NetProcessObject.Create(Au.Types.Api.PROCESS_INFORMATION@,System.Boolean)">
            <summary>
            Creates new .NET Process object with attached handle and id.
            Closes thread handle. If suspended, resumes thread.
            </summary>
        </member>
        <member name="T:Au.Util.LibSerializer">
            <summary>
            Binary-serializes and deserializes multiple values of types int, string, string[], byte[] and null.
            Used mostly for sending parameters for IPC through pipe etc.
            Similar to BinaryWriter, but faster and less garbage. Much faster than BinaryFormatter, CSV, etc.
            Serializes all values into a byte[] in single call. If need to append, use BinaryWriter instead.
            </summary>
        </member>
        <member name="T:Au.Util.LibSerializer.Value">
            <summary>
            Type of input and output values of <see cref="T:Au.Util.LibSerializer"/> functions.
            Has implicit conversions from/to int and string.
            </summary>
        </member>
        <member name="M:Au.Util.LibSerializer.Serialize(Au.Util.LibSerializer.Value[])">
            <summary>
            Serializes multiple values of types int, string, string[] and null.
            The returned array can be passed to <see cref="M:Au.Util.LibSerializer.Deserialize(System.Byte[])"/>.
            </summary>
        </member>
        <member name="M:Au.Util.LibSerializer.SerializeWithSize(Au.Util.LibSerializer.Value[])">
            <summary>
            Serializes multiple values of types int, string, string[] and null.
            Unlike <see cref="M:Au.Util.LibSerializer.Serialize(Au.Util.LibSerializer.Value[])"/>, in the first 4 bytes writes the size of data that follows.
            Can be used with pipes or other streams where data size is initially unknown: read 4 bytes as <c>int dataSize</c>; <c>var b=new byte[dataSize]</c>, read it, pass b to <see cref="M:Au.Util.LibSerializer.Deserialize(System.Byte[])"/>. 
            </summary>
        </member>
        <member name="M:Au.Util.LibSerializer.Deserialize(System.Byte[])">
            <summary>
            Deserializes values serialized by <see cref="M:Au.Util.LibSerializer.Serialize(Au.Util.LibSerializer.Value[])"/>.
            Returns array of values passed to <b>Serialize</b>.
            </summary>
        </member>
        <member name="T:Au.Util.LibSharedMemory">
            <summary>
            Memory shared by all processes using this library.
            </summary>
        </member>
        <member name="F:Au.Util.LibSharedMemory.Size">
            <summary>
            Shared memory size.
            </summary>
        </member>
        <member name="F:Au.Util.LibSharedMemory.Ptr">
            <summary>
            Gets pointer to the shared memory.
            </summary>
        </member>
        <member name="M:Au.Util.LibSharedMemory.CreateOrGet(System.String,System.UInt32,System.Boolean@)">
            <summary>
            Creates named shared memory of specified size. Opens if already exists.
            Returns shared memory address in this process.
            Calls API <msdn>CreateFileMapping</msdn> and API <msdn>MapViewOfFile</msdn>.
            </summary>
            <param name="name">Shared memory name. Case-insensitive.</param>
            <param name="size">Shared memory size. Ignored if the shared memory already exists.</param>
            <param name="created">Receives true if created and not opened.</param>
            <exception cref="T:Au.Types.AuException">The API failed.</exception>
            <remarks>
            Once the memory is created, it is alive at least until this process ends. Other processes can keep the memory alive even after that.
            There is no Close function to close the native shared memory object handle. The OS closes it when this process ends.
            </remarks>
        </member>
        <member name="T:Au.Util.LibStringBuilder">
            <summary>
            Provides a cached reusable instance of StringBuilder per thread. It's an optimisation that reduces the number of instances constructed and collected.
            Used like <c>using(new Au.Util.LibStringBuilder(out var b)) { b.Append("example"); var s = b.ToString(); }</c>.
            </summary>
            <remarks>
            This is a modified copy of the .NET internal StringBuilderCache class.
            The cache uses 2 [ThreadLocal] StringBuilder instances, which allows 1 nesting level. Not error to use deeper nesting level, but then gets new StringBuilder, not from the cache.
            </remarks>
        </member>
        <member name="F:Au.Util.LibStringBuilder.MAX_BUILDER_SIZE">
            <summary>
            2000. The cache is not used if capacity is bigger.
            </summary>
        </member>
        <member name="M:Au.Util.LibStringBuilder.#ctor(System.Text.StringBuilder@,System.Int32)">
            <summary>
            Gets a new or cached/cleared StringBuilder of the specified capacity, min 200.
            </summary>
        </member>
        <member name="M:Au.Util.LibStringBuilder.Dispose">
            <summary>
            Releases the StringBuilder to the cache.
            </summary>
        </member>
        <member name="M:Au.Util.LibWorkarounds.WaitCursorWhenShowingMenuEtc">
            <summary>
            A workaround for:
            	When showing a ContextMenuStrip menu or a submenu, something briefly sets the AppStarting cursor.
            	Only if this process does/did not have active windows.
            	Only if current cursor is arrow. Works well if eg I or hand.
            	Starts before first WM_NCPAINT (after WM_SHOWWINDOW+WM_WINDOWPOSCHANGING) and stops before WM_PAINT.
            Call this before showing a menu. Possibly also will need for some other windows.
            </summary>
        </member>
        <member name="T:Au.Util.NamespaceDoc">
            <summary>
            Rarely used classes of the automation library.
            </summary>
        </member>
        <member name="T:Au.Util.LibTables">
            <summary>
            Lookup tables for various functions of this library.
            </summary>
        </member>
        <member name="F:Au.Util.LibTables.Hex">
            <summary>
            Table for <see cref="M:Au.Util.AConvert.HexDecode(System.ReadOnlySpan{System.Char})"/> and co.
            </summary>
        </member>
        <member name="P:Au.Util.LibTables.LowerCase">
            <summary>
            Native-memory char[0x10000] containing lower-case versions of the first 0x10000 characters.
            </summary>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA">
            <summary>
            Thread pool where COM can be used. Initializes thread COM as single-thread-apartment.
            </summary>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.WorkCallbackData">
            <summary>
            Work callback function parameter type.
            More info: <see cref="T:Au.Util.ThreadPoolSTA.WorkCallback"/>.
            </summary>
        </member>
        <member name="F:Au.Util.ThreadPoolSTA.WorkCallbackData.state">
            
        </member>
        <member name="F:Au.Util.ThreadPoolSTA.WorkCallbackData.completionCallback">
            
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.WorkCallback">
            <summary>
            Work callback function type.
            </summary>
            <param name="d">
            Contains state and completionCallback that were passed to the submit function.
            Your work callback function can change completionCallback and/or state. For example it can set completionCallback = null to prevent calling it (the call is expensive); or change state, if want to pass another object to the completion function.
            Note that the completion function is never called if initially it was null.
            </param>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)">
            <summary>
            Requests that a thread pool thread call the callback function.
            </summary>
            <param name="state">Something to pass to the callback functions.</param>
            <param name="workCallback">Callback function to call in a thread pool thread.</param>
            <param name="completionCallback">Optional callback function to call in this thread after workCallback.</param>
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.CreateWork(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)">
            <summary>
            Creates a <see cref="T:Au.Util.ThreadPoolSTA.Work"/> object that can be used when need more options than <see cref="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)"/> has.
            </summary>
            <param name="state">Something to pass to the callback functions.</param>
            <param name="workCallback">Callback function to call in a thread pool thread.</param>
            <param name="completionCallback">Optional callback function to call in this thread after workCallback.</param>
            <remarks>
            Call Dispose() to avoid memory leaks. If not called, the object and related OS object remain in memory until this process ends.
            </remarks>
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="T:Au.Util.ThreadPoolSTA.Work">
            <summary>
            Allows to submit a callback function (one or more times) to be called in thread pool threads, then optionally wait and cancel.
            Can be used when need more options than <see cref="M:Au.Util.ThreadPoolSTA.SubmitCallback(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback)"/> has.
            </summary>
            <example>
            <code><![CDATA[
            using(var work = Util.ThreadPoolSTA.CreateWork(null, o =&gt; { Thread.Sleep(100); })) {
            	work.Submit();
            	work.Wait();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.#ctor(System.Object,Au.Util.ThreadPoolSTA.WorkCallback,System.Threading.SendOrPostCallback,System.Boolean)">
            <exception cref="T:System.ComponentModel.Win32Exception"/>
            <exception cref="T:System.InvalidOperationException">(only when completionCallback is used) This thread has a synchronization context other than WindowsFormsSynchronizationContext or null; or it is null and thread's GetApartmentState is not STA.</exception>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Submit">
            <summary>
            Requests that a thread pool thread call the callback function.
            This function can be called multiple times.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Wait">
            <summary>
            Waits until all submitted instances of the callback function finish their work.
            While waiting, this thread cannot dispatch events and Windows messages.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Cancel">
            <summary>
            Waits until all running instances of the callback function finish their work, and cancels pending (still not running) instances.
            While waiting, this thread cannot dispatch events and Windows messages.
            </summary>
        </member>
        <member name="M:Au.Util.ThreadPoolSTA.Work.Dispose">
            <summary>
            Calls <see cref="M:Au.Util.ThreadPoolSTA.Work.Cancel"/>, releases all resources used by this object and allows this object to be garbage-collected.
            Call this to avoid memory leaks. If not called, the object and related OS object remain in memory until this process ends.
            </summary>
        </member>
        <member name="T:Au.AWildex">
            <summary>
            Parses and compares [](xref:wildcard_expression).
            </summary>
            <remarks>
            Used in 'find' functions. For example in <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/> to compare window name, class name and program.
            The 'find' function creates an <b>AWildex</b> instance (which parses the wildcard expression), then calls <see cref="M:Au.AWildex.Match(System.String)"/> for each item (eg window) to compare some its property text.
            </remarks>
            <example>
            <code><![CDATA[
            //This version does not support wildcard expressions.
            Document Find1(string name, string date)
            {
            	return Documents.Find(x => x.Name.Eqi(name) && x.Date.Eqi(date));
            }
            
            //This version supports wildcard expressions.
            //null-string arguments are not compared.
            Document Find2(string name, string date)
            {
            	AWildex n = name, d = date; //null if the string is null
            	return Documents.Find(x => (n == null || n.Match(x.Name)) && (d == null || d.Match(x.Date)));
            }
            
            //Example of calling such function.
            //Find item whose name is "example" (case-insensitive) and date starts with "2017-".
            var item = x.Find2("example", "2017-*");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWildex.#ctor(System.String)">
            <param name="wildcardExpression">
            [Wildcard expression](xref:wildcard_expression).
            Cannot be null (throws exception).
            "" will match "".
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException">Invalid <c>"**options "</c> or regular expression.</exception>
        </member>
        <member name="M:Au.AWildex.op_Implicit(System.String)~Au.AWildex">
            <summary>
            Creates new <b>AWildex</b> from wildcard expression string.
            If the string is null, returns null.
            </summary>
            <param name="wildcardExpression">[Wildcard expression](xref:wildcard_expression). </param>
            <exception cref="T:System.ArgumentException">Invalid <c>"**options "</c> or regular expression.</exception>
        </member>
        <member name="M:Au.AWildex.Match(System.String)">
            <summary>
            Compares a string with the [](xref:wildcard_expression) used to create this <see cref="T:Au.AWildex"/>.
            Returns true if they match.
            </summary>
            <param name="s">String. If null, returns false. If "", returns true if it was "" or "*" or a regular expression that matches "".</param>
        </member>
        <member name="P:Au.AWildex.Text">
            <summary>
            Gets the wildcard or simple text.
            null if TextType is Regex or Multi.
            </summary>
        </member>
        <member name="P:Au.AWildex.RegexPcre">
            <summary>
            Gets the Regex object created from regular expression string.
            null if TextType is not RegexPcre (no option r).
            </summary>
        </member>
        <member name="P:Au.AWildex.RegexNet">
            <summary>
            Gets the Regex object created from regular expression string.
            null if TextType is not RegexNet (no option R).
            </summary>
        </member>
        <member name="P:Au.AWildex.MultiArray">
            <summary>
            Array of <b>AWildex</b> variables, one for each part in multi-part text.
            null if TextType is not Multi (no option m).
            </summary>
        </member>
        <member name="P:Au.AWildex.TextType">
            <summary>
            Gets the type of text (wildcard, regex, etc).
            </summary>
        </member>
        <member name="P:Au.AWildex.IgnoreCase">
            <summary>
            Is case-insensitive?
            </summary>
        </member>
        <member name="P:Au.AWildex.Not">
            <summary>
            Has option n?
            </summary>
        </member>
        <member name="M:Au.AWildex.ToString">
            
        </member>
        <member name="M:Au.AWildex.HasWildcardChars(System.String)">
            <summary>
            Returns true if string contains wildcard characters: '*', '?'.
            </summary>
            <param name="s">Can be null.</param>
        </member>
        <member name="T:Au.ATask">
            <summary>
            Automation task - a running script.
            </summary>
        </member>
        <member name="P:Au.ATask.Name">
            <summary>
            In an automation task process of a script with role miniProgram (defaut) returns script file name without extension.
            In other processes returns <see cref="P:System.AppDomain.FriendlyName"/>, like "ProgramFile.exe".
            </summary>
        </member>
        <member name="P:Au.ATask.Role">
            <summary>
            In an automation task process tells whether the task runs in host process (default), editor process or own .exe process. It matches meta role.
            In other processes always returns <b>ExeProgram</b>.
            </summary>
        </member>
        <member name="M:Au.ATask.Run(System.String,System.String[])">
            <summary>
            Starts an automation task. Does not wait.
            </summary>
            <returns>
            Native process id of the task process.
            Returns 0 if task start is deferred because a script is running (see meta option ifRunning).
            Returns 0 if role editorExtension; then waits until the task ends.
            </returns>
            <param name="script">Script name like "Script5.cs", or path like @"\Folder\Script5.cs".</param>
            <param name="args">Command line arguments. In script it will be variable <i>args</i>. Should not contain '\0' characters.</param>
            <exception cref="T:System.IO.FileNotFoundException">Script file not found.</exception>
            <exception cref="T:Au.Types.AuException">Failed to start script.</exception>
        </member>
        <member name="M:Au.ATask.RunWait(System.String,System.String[])">
            <summary>
            Starts an automation task and waits until it ends.
            More info: <see cref="M:Au.ATask.Run(System.String,System.String[])"/>.
            </summary>
            <returns>The exit code of the task process. See <see cref="P:System.Environment.ExitCode"/>.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Script file not found.</exception>
            <exception cref="T:Au.Types.AuException">Failed to start script.</exception>
        </member>
        <member name="M:Au.ATask.RunWait(System.String@,System.String,System.String[])">
            <summary>
            Starts an automation task, waits until it ends and gets its strings written by <see cref="M:Au.ATask.WriteResult(System.String)"/>.
            More info: <see cref="M:Au.ATask.Run(System.String,System.String[])"/>.
            </summary>
            <param name="results">Receives <see cref="M:Au.ATask.WriteResult(System.String)"/> output.</param>
            <returns>The exit code of the task process. See <see cref="P:System.Environment.ExitCode"/>.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Script file not found.</exception>
            <exception cref="T:Au.Types.AuException">Failed to start script.</exception>
        </member>
        <member name="M:Au.ATask.RunWait(System.Action{System.String},System.String,System.String[])">
            <summary>
            Starts an automation task, waits until it ends and gets its strings written by <see cref="M:Au.ATask.WriteResult(System.String)"/>.
            More info: <see cref="M:Au.ATask.Run(System.String,System.String[])"/>.
            </summary>
            <param name="results">Receives <see cref="M:Au.ATask.WriteResult(System.String)"/> output whenever the task calls it.</param>
            <returns>The exit code of the task process. See <see cref="P:System.Environment.ExitCode"/>.</returns>
            <exception cref="T:System.IO.FileNotFoundException">Script file not found.</exception>
            <exception cref="T:Au.Types.AuException">Failed to start script.</exception>
        </member>
        <member name="P:Au.ATask.WndMsg">
            <summary>
            Finds editor's message-only window used with WM_COPYDATA etc.
            </summary>
        </member>
        <member name="M:Au.ATask.WriteResult(System.String)">
            <summary>
            Writes a string result for the task that called <see cref="M:Au.ATask.RunWait(System.String@,System.String,System.String[])"/> or <see cref="M:Au.ATask.RunWait(System.Action{System.String},System.String,System.String[])"/> to run this task, or for the program that executed "Au.CL.exe" to run this task with command line like "Au.CL.exe **Script5.cs".
            Returns false if this task was not started in such a way. Returns null if failed to write, except when s is null/"".
            </summary>
            <param name="s">A string. This function does not append newline characters.</param>
            <remarks>
            The <b>RunWait</b>(Action) overload can read the string in real time.
            The <b>RunWait</b>(out string) overload gets all strings joined when the task ends.
            The program that executed "Au.CL.exe" to run this task with command line like "Au.CL.exe **Script5.cs" can read the string from the redirected standard output in real time, or the string is written to its console in real time. The string encoding is UTF8; if you use a bat file or cmd.exe and want to get correct Unicode text, execute this before, to change console code page to UTF-8: <c>chcp 65001</c>.
            </remarks>
        </member>
        <member name="T:Au.RunAssembly">
            <summary>
            Used by other Au projects to execute a script assembly.
            </summary>
        </member>
        <member name="M:Au.RunAssembly.Run(System.String,System.String[],System.Int32,Au.Types.RAFlags,System.String)">
            <summary>
            Executes assembly in this thread.
            Handles exceptions.
            </summary>
            <param name="asmFile">Full path of assembly file.</param>
            <param name="args">To pass to Main.</param>
            <param name="pdbOffset">0 or offset of portable PDB in assembly file.</param>
            <param name="flags"></param>
            <param name="fullPathRefs">Paths of assemblies specified using full path.</param>
        </member>
        <member name="T:Au.RunAssembly._LoadedScriptAssembly">
            <summary>
            Remembers and finds script assemblies loaded in this process, to avoid loading the same unchanged assembly multiple times.
            </summary>
        </member>
        <member name="T:Au.APerf">
            <summary>
            Code speed measurement. Easier to use than <see cref="T:System.Diagnostics.Stopwatch"/>.
            </summary>
        </member>
        <member name="T:Au.APerf.Inst">
            <summary>
            The same as <see cref="T:Au.APerf"/> class, but allows to have multiple independent speed measurements.
            </summary>
            <remarks>
            Stores data in the variable, not in a static variable.
            
            Don't need to dispose variables of this type. The <see cref="M:Au.APerf.Inst.Dispose"/> function just calls <see cref="M:Au.APerf.Inst.NW(System.Char)"/>.
            </remarks>
        </member>
        <member name="P:Au.APerf.Inst.Incremental">
            <summary>See <see cref="P:Au.APerf.Incremental"/>.</summary>
            <example>
            <code><![CDATA[
            var perf = new APerf.Inst { Incremental = true };
            for(int i = 0; i < 5; i++) {
            	Thread.Sleep(100); //not included in the measurement
            	perf.First();
            	Thread.Sleep(30); //will make sum ~150000
            	perf.Next();
            	Thread.Sleep(10); //will make sum ~50000
            	perf.Next();
            	Thread.Sleep(100); //not included in the measurement
            }
            perf.Write(); //speed:  154317  51060  (205377)
            perf.Incremental = false;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.APerf.Inst.First">
            <summary><see cref="M:Au.APerf.First"/></summary>
        </member>
        <member name="M:Au.APerf.Inst.Next(System.Char)">
            <summary><see cref="M:Au.APerf.Next(System.Char)"/></summary>
        </member>
        <member name="M:Au.APerf.Inst.NW(System.Char)">
            <summary>
            Calls <see cref="M:Au.APerf.Inst.Next(System.Char)"/> and <see cref="M:Au.APerf.Inst.Write"/>.
            </summary>
            <param name="cMark">A character to add to the results string like "A=150".</param>
        </member>
        <member name="M:Au.APerf.Inst.Dispose">
            <summary>
            Calls <see cref="M:Au.APerf.Inst.NW(System.Char)"/>, which calls <see cref="M:Au.APerf.Inst.Next(System.Char)"/> and <see cref="M:Au.APerf.Inst.Write"/>.
            Don't need to dispose variables of this type. There is nothing to dispose. This just allows to use the 'using' pattern instead of <b>NW</b>.
            </summary>
        </member>
        <member name="M:Au.APerf.Inst.Write">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.APerf.Inst.First"/> and <see cref="M:Au.APerf.Inst.Next(System.Char)"/>, and shows it in the output.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.APerf.Inst.ToString">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.APerf.Inst.First"/> and <see cref="M:Au.APerf.Inst.Next(System.Char)"/>.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.APerf.Inst.ToArray">
            <summary>
            Return array of time values collected by calling <see cref="M:Au.APerf.Inst.First"/> and <see cref="M:Au.APerf.Inst.Next(System.Char)"/>.
            Each element is the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="P:Au.APerf.Inst.TimeTotal">
            <summary>
            Gets the number of microseconds between <see cref="M:Au.APerf.Inst.First"/> and the last <see cref="M:Au.APerf.Inst.Next(System.Char)"/>.
            </summary>
        </member>
        <member name="F:Au.APerf.StaticInst">
            <summary>
            This static variable is used by the static functions.
            </summary>
        </member>
        <member name="M:Au.APerf.Create">
            <summary>
            Creates and returns new <see cref="T:Au.APerf.Inst"/> variable and calls its <see cref="M:Au.APerf.Inst.First"/>.
            </summary>
        </member>
        <member name="P:Au.APerf.Incremental">
            <summary>
            If true, times of each new First/Next/Next... measurement are added to previous measurement times.
            Finally you can call <see cref="M:Au.APerf.Write"/> or <see cref="M:Au.APerf.ToString"/> to get the sums.
            Usually used to measure code in loops. See example.
            </summary>
            <example>
            <code><![CDATA[
            APerf.Incremental = true;
            for(int i = 0; i < 5; i++) {
            	Thread.Sleep(100); //not included in the measurement
            	APerf.First();
            	Thread.Sleep(30); //will make sum ~150000
            	APerf.Next();
            	Thread.Sleep(10); //will make sum ~50000
            	APerf.Next();
            	Thread.Sleep(100); //not included in the measurement
            }
            APerf.Write(); //speed:  154317  51060  (205377)
            APerf.Incremental = false;
            ]]></code>
            </example>
        </member>
        <member name="M:Au.APerf.First">
            <summary>
            Stores current time in the first element of an internal array.
            </summary>
        </member>
        <member name="M:Au.APerf.Next(System.Char)">
            <summary>
            Stores current time in next element of an internal array.
            </summary>
            <remarks>
            Don't call <b>Next</b> more than 16 times after <b>First</b>, because the array has fixed size.
            </remarks>
            <param name="cMark">A character to mark this time in the results string, like "A=150".</param>
        </member>
        <member name="M:Au.APerf.NW(System.Char)">
            <summary>
            Calls <see cref="M:Au.APerf.Next(System.Char)"/> and <see cref="M:Au.APerf.Write"/>.
            </summary>
            <param name="cMark">A character to add to the results string like "A=150".</param>
        </member>
        <member name="M:Au.APerf.Write">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.APerf.First"/> and <see cref="M:Au.APerf.Next(System.Char)"/>, and shows it in the output.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
            <example>
            <code><![CDATA[
            APerf.First(100);
            CODE1;
            APerf.Next();
            CODE2;
            APerf.Next();
            APerf.Write(); //speed:  timeOfCODE1  timeOfCODE2  (totalTime)
            ]]></code>
            </example>
        </member>
        <member name="M:Au.APerf.ToString">
            <summary>
            Formats a string from time values collected by calling <see cref="M:Au.APerf.First"/> and <see cref="M:Au.APerf.Next(System.Char)"/>.
            The string contains the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="M:Au.APerf.ToArray">
            <summary>
            Return array of time values collected by calling <see cref="M:Au.APerf.First"/> and <see cref="M:Au.APerf.Next(System.Char)"/>.
            Each element is the number of microseconds of each code execution between calling <b>First</b> and each <b>Next</b>.
            </summary>
        </member>
        <member name="P:Au.APerf.TimeTotal">
            <summary>
            Gets the number of microseconds between <see cref="M:Au.APerf.First"/> and the last <see cref="M:Au.APerf.Next(System.Char)"/>.
            </summary>
        </member>
        <member name="M:Au.APerf.SpeedUpCpu(System.Int32)">
            <summary>
            Executes some code in loop for the specified amount of time. It should make CPU to run at full speed.
            </summary>
            <param name="timeMilliseconds">How long to speed up CPU, milliseconds. The minimal required time probably is about 100 ms, but depends on CPU.</param>
            <remarks>
            Code speed measurements often are misleading because of variable CPU speed. Most CPU don't run at full speed when not actively used.
            
            You can make CPU speed constant in Control Panel -> Power Options -> ... Advanced -> Processor power management -> Minimum or maximum power state.
            There are programs that show current CPU speed. For example HWMonitor.
            </remarks>
        </member>
        <member name="T:Au.ATime">
            <summary>
            Time functions. Get time, sleep/wait, doevents.
            </summary>
            <seealso cref="T:Au.APerf"/>
            <seealso cref="T:Au.AWaitFor"/>
        </member>
        <member name="P:Au.ATime.PerfMicroseconds">
            <summary>
            Gets the number of microseconds elapsed since Windows startup. Uses the high-resolution system timer.
            </summary>
            <remarks>
            Uses API <msdn>QueryPerformanceCounter</msdn>.
            This function is used to measure time differences with 1 microsecond precision, like <c>var t1=ATime.PerfMicroseconds; ... var t2=ATime.PerfMicroseconds; var diff=t2-t1;</c>.
            Independent of computer clock time changes.
            MSDN article: <msdn>Acquiring high-resolution time stamps</msdn>.
            </remarks>
            <seealso cref="T:Au.APerf"/>
        </member>
        <member name="P:Au.ATime.PerfMilliseconds">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup. Uses the high-resolution system timer.
            </summary>
            <remarks>
            Uses API <msdn>QueryPerformanceCounter</msdn>.
            This function is used to measure time differences with 1 ms precision, like <c>var t1=ATime.PerfMilliseconds; ... var t2=ATime.PerfMilliseconds; var diff=t2-t1;</c>.
            The return value equals <see cref="P:Au.ATime.PerfMicroseconds"/>/1000 but is slightly different than of <see cref="P:Au.ATime.WinMilliseconds"/> and other similar functions of this library, Windows API and .NET. Never compare times returned by different functions.
            Independent of computer clock time changes.
            </remarks>
        </member>
        <member name="P:Au.ATime.WinMilliseconds">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup.
            </summary>
            <remarks>
            Uses API <msdn>GetTickCount64</msdn>.
            Like <see cref="P:System.Environment.TickCount"/>, but returns a 64-bit value that does not overflow.
            Uses the low-resolution system timer. Its period usually is 15.25 ms. When need to measure time differences with better precision, use <see cref="P:Au.ATime.PerfMilliseconds"/> or <see cref="P:Au.ATime.PerfMicroseconds"/>.
            Independent of computer clock time changes.
            </remarks>
        </member>
        <member name="P:Au.ATime.WinMilliseconds32">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup.
            </summary>
            <remarks>
            Uses API <msdn>GetTickCount</msdn>.
            The same as <see cref="P:System.Environment.TickCount"/>. Returns a 32-bit value that overflows after 24.9 days.
            Uses the low-resolution system timer. Its period usually is 15.25 ms.
            Independent of computer clock time changes.
            </remarks>
        </member>
        <member name="P:Au.ATime.WinMillisecondsWithoutSleep">
            <summary>
            Gets the number of milliseconds elapsed since Windows startup, not including the time when the computer sleeps or hibernates.
            </summary>
            <remarks>
            Uses API <msdn>QueryUnbiasedInterruptTime</msdn>.
            Uses the low-resolution system timer. Its period usually is 15.25 ms.
            Independent of computer clock time changes.
            </remarks>
        </member>
        <member name="M:Au.ATime.Sleep(System.Int32)">
            <summary>
            Waits <i>timeMilliseconds</i> milliseconds.
            </summary>
            <param name="timeMilliseconds">Time to wait, milliseconds. Or <see cref="F:System.Threading.Timeout.Infinite"/>.</param>
            <remarks>
            Calls <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/>.
            Does not process Windows messages and other events, therefore should not be used in threads with windows, timers, hooks, events or COM, unless <i>timeMilliseconds</i> is small. Supports APC.
            If the computer goes to sleep or hibernate during that time, the real time is the specified time + the sleep/hibernate time.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeMilliseconds</i> is negative and not Timeout.Infinite (-1).</exception>
            <example>
            <code><![CDATA[
            ATime.Sleep(50);
            50.ms(); //the same
            0.05.s(); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ATime.ms(System.Int32)">
            <summary>
            Waits <i>timeMilliseconds</i> milliseconds. The same as <see cref="M:Au.ATime.Sleep(System.Int32)"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeMilliseconds</i> is negative and not Timeout.Infinite (-1).</exception>
            <example>
            <code><![CDATA[
            50.ms();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ATime.s(System.Int32)">
            <summary>
            Waits <i>timeSeconds</i> seconds.
            The same as <see cref="M:Au.ATime.Sleep(System.Int32)"/> and <see cref="M:Au.ATime.ms(System.Int32)"/>, but the time is specified in seconds, not milliseconds.
            </summary>
            <param name="timeSeconds">Time to wait, seconds.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeSeconds</i> is less than 0 or greater than 2147483 (int.MaxValue/1000, 24.8 days).</exception>
            <example>
            <code><![CDATA[
            ATime.Sleep(5000);
            5000.ms(); //the same
            5.s(); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ATime.s(System.Double)">
            <summary>
            Waits <i>timeSeconds</i> seconds.
            The same as <see cref="M:Au.ATime.Sleep(System.Int32)"/> and <see cref="M:Au.ATime.ms(System.Int32)"/>, but the time is specified in seconds, not milliseconds.
            </summary>
            <param name="timeSeconds">Time to wait, seconds. The smallest value is 0.001 (1 ms).</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeSeconds</i> is less than 0 or greater than 2147483 (int.MaxValue/1000, 24.8 days).</exception>
            <example>
            <code><![CDATA[
            ATime.Sleep(2500);
            2500.ms(); //the same
            2.5.s(); //the same
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ATime.SleepDoEvents(System.Int32)">
            <summary>
            Waits <i>timeMS</i> milliseconds. While waiting, retrieves and dispatches Windows messages and other events.
            </summary>
            <param name="timeMS">Time to wait, milliseconds. Or <see cref="F:System.Threading.Timeout.Infinite"/>.</param>
            <remarks>
            Unlike <see cref="M:Au.ATime.Sleep(System.Int32)"/>, this function retrieves and dispatches Windows messages, calls .NET event handlers, hook procedures, timer functions, COM/RPC, etc. Supports APC.
            This function can be used in threads with windows. However usually there are better ways, for example timer, other thread, async/await/Task. In some places this function does not work as expected, for example in Form/Control mouse event handlers .NET blocks other mouse events.
            Be careful, this function is as dangerous as <see cref="M:System.Windows.Forms.Application.DoEvents"/>.
            Calls API <msdn>MsgWaitForMultipleObjectsEx</msdn> and <see cref="M:Au.ATime.DoEvents"/>.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><i>timeMS</i> is negative and not Timeout.Infinite.</exception>
            <seealso cref="M:Au.AWaitFor.MessagesAndCondition(System.Double,System.Func{System.Boolean})"/>
            <seealso cref="M:Au.AWaitFor.PostedMessage(System.Double,Au.Types.WaitMsgCallback)"/>
            <seealso cref="T:Au.Util.AMessageLoop"/>
        </member>
        <member name="M:Au.ATime.LibSleepDoEvents(System.Int32,System.Boolean)">
            <summary>SleepDoEvents + noSetPrecision.</summary>
        </member>
        <member name="M:Au.ATime.DoEvents">
            <summary>
            Retrieves and dispatches events and Windows messages from the message queue of this thread.
            </summary>
            <remarks>
            Similar to <see cref="M:System.Windows.Forms.Application.DoEvents"/>, but more lightweight. Uses API functions <msdn>PeekMessage</msdn>, <msdn>TranslateMessage</msdn> and <msdn>DispatchMessage</msdn>.
            Be careful, this function is as dangerous as <b>Application.DoEvents</b>.
            </remarks>
        </member>
        <member name="T:Au.ATime.LibSleepPrecision">
            <summary>
            Temporarily changes the time resolution/precision of Thread.Sleep and some other functions.
            </summary>
            <remarks>
            Uses API <msdn>timeBeginPeriod</msdn>, which requests a time resolution for various system timers and wait functions. Actually it is the system thread scheduling timer period.
            Normal resolution on Windows 7-10 is 15.625 ms. It means that, for example, <c>Thread.Sleep(1);</c> sleeps not 1 but 1-15 ms. If you set resolution 1, it sleeps 1-2 ms.
            The new resolution is revoked (<msdn>timeEndPeriod</msdn>) when disposing the LibSleepPrecision variable or when this process ends. See example. See also <see cref="M:Au.ATime.LibSleepPrecision.TempSet1(System.Int32)"/>.
            The resolution is applied to all threads and processes. Other applications can change it too. For example, often web browsers temporarily set resolution 1 ms when opening a web page.
            The system uses the smallest period (best resolution) that currently is set by any application. You cannot make it bigger than current value.
            <note>It is not recommended to keep small period (high resolution) for a long time. It can be bad for power saving.</note>
            Don't need this for ATime.SleepX and functions that use them (AMouse.Click etc). They call <see cref="M:Au.ATime.LibSleepPrecision.TempSet1(System.Int32)"/> when the sleep time is 1-99 ms.
            This does not change the minimal period of <see cref="T:Au.ATimer"/> and System.Windows.Forms.Timer.
            </remarks>
            <example>
            <code><![CDATA[
            _Test("before");
            using(new ATime.LibSleepPrecision(2)) {
            	_Test("in");
            }
            _Test("after");
            
            void _Test(string name)
            {
            	Print(name);
            	APerf.First();
            	for(int i = 0; i < 8; i++) { Thread.Sleep(1); APerf.Next(); }
            	APerf.Write();
            }
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ATime.LibSleepPrecision.#ctor(System.Int32)">
            <summary>
            Calls API <msdn>timeBeginPeriod</msdn>.
            </summary>
            <param name="periodMS">
            New system timer period, milliseconds.
            Should be 1. Other values may stuck and later cannot be made smaller due to bugs in OS or some applications; this bug would impact many functions of this library.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">periodMS &lt;= 0.</exception>
        </member>
        <member name="M:Au.ATime.LibSleepPrecision.Dispose">
            <summary>
            Calls API <msdn>timeEndPeriod</msdn>.
            </summary>
        </member>
        <member name="M:Au.ATime.LibSleepPrecision.Finalize">
            
        </member>
        <member name="P:Au.ATime.LibSleepPrecision.Current">
            <summary>
            Gets current actual system time resolution (period).
            The return value usually is between 0.5 and 15.625 milliseconds. Returns 0 if fails.
            </summary>
        </member>
        <member name="M:Au.ATime.LibSleepPrecision.TempSet1(System.Int32)">
            <summary>
            Temporarily sets the system wait precision to 1 ms. It will be revoked after the specified time or when this process ends.
            If already set, just updates the revoking time.
            </summary>
            <param name="endAfterMS">Revoke after this time, milliseconds.</param>
            <example>
            <code><![CDATA[
            Print(ATime.LibSleepPrecision.Current); //probably 15.625
            ATime.LibSleepPrecision.TempSet1(500);
            Print(ATime.LibSleepPrecision.Current); //1
            Thread.Sleep(600);
            Print(ATime.LibSleepPrecision.Current); //probably 15.625 again
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ATime.LibSleepPrecision.LibTempSet1(System.Int32)">
            <summary>
            Calls TempSet1 if sleepTimeMS is 1-99.
            </summary>
            <param name="sleepTimeMS">milliseconds of the caller 'sleep' function.</param>
        </member>
        <member name="T:Au.ATimer">
            <summary>
            Timer that uses API <msdn>SetTimer</msdn> and API <msdn>KillTimer</msdn>.
            </summary>
            <remarks>
            Similar to System.Windows.Forms.Timer, but more lightweight, for example does not create a hidden window.
            Use in UI threads. Does not work if this thread does not retrieve/dispatch posted messages (<msdn>WM_TIMER</msdn>).
            </remarks>
            <example>
            This example sets 3 timers.
            <code><![CDATA[
            ATimer.After(500, _ => Print("after 500 ms"));
            ATimer.Every(1000, _ => Print("every 1000 ms"));
            var t3 = new ATimer(_ => Print("after 3000 ms")); t3.After(3000); //the same as ATimer.After
            MessageBox.Show("");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.ATimer.#ctor(System.Action{Au.ATimer})">
            
        </member>
        <member name="P:Au.ATimer.Tag">
            <summary>
            Something to attach to this ATimer variable.
            </summary>
        </member>
        <member name="P:Au.ATimer.IsRunning">
            <summary>
            true if the timer is started and not stopped.
            Note: single-period timer is automatically stopped before calling the callback function.
            </summary>
        </member>
        <member name="M:Au.ATimer.After(System.Int32,System.Object)">
            <summary>
            Starts one-time timer. If already started, resets and changes its period.
            </summary>
            <param name="milliseconds">Time interval after which will be called the callback function, milliseconds. The actual minimal interval is 10-20 ms.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.ATimer.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative.</exception>
            <exception cref="T:System.InvalidOperationException">Called not in the same thread as previous <b>Start</b>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The timer will be stopped before calling the callback function. The callback function can start it again.
            If already started, this function must be called in the same thread as when started.
            </remarks>
        </member>
        <member name="M:Au.ATimer.Every(System.Int32,System.Object)">
            <summary>
            Starts periodic timer. If already started, resets and changes its period.
            </summary>
            <param name="milliseconds">Time interval (period) of calling the callback function, milliseconds. The actual minimal period is 10-20 ms.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.ATimer.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative.</exception>
            <exception cref="T:System.InvalidOperationException">Called not in the same thread as previous <b>Start</b>.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The callback function can stop the timer or restart with different period.
            If already started, this function must be called in the same thread as when started.
            </remarks>
        </member>
        <member name="M:Au.ATimer.Stop">
            <summary>
            Stops the timer.
            </summary>
            <exception cref="T:System.InvalidOperationException">Called not in the same thread as <b>Start</b>.</exception>
            <remarks>
            The callback function will not be called after this.
            Later you can start the timer again (call <see cref="M:Au.ATimer.After(System.Int32,System.Object)"/> or <see cref="M:Au.ATimer.Every(System.Int32,System.Object)"/>).
            Don't need to call this function for single-period timers. For periodic timers it is optional; the timer stops when the thread ends.
            This function must be called in the same thread as <b>Start</b>.
            </remarks>
        </member>
        <member name="M:Au.ATimer.After(System.Int32,System.Action{Au.ATimer},System.Object)">
            <summary>
            Creates and starts new one-time timer.
            Returns new <see cref="T:Au.ATimer"/> object. Usually you don't need it.
            </summary>
            <param name="milliseconds">Time interval after which will be called the callback function, milliseconds. The actual minimal interval is 10-20 ms.</param>
            <param name="timerAction">Callback function.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.ATimer.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The timer will be stopped before calling the callback function. The callback function can start it again.
            The callback function will be called in this thread.
            This thread must must get/dispatch posted messages, eg call Application.Run() or Form.ShowModal() or ADialog.Show(). The callback function is not called while this thread does not do it.
            </remarks>
        </member>
        <member name="M:Au.ATimer.Every(System.Int32,System.Action{Au.ATimer},System.Object)">
            <summary>
            Creates and starts new periodic timer.
            Returns new <see cref="T:Au.ATimer"/> object that can be used to modify timer properties if you want to do it not in the callback function; usually don't need it.
            </summary>
            <param name="milliseconds">Time interval (period) of calling the callback function, milliseconds. The actual minimal period is 10-20 ms.</param>
            <param name="timerAction">Callback function.</param>
            <param name="tag">Something to pass to the callback function as <see cref="P:Au.ATimer.Tag"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Negative.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">API <msdn>SetTimer</msdn> returned 0. Unlikely.</exception>
            <remarks>
            The callback function can stop the timer or restart with different period.
            The callback function will be called in this thread.
            This thread must must get/dispatch posted messages, eg call Application.Run() or Form.ShowModal() or ADialog.Show(). The callback function is not called while this thread does not do it.
            </remarks>
        </member>
        <member name="T:Au.AWaitFor">
            <summary>
            Contains functions to wait for a user-defined condition or variable.
            </summary>
            <remarks>
            Specialized 'wait for' functions are in other classes, for example <see cref="M:Au.AWnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            
            All 'wait for' functions have a <i>secondsTimeout</i> parameter. It is the maximal time to wait, seconds. If it is 0, waits infinitely. If &gt;0, after that time interval throws <see cref="T:System.TimeoutException"/>. If &lt;0, then stops waiting and returns default value of that type (false, etc).
            
            While waiting, most functions by default don't dispatch Windows messages, events, hooks, timers, COM/RPC, etc. For example, if used in a Form/Control event handler, the form would stop responding. Use another thread, for example async/await/Task, like in the example. Or option <see cref="P:Au.Types.OptWaitFor.DoEvents"/>.
            </remarks>
            <seealso cref="T:Au.ATime"/>
            <example>
            <code><![CDATA[
            AWaitFor.Condition(0, () => AKeys.IsScrollLock);
            Print("ScrollLock now is toggled");
            ]]></code>
            Using in a Form/Control event handler.
            <code><![CDATA[
            var f = new Form();
            f.Click += async (unu, sed) =>
              {
            	  Print("waiting...");
            	  var result = await Task.Run(() => AWaitFor.Condition(-10, () => AKeys.IsScrollLock));
            	  if(w.Is0) Print("timeout"); else Print(result);
              };
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AWaitFor.Loop">
            <summary>
            Can be used to easily implement 'wait for' functions with a timeout.
            </summary>
            <remarks>
            See examples. The code works like most 'wait for' functions of this library: on timeout throws exception, unless secondsTimeout is negative.
            Similar code is used by most 'wait for' functions of this library.
            See also <see cref="M:Au.AWaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/>; usually it's easier; internally it uses similar code too.
            </remarks>
            <example>
            <code><![CDATA[
            public static bool WaitForMouseLeftButtonDown(double secondsTimeout)
            {
            	var x = new AWaitFor.Loop(secondsTimeout);
            	for(; ; ) {
            		if(AMouse.IsPressed(MButtons.Left)) return true;
            		if(!x.Sleep()) return false;
            	}
            }
            ]]></code>
            The same with AWaitFor.Condition.
            <code><![CDATA[
            static bool WaitForMouseLeftButtonDown2(double secondsTimeout)
            {
            	return AWaitFor.Condition(secondsTimeout, () => AMouse.IsPressed(MButtons.Left));
            }
            ]]></code>
            </example>
        </member>
        <member name="P:Au.AWaitFor.Loop.Period">
            <summary>
            Current period (<see cref="M:Au.AWaitFor.Loop.Sleep"/> sleep time), milliseconds.
            Initially it is <see cref="P:Au.Types.OptWaitFor.Period"/>, optionally multiplied by constructor's <i>options.Period</i>/10. Default 10 ms. Then each <see cref="M:Au.AWaitFor.Loop.Sleep"/> increments it until <see cref="P:Au.AWaitFor.Loop.MaxPeriod"/>.
            </summary>
        </member>
        <member name="P:Au.AWaitFor.Loop.MaxPeriod">
            <summary>
            Maximal period (<see cref="M:Au.AWaitFor.Loop.Sleep"/> sleep time), milliseconds.
            It is <see cref="P:Au.AWaitFor.Loop.Period"/>*50 (default 500).
            </summary>
        </member>
        <member name="P:Au.AWaitFor.Loop.TimeRemaining">
            <summary>
            Gets or sets the remaining time, milliseconds.
            </summary>
        </member>
        <member name="M:Au.AWaitFor.Loop.#ctor(System.Double,Au.Types.OptWaitFor)">
            <param name="secondsTimeout">
            The maximal time to wait, seconds. If 0, waits infinitely. If &gt;0, after that time interval <see cref="M:Au.AWaitFor.Loop.Sleep"/> throws <see cref="T:System.TimeoutException"/>. If &lt;0, then <see cref="M:Au.AWaitFor.Loop.Sleep"/> returns false.
            </param>
            <param name="options">Options. If null, uses <see cref="P:Au.AOpt.WaitFor"/>, else combines with it.</param>
        </member>
        <member name="M:Au.AWaitFor.Loop.Sleep">
            <summary>
            Calls <see cref="M:Au.AWaitFor.Loop.IsTimeout"/>. If it returns true, returns false.
            Else sleeps for <see cref="P:Au.AWaitFor.Loop.Period"/> milliseconds, increments <b>Period</b> if it is less than <see cref="P:Au.AWaitFor.Loop.MaxPeriod"/>, and returns true.
            </summary>
            <exception cref="T:System.TimeoutException">The <i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.AWaitFor.Loop.IsTimeout">
            <summary>
            If the <i>secondsTimeout</i> time is not expired, returns false.
            Else if <i>secondsTimeout</i> is negative, returns true.
            Else throws <see cref="T:System.TimeoutException"/>.
            </summary>
            <exception cref="T:System.TimeoutException">The <i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.AWaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)">
            <summary>
            Waits for an user-defined condition.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="condition">Callback function (eg lambda). It is called repeatedly, until returns true. The calling period depends on <i>options</i>.</param>
            <param name="options">Options. If null, uses <see cref="P:Au.AOpt.WaitFor"/>, else combines with it.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>More info: <see cref="T:Au.AWaitFor"/>.</remarks>
            <example>See <see cref="T:Au.AWaitFor"/>.</example>
        </member>
        <member name="M:Au.AWaitFor.Handle(System.Double,Au.Types.WHFlags,System.IntPtr[])">
            <summary>
            Waits for a kernel object (event, mutex, etc).
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="flags"></param>
            <param name="handles">One or more handles of kernel objects. Max 63.</param>
            <returns>
            Returns 1-based index of the first signaled handle. Negative if abandoned mutex.
            On timeout returns 0 if <i>secondsTimeout</i> is negative; else exception.
            </returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuException">Failed. For example a handle is invalid.</exception>
            <remarks>
            Uses API <msdn>WaitForMultipleObjectsEx</msdn> or <msdn>MsgWaitForMultipleObjectsEx</msdn>. Alertable.
            Does not use <see cref="P:Au.AOpt.WaitFor"/>.
            </remarks>
        </member>
        <member name="M:Au.AWaitFor.LibWait(System.Int64,Au.Types.WHFlags,System.IntPtr[])">
            <summary>
            Waits for a signaled kernel handle. Or just sleeps, if handles is null/empty.
            If flag DoEvents, dispatches received messages, hook notifications, etc.
            Calls API <msdn>WaitForMultipleObjectsEx</msdn> or <msdn>MsgWaitForMultipleObjectsEx</msdn> with QS_ALLINPUT. Alertable.
            When a handle becomes signaled, returns its 0-based index. If abandoned mutex, returns 0-based index + Api.WAIT_ABANDONED_0 (0x80).
            If timeMS>0, waits max timeMS and on timeout returns Api.WAIT_TIMEOUT.
            If failed, returns -1. Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWaitFor.LibWait(System.Int64,Au.Types.WHFlags,System.Object,Au.Types.LibWaitVariable,System.IntPtr[])">
            <summary>
            The same as <see cref="M:Au.AWaitFor.LibWait(System.Int64,Au.Types.WHFlags,System.IntPtr[])"/> + can wait for message and variable.
            If msgCallback is not null, calls it when dispatching messages. If returns true, stops waiting and returns handles?.Length.
            	If it is WaitMsgCallback, calls it before dispatching a posted message.
            	If it is Func{bool}, calls it after dispatching one or more messages.
            If stopVar is not null, when it becomes true stops waiting and returns handles?.Length + 1.
            </summary>
        </member>
        <member name="M:Au.AWaitFor.PostedMessage(System.Double,Au.Types.WaitMsgCallback)">
            <summary>
            Waits for a posted message received by this thread.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="callback">Callback function that returns true to stop waiting. More info in Remarks.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            While waiting, dispatches Windows messages etc, like <see cref="M:Au.ATime.SleepDoEvents(System.Int32)"/>. Before dispatching a posted message, calls the callback function. Stops waiting when it returns true. Does not dispatch the message if the function sets the message field = 0.
            Does not use <see cref="P:Au.AOpt.WaitFor"/>.
            </remarks>
            <example>
            <code><![CDATA[
            ATimer.After(2000, t => { Print("timer"); });
            AWaitFor.PostedMessage(5, (ref Native.MSG m) => { Print(m); return m.message == 0x113; }); //WM_TIMER
            Print("finished");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWaitFor.MessagesAndCondition(System.Double,System.Func{System.Boolean})">
            <summary>
            Waits for a variable or other condition that is changed while processing messages or other events received by this thread.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="condition">Callback function that returns true to stop waiting. More info in Remarks.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            While waiting, dispatches Windows messages etc, like <see cref="M:Au.ATime.SleepDoEvents(System.Int32)"/>. After dispatching one or more messages or other events (posted messages, messages sent by other threads, hooks, etc), calls the callback function. Stops waiting when it returns true.
            Similar to <see cref="M:Au.AWaitFor.Condition(System.Double,System.Func{System.Boolean},Au.Types.OptWaitFor)"/>. Differences: 1. Always dispatches messages etc. 2. Does not call the callback function when there are no messages etc.
            Does not use <see cref="P:Au.AOpt.WaitFor"/>.
            </remarks>
            <example>
            <code><![CDATA[
            bool stop = false;
            ATimer.After(2000, t => { Print("timer"); stop = true; });
            AWaitFor.MessagesAndCondition(5, () => stop);
            Print(stop);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWaitFor.Variable(System.Double,System.Boolean@,Au.Types.OptWaitFor)">
            <summary>
            Waits until a variable is set = true.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="variable">Stop waiting when this variable is set to true.</param>
            <param name="options">Options. If null, uses <see cref="P:Au.AOpt.WaitFor"/>, else combines with it.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            This function is useful when the variable can be changed by any thread. To wait for a variable changed while processing messages etc in this thread, it's better to use <see cref="M:Au.AWaitFor.MessagesAndCondition(System.Double,System.Func{System.Boolean})"/>.
            </remarks>
            <example>
            <code><![CDATA[
            bool stop = false;
            Task.Run(() => { 2.s(); Print("task"); stop = true; });
            AWaitFor.Variable(5, stop);
            Print(stop);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Triggers.ActionTrigger">
            <summary>
            Base of classes of all action trigger types.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTrigger.Run(Au.Triggers.TriggerArgs)">
            <summary>
            Called through <see cref="M:Au.Triggers.TriggerActionThreads.Run(Au.Triggers.ActionTrigger,Au.Triggers.TriggerArgs,System.Int32)"/> in action thread.
            Possibly runs later.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTrigger.RunT``1(``0)">
            <summary>
            Makes simpler to implement <see cref="M:Au.Triggers.ActionTrigger.Run(Au.Triggers.TriggerArgs)"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.TypeString">
            <summary>
            Returns a trigger type string, like "Hotkey", "Mouse", "Window.ActiveNew".
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTrigger.ToString">
            <summary>
            Returns TypeString + " " + ParamsString.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.Disabled">
            <summary>
            Gets or sets whether this trigger is disabled.
            Does not depend on <see cref="P:Au.Triggers.ActionTriggers.Disabled"/>, <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>, <see cref="P:Au.Triggers.ActionTrigger.EnabledAlways"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.DisabledThisOrAll">
            <summary>
            Returns true if <see cref="P:Au.Triggers.ActionTrigger.Disabled"/>; also if <see cref="P:Au.Triggers.ActionTriggers.Disabled"/> or <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>, unless <see cref="P:Au.Triggers.ActionTrigger.EnabledAlways"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTrigger.EnabledAlways">
            <summary>
            Gets or sets whether this trigger ignores <see cref="P:Au.Triggers.ActionTriggers.Disabled"/> and <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>.
            </summary>
            <remarks>
            When adding the trigger, this property is set to the value of <see cref="P:Au.Triggers.TriggerOptions.EnabledAlways"/> at that time.
            </remarks>
        </member>
        <member name="M:Au.Triggers.ActionTrigger.RunAction(Au.Triggers.TriggerArgs)">
            <summary>
            Starts the action like when its trigger is activated.
            </summary>
            <param name="args"></param>
            <exception cref="T:System.InvalidOperationException">Called in a wrong place or from a wrong thread. More info in Ramarks.</exception>
            <remarks>
            Must be called while <see cref="M:Au.Triggers.ActionTriggers.Run"/> is running, from the same thread that called it.
            </remarks>
        </member>
        <member name="T:Au.Triggers.TriggerArgs">
            <summary>
            Base of trigger action argument classes of all trigger types.
            </summary>
        </member>
        <member name="T:Au.Triggers.TriggerScopes">
            <summary>
            Allows to specify working windows for multiple triggers of these types: hotkey, autotext, mouse.
            </summary>
            <example>
            <code><![CDATA[
            Triggers.Hotkey["Ctrl+K"] = o => Print("this trigger works with all windows");
            Triggers.Of.Window("* Notepad"); //specifies a working window for triggers added afterwards
            Triggers.Hotkey["Ctrl+F11"] = o => Print("this trigger works only when a Notepad window is active");
            Triggers.Hotkey["Ctrl+F12"] = o => Print("this trigger works only when a Notepad window is active");
            var wordpad = Triggers.Of.Window("* WordPad"); //specifies another working window for triggers added afterwards
            Triggers.Hotkey["Ctrl+F11"] = o => Print("this trigger works only when a WordPad window is active");
            Triggers.Hotkey["Ctrl+F12"] = o => Print("this trigger works only when a WordPad window is active");
            Triggers.Of.AllWindows(); //let triggers added afterwards work with all windows
            Triggers.Mouse[TMEdge.RightInTop25] = o => Print("this trigger works with all windows");
            Triggers.Of.Again(wordpad); //sets a previously specified working window for triggers added afterwards
            Triggers.Mouse[TMEdge.RightInBottom25] = o => Print("this trigger works only when a WordPad window is active");
            Triggers.Mouse[TMMove.DownUp] = o => Print("this trigger works only when a WordPad window is active");
            Triggers.Mouse[TMClick.Middle] = o => Print("this trigger works only when the mouse is in a WordPad window");
            Triggers.Mouse[TMWheel.Forward] = o => Print("this trigger works only when the mouse is in a WordPad window");
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.AllWindows">
            <summary>
            Sets scope "all windows" again. Hotkey, autotext and mouse triggers added afterwards will work with all windows.
            </summary>
            <remarks>
            Example in class help.
            </remarks>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)">
            <summary>
            Sets (reuses) a previously specified scope.
            </summary>
            <remarks>
            Example in class help.
            </remarks>
            <param name="scope">The return value of function <b>Window</b>, <b>NotWindow</b>, <b>Windows</b> or <b>NotWindows</b>.</param>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Window(System.String,System.String,Au.Types.WF3,System.Func{Au.AWnd,System.Boolean},System.Object)">
            <summary>
            Sets scope "only this window". Hotkey, autotext and mouse triggers added afterwards will work only when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <remarks>
            Parameters are like with <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            Example in class help.
            </remarks>
            <exception cref="T:System.ArgumentException">Exceptions of <see cref="T:Au.AWnd.Finder"/> constructor.</exception>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.NotWindow(System.String,System.String,Au.Types.WF3,System.Func{Au.AWnd,System.Boolean},System.Object)">
            <summary>
            Sets scope "not this window". Hotkey, autotext and mouse triggers added afterwards will not work when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <remarks>
            Parameters are like with <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            Example in class help.
            </remarks>
            <exception cref="T:System.ArgumentException">Exceptions of <see cref="T:Au.AWnd.Finder"/> constructor.</exception>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Window(Au.AWnd.Finder)">
            <summary>
            Sets scope "only this window". Hotkey, autotext and mouse triggers added afterwards will work only when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.NotWindow(Au.AWnd.Finder)">
            <summary>
            Sets scope "not this window". Hotkey, autotext and mouse triggers added afterwards will not work when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Window(Au.AWnd)">
            <summary>
            Sets scope "only this window". Hotkey, autotext and mouse triggers added afterwards will work only when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.NotWindow(Au.AWnd)">
            <summary>
            Sets scope "not this window". Hotkey, autotext and mouse triggers added afterwards will not work when the specified window is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle.</exception>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.Windows(System.Object[])">
            <summary>
            Sets scope "only these windows". Hotkey, autotext and mouse triggers added afterwards will work only when one of the specified windows is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <param name="any">
            Specifies one or more windows.
            Supported object types: <see cref="T:Au.AWnd.Finder"/>, <see cref="T:Au.AWnd"/>, string.
            If string, its format must be like with <see cref="M:Au.AWnd.Finder.op_Implicit(System.String)~Au.AWnd.Finder"/>. Examples: "Name", "Name,Class", ",,Program.exe".
            The easiest way to specify "all windows of program X.exe": <c>Triggers.Of.Windows(",,X.exe")</c>.
            </param>
            <exception cref="T:System.ArgumentException">Unsupported object type.</exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (when object type is <b>AWnd</b>).</exception>
        </member>
        <member name="M:Au.Triggers.TriggerScopes.NotWindows(System.Object[])">
            <summary>
            Sets scope "not these windows". Hotkey, autotext and mouse triggers added afterwards will not work when one of the specified windows is active.
            </summary>
            <returns>Returns an object that can be later passed to <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/> to reuse this scope.</returns>
            <param name="any">See <see cref="M:Au.Triggers.TriggerScopes.Windows(System.Object[])"/>.</param>
            <exception cref="T:System.ArgumentException">Unsupported object type.</exception>
            <exception cref="T:Au.Types.AuWndException">Invalid window handle (when object type is <b>AWnd</b>).</exception>
        </member>
        <member name="T:Au.Triggers.TriggerScope">
            <summary>
            A trigger scope returned by functions like <see cref="M:Au.Triggers.TriggerScopes.Window(System.String,System.String,Au.Types.WF3,System.Func{Au.AWnd,System.Boolean},System.Object)"/> and used with <see cref="M:Au.Triggers.TriggerScopes.Again(Au.Triggers.TriggerScope)"/>.
            </summary>
            <example>See <see cref="T:Au.Triggers.TriggerScopes"/>.</example>
        </member>
        <member name="M:Au.Triggers.TriggerScope.Match(Au.Triggers.TriggerHookContext)">
            <summary>
            Returns true if window matches.
            </summary>
            <param name="thc">This func uses the window handle (gets on demand) and WFCache.</param>
        </member>
        <member name="T:Au.Triggers.TriggerFuncs">
             <summary>
             Allows to define custom scopes/contexts/conditions for triggers.
             </summary>
             <remarks>
             Similar to <see cref="T:Au.Triggers.TriggerScopes"/> (code like <c>Triggers.Of.Window(...);</c>), but allows to define any scope/condition/etc, not just the active window.
             
             To define a scope, you create a callback function (CF) that checks some conditions and returns true to allow the trigger action to run or false to not allow. Assign the CF to some property of this class and then add the trigger, like in the examples below. The CF will be assigned to the trigger and called when need.
             
             You may ask: why to use CF when the trigger action (TA) can do the same?
             1. CF runs synchronously; if it returns false, the trigger key or mouse button message is passed to other triggers, hooks and apps. TA cannot do it reliably; it runs asynchronously, and the message is already stealed from other apps/triggers/hooks.
             2. CF is faster to call. It is simply called in the same thread that processes trigger messages. TA runs in another thread.
             3. A CF can be assigned to multiple triggers with a single line of code. Don't need to add the same code in all trigger actions.
             
             A trigger can have up to 4 CF delegates and a window scope (<c>Triggers.Of...</c>). They are called in this order: CF assigned through <see cref="P:Au.Triggers.TriggerFuncs.FollowingTriggersBeforeWindow"/>, <see cref="P:Au.Triggers.TriggerFuncs.NextTriggerBeforeWindow"/>, window scope, <see cref="P:Au.Triggers.TriggerFuncs.NextTrigger"/>, <see cref="P:Au.Triggers.TriggerFuncs.FollowingTriggers"/>. The <b>NextX</b> properties assign the CF to the next single trigger. The <b>FollowingX</b> properties assign the CF to all following triggers until you assign another CF or null. If several are assigned, the trigger action runs only if all CF return true and the window scope matches. The <b>XBeforeWindow</b> properties are used only with hotkey, autotext and mouse triggers.
             
             All CF must be as fast as possible. Slow CF can make triggers slower (or even all keyboard/mouse input); also may cause warnings and trigger failures. A big problem is the low-level hooks timeout that Windows applies to trigger hooks; see <see cref="P:Au.AHookWin.LowLevelHooksTimeout"/>. A related problem - slow JIT and loading of assemblies, which can make the CF too slow the first time; in some rare cases may even need to preload assemblies or pre-JIT functions to avoid the timeout warning.
            
             In CF never use functions that generate keyboard or mouse events or activate windows.
             </remarks>
             <example>
             <code><![CDATA[
             //examples of assigning a CF to a single trigger
             Triggers.FuncOf.NextTrigger = o => AKeys.IsCapsLock; //o => AKeys.IsCapsLock is the callback function (lambda)
             Triggers.Hotkey["Ctrl+K"] = o => Print("action: Ctrl+K while CapsLock is on");
             Triggers.FuncOf.NextTrigger = o => { var v = o as HotkeyTriggerArgs; Print($"func: mod={v.Mod}"); return AMouse.IsPressed(MButtons.Left); };
             Triggers.Hotkey["Ctrl+Shift?+B"] = o => Print("action: mouse left button + Ctrl+B or Ctrl+Shift+B");
             
             //examples of assigning a CF to multiple triggers
             Triggers.FuncOf.FollowingTriggers = o => { var v = o as HotkeyTriggerArgs; Print("func", v.Trigger); return true; };
             Triggers.Hotkey["Ctrl+F8"] = o => Print("action: " + o.Trigger);
             Triggers.Hotkey["Ctrl+F9"] = o => Print("action: " + o.Trigger);
             Triggers.FuncOf.FollowingTriggers = null; //stop assigning the CF to triggers added afterwards
             
             //sometimes all work can be done in CF and you don't need the trigger action
             Triggers.FuncOf.NextTrigger = o => { var v = o as HotkeyTriggerArgs; Print("func: " + v.Trigger); return true; };
             Triggers.Hotkey["Ctrl+F12"] = null;
             
             Triggers.Run();
             ]]></code>
             </example>
        </member>
        <member name="P:Au.Triggers.TriggerFuncs.NextTrigger">
            <summary>
            Sets callback function for the next added trigger.
            If the trigger has a window scope, the callback function is called after evaluating the window.
            This function is used with triggers of all types.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerFuncs.NextTriggerBeforeWindow">
            <summary>
            Sets callback function for the next added trigger.
            If the trigger has a window scope, the callback function is called before evaluating the window.
            This function is used with triggers of these types: hotkey, autotext, mouse.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerFuncs.FollowingTriggers">
            <summary>
            Sets callback function for multiple triggers added afterwards.
            If the trigger has a window scope, the callback function is called after evaluating the window.
            This function is used with triggers of all types.
            The value can be null.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerFuncs.FollowingTriggersBeforeWindow">
            <summary>
            Sets callback function for multiple triggers added afterwards.
            If the trigger has a window scope, the callback function is called before evaluating the window.
            This function is used with triggers of these types: hotkey, autotext, mouse.
            The value can be null.
            </summary>
        </member>
        <member name="T:Au.Triggers.TFunc">
            <summary>
            Type of functions used with class <see cref="T:Au.Triggers.TriggerFuncs"/> to define custom scope for triggers.
            </summary>
            <param name="args">Trigger action arguments. Example: <see cref="T:Au.Triggers.TriggerFuncs"/>.</param>
            <returns>Return true to run the trigger action, or false to not run.</returns>
        </member>
        <member name="T:Au.Triggers.ActionTriggers">
            <summary>
            The main class of action triggers.
            </summary>
            <remarks>
            Action triggers launch functions (aka <i>trigger actions</i>) in running automation scripts. To launch scripts are used other ways: manually, at startup, command line, <see cref="M:Au.ATask.Run(System.String,System.String[])"/>, output link.
            
            This class manages action triggers. The <see cref="P:Au.Types.AScript.Triggers"/> property gets its instance. Through it you access all trigger types (hotkey, window, etc) and add triggers to them.
            
            Code syntax to add an action trigger:
            <code>Triggers.TriggerType[parameters] = action;</code>
            Examples:
            <code>
            Triggers.Hotkey["Ctrl+K"] = o => Print(o.Trigger);
            Triggers.Hotkey["Ctrl+Shift+K"] = o => {
            	Print("This is a trigger action. Usually it is a lambda function, like in these examples.");
            	Print($"It runs when you press {o.Trigger}.");
            };
            Triggers.Run();
            </code>
            
            Also you can set options (<see cref="T:Au.Triggers.TriggerOptions"/>), window scopes (<see cref="T:Au.Triggers.TriggerScopes"/>) and custom scopes (<see cref="T:Au.Triggers.TriggerFuncs"/>) for multiple triggers added afterwards.
            
            Finally call <see cref="M:Au.Triggers.ActionTriggers.Run"/>. It runs all the time (like <b>Application.Run</b>) and launches trigger actions (functions) when need. Actions run in other thread(s).
            
            Recommended properties for scripts containg triggers. You can set it in the Properties dialog.
            - <c>runMode blue</c> allows other scripts to start while this script is running.
            - <c>ifRunning restart</c> makes easy to restart the script after editing: just click the Run button.
            
            <note>Trigger actions don't inherit <b>AOpt</b> options that are set before adding triggers. The example shows two ways how to set <b>AOpt</b> options for multiple actions. Also you can set them in action code. Next action running in the same thread will not inherit <b>AOpt</b> options set by previous action; the trigger engine calls <see cref="M:Au.AOpt.Reset"/> before executing an action.</note>
            </remarks>
            <example>
            This is a single script with many action triggers.
            <code><![CDATA[
            using Au.Triggers; //add this below other 'using' directives
            
            //if you want to set options for all or some triggers, do it before adding them
            Triggers.Options.RunActionInThread(0, 500);
            
            //you can use variables if don't want to type "Triggers.Hotkey" etc for each trigger
            var hk = Triggers.Hotkey;
            var mouse = Triggers.Mouse;
            var window = Triggers.Window;
            var tt = Triggers.Autotext;
            
            //hotkey triggers
            
            hk["Ctrl+K"] = o => Print(o.Trigger); //it means: execute code "o => Print(o.Trigger)" when I press Ctrl+K
            hk["Ctrl+Shift+F11"] = o => {
            	Print(o.Trigger);
            	var w1 = AWnd.FindOrRun("* Notepad", run: () => AExec.Run(AFolders.System + "notepad.exe"));
            	Text("text");
            	w1.Close();
            };
            
            //triggers that work only with some windows
            
            Triggers.Of.Window("* WordPad", "WordPadClass"); //let the following triggers work only when a WordPad window is active
            hk["Ctrl+F5"] = o => Print(o.Trigger, o.Window);
            hk["Ctrl+F6"] = o => Print(o.Trigger, o.Window);
            
            var notepad = Triggers.Of.Window("* Notepad"); //let the following triggers work only when a Notepad window is active
            hk["Ctrl+F5"] = o => Print(o.Trigger, o.Window);
            hk["Ctrl+F6"] = o => Print(o.Trigger, o.Window);
            
            Triggers.Of.AllWindows(); //let the following triggers work with all windows
            
            //mouse triggers
            
            mouse[TMClick.Right, "Ctrl+Shift", TMFlags.ButtonModUp] = o => Print(o.Trigger);
            mouse[TMEdge.RightInCenter50] = o => { Print(o.Trigger); ADialog.ShowEx("Bang!", x: Coord.Max); };
            mouse[TMMove.LeftRightInCenter50] = o => AWnd.SwitchActiveWindow();
            
            Triggers.FuncOf.NextTrigger = o => AKeys.IsScrollLock; //example of a custom scope (aka context, condition)
            mouse[TMWheel.Forward] = o => Print($"{o.Trigger} while ScrollLock is on");
            
            Triggers.Of.Again(notepad); //let the following triggers work only when a Notepad window is active
            mouse[TMMove.LeftRightInBottom25] = o => { Print(o.Trigger); o.Window.Close(); };
            Triggers.Of.AllWindows();
            
            //window triggers. Note: window triggers don't depend on Triggers.Of.
            
            window[TWEvent.ActiveNew, "* Notepad", "Notepad"] = o => Print("opened Notepad window");
            window[TWEvent.ActiveNew, "Notepad", "#32770", contains: "Do you want to save *"] = o => {
            	Print("opened Notepad's 'Do you want to save' dialog");
            	//Key("Alt+S"); //click the Save button
            };
            
            //autotext triggers
            
            tt["los"] = o => o.Replace("Los Angeles");
            tt["WIndows", TAFlags.MatchCase] = o => o.Replace("Windows");
            tt.DefaultPostfixType = TAPostfix.None;
            tt["<b>"] = o => o.Replace("<b>[[|]]</b>");
            tt["#file"] = o => {
            	o.Replace("");
            	var fd = new OpenFileDialog();
            	if(fd.ShowDialog() == DialogResult.OK) Text(fd.FileName);
            };
            tt.DefaultPostfixType = default;
            
            //shorter auto-replace code
            
            var ts = Triggers.Autotext.SimpleReplace;
            ts["#so"] = "Some text"; //the same as tt["#so"] = o => o.Replace("Some text");
            ts["#mo"] = "More text";
            
            //how to set AOpt options for trigger actions
            
            //AOpt.Key.TextOption = KTextOption.Paste; //no, it won't work. It sets AOpt for this thread, not for trigger actions.
            Triggers.Options.BeforeAction = o => { AOpt.Key.TextOption = KTextOption.Paste; }; //the correct way. Sets AOpt before executing an action.
            ts["#p1"] = "text 1";
            ts["#p2"] = "text 2";
            Triggers.Options.BeforeAction = null;
            
            //another way to set AOpt options - use AOpt.Static. It sets options for all actions in the script, not just for triggers added afterwards.
            
            AOpt.Static.Key.PasteLength = 50;
            AOpt.Static.Key.Hook = h => { var w1 = h.w.Window; Print(w1); if(w1.Name.Like("* Word")) h.opt.PasteEnter = true; };
            ts["#p3"] = "/* " + new string('*', 60) + " */\r\n";
            
            //how to stop and disable/enable triggers
            
            hk["Ctrl+Alt+Q"] = o => Triggers.Stop(); //let Triggers.Run() end its work and return
            hk.Last.EnabledAlways = true;
            
            hk["Ctrl+Alt+D"] = o => Triggers.Disabled ^= true; //disable/enable triggers here
            hk.Last.EnabledAlways = true;
            
            hk["Ctrl+Alt+Win+D"] = o => ActionTriggers.DisabledEverywhere ^= true; //disable/enable triggers in all processes
            hk.Last.EnabledAlways = true;
            
            hk["Ctrl+F7"] = o => Print("This trigger can be disabled/enabled with Ctrl+F8.");
            var t1 = hk.Last;
            hk["Ctrl+F8"] = o => t1.Disabled ^= true; //disable/enable a trigger
            
            //finally call Triggers.Run(). Without it the triggers won't work.
            Triggers.Run();
            //Triggers.Run returns when is called Triggers.Stop (see the "Ctrl+Alt+Q" trigger above).
            Print("called Triggers.Stop");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.#ctor">
            <summary>
            Initializes a new instance of this class.
            </summary>
            <remarks>
            In automation scripts don't need to create new instances of this class. Instead use the <see cref="P:Au.Types.AScript.Triggers"/> property to get an instance.
            </remarks>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Of">
            <summary>
            Allows to set window scopes (working windows) for triggers.
            </summary>
            <remarks>Examples: <see cref="T:Au.Triggers.TriggerScopes"/>, <see cref="T:Au.Triggers.ActionTriggers"/>.</remarks>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.FuncOf">
            <summary>
            Allows to set custom scopes/contexts/conditions for triggers.
            </summary>
            <remarks>More info and examples: <see cref="T:Au.Triggers.TriggerFuncs"/>, <see cref="T:Au.Triggers.ActionTriggers"/>.</remarks>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Options">
            <summary>
            Allows to set some options for multiple triggers and their actions.
            </summary>
            <remarks>More info and examples: <see cref="T:Au.Triggers.TriggerOptions"/>, <see cref="T:Au.Triggers.ActionTriggers"/>.</remarks>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Hotkey">
            <summary>
            Hotkey triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Autotext">
            <summary>
            Autotext triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Mouse">
            <summary>
            Mouse triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Window">
            <summary>
            Window triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.Run">
            <summary>
            Makes triggers alive.
            </summary>
            <remarks>
            This function monitors hotkeys, activated windows and other events. When an event matches an added trigger, launches the thrigger's action, which runs in other thread.
            Does not return immediately, unless there are no triggers added. Runs until this process or thread is terminated/aborted or <see cref="M:Au.Triggers.ActionTriggers.Stop"/> called.
            </remarks>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
            <exception cref="T:System.InvalidOperationException">Already running.</exception>
            <exception cref="T:Au.Types.AuException">Something failed.</exception>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.Stop">
            <summary>
            Stops trigger engines and causes <see cref="M:Au.Triggers.ActionTriggers.Run"/> to return.
            </summary>
            <remarks>
            Does not abort threads of trigger actions that are still running.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Hotkey["Ctrl+T"] = o => Print("Ctrl+T");
            Triggers.Hotkey["Ctrl+Q"] = o => { Print("Ctrl+Q (stop)"); Triggers.Stop(); };
            Triggers.Hotkey.Last.EnabledAlways = true;
            Triggers.Run();
            Print("stopped");
            ]]></code>
            </example>
        </member>
        <member name="E:Au.Triggers.ActionTriggers.Stopping">
            <summary>
            Occurs before <see cref="M:Au.Triggers.ActionTriggers.Run"/> stops trigger engines and returns.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.LibRunning">
            <summary>
            True if executing <see cref="M:Au.Triggers.ActionTriggers.Run"/>.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.LibThrowIfRunning">
            <summary>
            Throws InvalidOperationException if executing <see cref="M:Au.Triggers.ActionTriggers.Run"/>.
            </summary>
        </member>
        <member name="M:Au.Triggers.ActionTriggers.LibThrowIfNotRunning">
            <summary>
            Throws InvalidOperationException if not executing <see cref="M:Au.Triggers.ActionTriggers.Run"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.Disabled">
            <summary>
            Gets or sets whether triggers of this <see cref="T:Au.Triggers.ActionTriggers"/> instance are disabled.
            </summary>
            <remarks>
            Does not depend on <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>.
            Does not end/pause threads of trigger actions.
            </remarks>
            <seealso cref="P:Au.Triggers.ActionTrigger.EnabledAlways"/>
            <seealso cref="P:Au.Triggers.TriggerOptions.EnabledAlways"/>
            <example>
            <code><![CDATA[
            Triggers.Hotkey["Ctrl+T"] = o => Print("Ctrl+T");
            Triggers.Hotkey["Ctrl+D"] = o => { Print("Ctrl+D (disable/enable)"); Triggers.Disabled ^= true; }; //toggle
            Triggers.Hotkey.Last.EnabledAlways = true;
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.ActionTriggers.DisabledEverywhere">
            <summary>
            true if triggers are disabled in all processes that use this library in this user session.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
            <seealso cref="P:Au.Triggers.ActionTriggers.Disabled"/>
            <seealso cref="P:Au.Triggers.TriggerOptions.EnabledAlways"/>
        </member>
        <member name="P:Au.Triggers.ITriggers.HasTriggers">
            <summary>
            Return true if added triggers of this type.
            </summary>
        </member>
        <member name="M:Au.Triggers.ITriggers.StartStop(System.Boolean)">
            <summary>
            Optionally start/stop trigger engine (hooks etc).
            </summary>
            <param name="start"></param>
        </member>
        <member name="F:Au.Triggers.TriggerHookContext.trigger">
            <summary>
            Trigger/action to run. Set by a hook proc of a trigger engine.
            </summary>
        </member>
        <member name="F:Au.Triggers.TriggerHookContext.args">
            <summary>
            Used with <see cref="F:Au.Triggers.TriggerHookContext.trigger"/>.
            </summary>
        </member>
        <member name="F:Au.Triggers.TriggerHookContext.muteMod">
            <summary>
            Used with <see cref="F:Au.Triggers.TriggerHookContext.trigger"/>.
            Can be 0 or one of TriggerActionThreads.c_ constants.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerHookContext.InitContext">
            <summary>
            Called before processing each hook event. Clears most properties and fields.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerHookContext.UseWndFromPoint(Au.Types.POINT)">
            <summary>
            Tells to get window (for scope) from the specified point. If not called, will use the active window. In any case, gets window on demand.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerHookContext.Mod">
            <summary>
            Currently pressed modifier keys. Valid only in hotkey and autotext triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerHookContext.ModL">
            <summary>
            Currently pressed left-side modifier keys. Valid only in hotkey and autotext triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerHookContext.ModR">
            <summary>
            Currently pressed right-side modifier keys. Valid only in hotkey and autotext triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.TriggerHookContext.ModThis">
            <summary>
            Not 0 if this key event is a modifier key. Valid only in hotkey and autotext triggers.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerHookContext.InitMod(Au.Types.HookData.Keyboard)">
            <summary>
            Called before processing each keyboard hook event.
            Updates Mod, ModL, ModR, IsThisKeyMod. They are used by hotkey and autotext triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TriggerOptions">
            <summary>
            Allows to set some options for multiple triggers and their actions.
            </summary>
            <remarks>
            You set options through a thread-static property <see cref="P:Au.Triggers.ActionTriggers.Options"/>.
            Changed options are applied to all triggers/actions added afterwards in this thread.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Options.RunActionInThreadPool(singleInstance: false);
            Triggers.Options.BeforeAction = o => { AOpt.Key.KeySpeed = 10; };
            Triggers.Hotkey["Ctrl+K"] = o => Print(AOpt.Key.KeySpeed); //10
            Triggers.Hotkey["Ctrl+Shift+K"] = o => Print(AOpt.Key.KeySpeed); //10
            Triggers.Options.BeforeAction = o => { AOpt.Key.KeySpeed = 20; };
            Triggers.Hotkey["Ctrl+L"] = o => Print(AOpt.Key.KeySpeed); //20
            Triggers.Hotkey["Ctrl+Shift+L"] = o => Print(AOpt.Key.KeySpeed); //20
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.TriggerOptions.RunActionInThread(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Run actions in a dedicated thread that does not end when actions end.
            </summary>
            <param name="thread">A number that you want to use to identify the thread. Can be 0-32767 (short.MaxValue). Default 0.</param>
            <param name="ifRunningWaitMS">Defines when to start an action if an action (other or same) is currently running in this thread. If 0 (default), don't run. If -1 (<b>Timeout.Infinite</b>), run when that action ends (and possibly other queed actions). If &gt; 0, run when that action ends, if it ends within this time from now; the time is in milliseconds.</param>
            <param name="noWarning">No warning when cannot start an action because an action is running and ifRunningWaitMS==0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks>
            Multiple actions in same thread cannot run simultaneously. Actions in different threads can run simultaneously.
            There is no "end old running action" feature. If need it, use other script. Example: <c>Triggers.Hotkey["Ctrl+M"] = o => ATask.RunWait("Other Script");</c>.
            There is no "temporarily pause old running action to run new action" feature. As well as for scripts.
            The thread has <see cref="F:System.Threading.ApartmentState.STA"/>.
            The <b>RunActionInX</b> functions are mutually exclusive: only the last called function is active. If none called, it is the same as called this function without arguments.
            </remarks>
        </member>
        <member name="M:Au.Triggers.TriggerOptions.RunActionInNewThread(System.Boolean)">
            <summary>
            Run actions in new threads.
            </summary>
            <remarks>
            Use if need to run actions simultaneously with other actions or other instances of self, especially if the action is long-running (maybe 5 s and more).
            The thread has <see cref="F:System.Threading.ApartmentState.STA"/>.
            The <b>RunActionInX</b> functions are mutually exclusive: only the last called function is active.
            </remarks>
            <param name="singleInstance">Don't run if this action is already running. If false, multiple action instances can run paralelly in multiple threads.</param>
        </member>
        <member name="M:Au.Triggers.TriggerOptions.RunActionInThreadPool(System.Boolean)">
            <summary>
            Run actions in thread pool threads.
            </summary>
            <remarks>
            Use if need to run actions simultaneously with other actions or other instances of self, and the action is short-running (maybe less than 5 s) and don't need <see cref="F:System.Threading.ApartmentState.STA"/>.
            Thread pool threads have <see cref="F:System.Threading.ApartmentState.MTA"/>.
            The <b>RunActionInX</b> functions are mutually exclusive: only the last called function is active.
            </remarks>
            <param name="singleInstance">Don't run if this action is already running. If false, multiple action instances can run paralelly in multiple threads.</param>
        </member>
        <member name="P:Au.Triggers.TriggerOptions.BeforeAction">
            <summary>
            A function to run before the trigger action.
            For example, it can set <see cref="T:Au.AOpt"/> options.
            </summary>
            <example>
            <code><![CDATA[
            Triggers.Options.BeforeAction = o => { AOpt.Key.KeySpeed = 20; AOpt.Key.TextSpeed = 5; };
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.TriggerOptions.AfterAction">
            <summary>
            A function to run after the trigger action.
            For example, it can log exceptions.
            </summary>
            <example>
            <code><![CDATA[
            Triggers.Options.AfterAction = o => { if(o.Exception!=null) Print(o.Exception.Message); else Print("completed successfully"); };
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.TriggerOptions.EnabledAlways">
            <summary>
            If true, triggers added afterwards don't depend on <see cref="P:Au.Triggers.ActionTriggers.Disabled"/> and <see cref="P:Au.Triggers.ActionTriggers.DisabledEverywhere"/>.
            This property sets the <see cref="P:Au.Triggers.ActionTrigger.EnabledAlways"/> property of triggers added afterwards.
            </summary>
        </member>
        <member name="T:Au.Triggers.TOBAArgs">
            <summary>
            Arguments for <see cref="P:Au.Triggers.TriggerOptions.BeforeAction"/> and <see cref="P:Au.Triggers.TriggerOptions.AfterAction"/>.
            </summary>
        </member>
        <member name="P:Au.Triggers.TOBAArgs.ActionArgs">
            <summary>
            Trigger event info. The same variable as passed to the trigger action.
            To access the info, cast to <b>HotkeyTriggerArgs</b> etc, depending on trigger type.
            </summary>
        </member>
        <member name="P:Au.Triggers.TOBAArgs.Exception">
            <summary>
            If action ended with an exception, the exception. Else null.
            </summary>
        </member>
        <member name="M:Au.Triggers.TriggerActionThreads._Thread.RunAction(System.Action,Au.Triggers.ActionTrigger)">
            <summary>
            Adds the action to the queue and notifies the thread to execute it.
            If the thread is busy, returns false; if ifRunning!=0, the action possibly will run later.
            </summary>
        </member>
        <member name="T:Au.Triggers.HooksServer">
            <summary>
            Low-level keyboard and mouse hooks in editor process or task process.
            Communicates with multiple task processes/threads.
            </summary>
            <remarks>
            To receive data from task processes, uses a message-only window and WM_COPYDATA/WM_USER.
            To send data to task processes, uses pipes created by task processes/threads.
            </remarks>
        </member>
        <member name="M:Au.Triggers.HooksServer.RemoveTask(System.Int32)">
            <summary>
            Called by RunningTasks.TaskEnded2.
            </summary>
            <param name="processId"></param>
        </member>
        <member name="M:Au.Triggers.TrigUtil.GetModLR(Au.Types.KMod@,Au.Types.KMod@)">
            <summary>
            Gets left and right modifiers. Uses AKeys.IsPressed.
            Returns modL | modR.
            </summary>
        </member>
        <member name="T:Au.Triggers.TAFlags">
            <summary>
            Flags of autotext triggers.
            </summary>
            <remarks>
            To avoid passing flags to each trigger as the <i>flags</i> parameter, use <see cref="P:Au.Triggers.AutotextTriggers.DefaultFlags"/>; its initial value is 0, which means: case-insensitive, erase the typed text, modify the replacement text depending on the case of the typed text.
            </remarks>
        </member>
        <member name="F:Au.Triggers.TAFlags.MatchCase">
            <summary>
            Case-sensitive.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.DontErase">
            <summary>
            Don't erase the user-typed text.
            This flag is for <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.Object[])"/>. It erases text with the Backspace key. If you don't call it, text is not erased regardless of this flag.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.ReplaceRaw">
            <summary>
            Let <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.Object[])"/> don't modify the replacement text. Without this flag it:
            1. If the first character of the typed text is uppercase, makes the first character of the replacement text uppercase.
            2. If all typed text is uppercase, makes the replacement text uppercase.
            
            Flag <b>MatchCase</b> disables these modifications too.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.RemovePostfix">
            <summary>
            Let <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.Object[])"/> remove the postfix delimiter character.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAFlags.Confirm">
            <summary>
            Don't run the action immediately. Show a menu containing 1 item. Let the user click it or press Enter or Tab. Other keys just close the menu.
            See also: <see cref="M:Au.Triggers.AutotextTriggerArgs.Confirm(System.String)"/>.
            </summary>
        </member>
        <member name="T:Au.Triggers.TAPostfix">
            <summary>
            Postfix type of autotext triggers.
            The trigger action runs only when the user ends the autotext with a postfix character or key, unless postfix type is <b>None</b>.
            Default: <b>CharOrKey</b>.
            </summary>
        </member>
        <member name="F:Au.Triggers.TAPostfix.CharOrKey">
            <summary>A postfix character (see <b>Char</b>) or key (see <b>Key</b>).</summary>
        </member>
        <member name="F:Au.Triggers.TAPostfix.Char">
            <summary>A postfix character specified in the <i>postfixChars</i> parameter or <see cref="P:Au.Triggers.AutotextTriggers.DefaultPostfixChars"/> property. If not specified - any non-word character.</summary>
        </member>
        <member name="F:Au.Triggers.TAPostfix.Key">
            <summary>The Ctrl or Shift key. Default is Ctrl. You can change it with <see cref="P:Au.Triggers.AutotextTriggers.PostfixKey"/>.</summary>
        </member>
        <member name="F:Au.Triggers.TAPostfix.None">
            <summary>Don't need a postfix. The action runs immediately when the user types the autotext.</summary>
        </member>
        <member name="T:Au.Triggers.AutotextTrigger">
            <summary>
            Represents an autotext trigger.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTrigger.TypeString">
            <summary>
            Returns "Autotext".
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="T:Au.Triggers.AutotextTriggers">
            <summary>
            Autotext triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.Item(System.String,System.Nullable{Au.Triggers.TAFlags},System.Nullable{Au.Triggers.TAPostfix},System.String)">
            <summary>
            Adds an autotext trigger.
            </summary>
            <param name="text">The action runs when the user types this text and a postfix character or key. By default case-insensitive.</param>
            <param name="flags">Options. If omitted or null, uses <see cref="P:Au.Triggers.AutotextTriggers.DefaultFlags"/>. Some flags are used by <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.Object[])"/>.</param>
            <param name="postfixType">Postfix type (character, key, any or none). If omitted or null, uses <see cref="P:Au.Triggers.AutotextTriggers.DefaultPostfixType"/>; default - a non-word character or the Ctrl key.</param>
            <param name="postfixChars">Postfix characters used when postfix type is <b>Char</b> or <b>CharOrKey</b> (default). If omitted or null, uses <see cref="P:Au.Triggers.AutotextTriggers.DefaultPostfixChars"/>; default - non-word characters.</param>
            <exception cref="T:System.ArgumentException">
            - Text is empty or too long. Can be 1 - 100 characters.
            - Postfix characters contains letters or digits.
            </exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.SimpleReplace">
            <summary>
            Allows to add triggers in a more concise way - assign a string, not a function. The string will replace the user-typed text.
            </summary>
            <example>
            <code><![CDATA[
            var ts = Triggers.Autotext.SimpleReplace;
            ts["#su"] = "Sunday"; //the same as Triggers.Autotext["#su"] = o => o.Replace("Sunday");
            ts["#mo"] = "Monday";
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.DefaultFlags">
            <summary>
            Default value for the <i>flags</i> parameter used for triggers added afterwards.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.DefaultPostfixType">
            <summary>
            Default value for the <i>postfixType</i> parameter used for triggers added afterwards.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.DefaultPostfixChars">
            <summary>
            Default value for the <i>postfixChars</i> parameter used for triggers added afterwards.
            Default: null.
            </summary>
            <remarks>
            If null (default), postfix characters are all except alpha-numeric (see <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/>).
            The value cannot contain alpha-numeric characters (exception) and <see cref="P:Au.Triggers.AutotextTriggers.WordCharsPlus"/> characters (triggers will not work).
            For Enter use \r.
            </remarks>
            <exception cref="T:System.ArgumentException">The value contains letters or digits.</exception>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.PostfixKey">
            <summary>
            The postfix key for all triggers where postfix type is <see cref="F:Au.Triggers.TAPostfix.Key"/> or <see cref="F:Au.Triggers.TAPostfix.CharOrKey"/> (default).
            Can be Ctrl, Shift, LCtrl, RCtrl, LShift or RShift.
            </summary>
            <exception cref="T:System.ArgumentException">The value is not Ctrl or Shift.</exception>
            <remarks>
            This property is applied to all triggers, not just to those added afterwards.
            </remarks>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.WordCharsPlus">
            <summary>
            Additional word characters (non-delimiters).
            Default: null.
            </summary>
            <remarks>
            By default, only alpha-numeric characters (<see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> returns true) are considered word characters. You can use this property to add more word characters, for example "_#".
            This is used to avoid activating triggers when a trigger text found inside a word.
            This property is applied to all triggers, not just to those added afterwards.
            </remarks>
        </member>
        <member name="P:Au.Triggers.AutotextTriggers.Last">
            <summary>
            The last added trigger.
            </summary>
        </member>
        <member name="M:Au.Triggers.AutotextTriggers.GetEnumerator">
            <summary>
            Used by foreach to enumerate added triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.AutotextTriggerArgs">
            <summary>
            Arguments for actions of autotext triggers.
            Use function <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.Object[])"/> to replace user-typed text.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.Trigger">
            
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.Window">
            <summary>
            The active window.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.Text">
            <summary>
            The user-typed text. If <see cref="P:Au.Triggers.AutotextTriggerArgs.HasPostfixChar"/>==true, the last character is the postfix delimiter character.
            </summary>
        </member>
        <member name="P:Au.Triggers.AutotextTriggerArgs.HasPostfixChar">
            <summary>
            true if the autotext activated when the user typed a postfix delimiter character. Then it is the last character in <see cref="P:Au.Triggers.AutotextTriggerArgs.Text"/>.
            </summary>
        </member>
        <member name="M:Au.Triggers.AutotextTriggerArgs.#ctor(Au.Triggers.AutotextTrigger,Au.AWnd,System.String,System.Boolean)">
            
        </member>
        <member name="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.Object[])">
            <summary>
            Replaces the user-typed text with the specified text.
            </summary>
            <param name="text">The replacement text.</param>
            <param name="keysEtc">Optional arguments to send keys etc. The same as with <see cref="M:Au.AKeys.Key(System.Object[])"/>.</param>
            <exception cref="T:System.ArgumentException">An argument in <i>keysEtc</i> is of an unsupported type or has an invalid value, for example an unknown key name.</exception>
            <remarks>
            Options for this function can be specified when adding triggers, in the <i>flags</i> parameter. Or before adding triggers, with <see cref="P:Au.Triggers.AutotextTriggers.DefaultFlags"/>. Uses these flags: <see cref="F:Au.Triggers.TAFlags.DontErase"/> <see cref="F:Au.Triggers.TAFlags.RemovePostfix"/> <see cref="F:Au.Triggers.TAFlags.ReplaceRaw"/> <see cref="F:Au.Triggers.TAFlags.Confirm"/>.
            
            Erases the user-typed text with the Backspace key.
            
            If the replacement text contains substring "[[|]]", removes it and moves the text cursor (caret) there with the Left key. See example.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Autotext["#exa"] = o => o.Replace("<example>[[|]]</example>");
            ]]></code>
            More examples: <see cref="T:Au.Triggers.ActionTriggers"/>.
            </example>
        </member>
        <member name="M:Au.Triggers.AutotextTriggerArgs.Confirm(System.String)">
            <summary>
            Shows a 1-item menu below the text cursor (caret) or mouse cursor.
            Returns true if the user selected the item with the mouse or Enter or Tab. Other keys just close the menu.
            </summary>
            <param name="text">Item text. This function escapes it (replaces newlines with \r\n etc) and limits to 60 characters.</param>
            <remarks>
            This function is used by <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.Object[])"/> when used flag <see cref="F:Au.Triggers.TAFlags.Confirm"/>.
            </remarks>
            <example>
            <code><![CDATA[
            var tt = Triggers.Autotext;
            tt["con1", TAFlags.Confirm] = o => o.Replace("Flag Confirm");
            tt["con2"] = o => { if(o.Confirm("Example")) o.Replace("Function Confirm"); };
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="T:Au.Triggers.TASimpleReplace">
            <remarks>Infrastructure.</remarks>
        </member>
        <member name="P:Au.Triggers.TASimpleReplace.Item(System.String,System.Nullable{Au.Triggers.TAFlags},System.Nullable{Au.Triggers.TAPostfix},System.String)">
            <summary>
            Adds an autotext trigger. Its action calls <see cref="M:Au.Triggers.AutotextTriggerArgs.Replace(System.String,System.Object[])"/>.
            More info: <see cref="P:Au.Triggers.AutotextTriggers.Item(System.String,System.Nullable{Au.Triggers.TAFlags},System.Nullable{Au.Triggers.TAPostfix},System.String)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="P:Au.Triggers.AutotextTriggers.Item(System.String,System.Nullable{Au.Triggers.TAFlags},System.Nullable{Au.Triggers.TAPostfix},System.String)"/>.</exception>
        </member>
        <member name="T:Au.Triggers.TKFlags">
            <summary>
            Flags of hotkey triggers.
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.ShareEvent">
            <summary>
            Allow other apps to receive the key down message too.
            Without this flag, other apps usually receive only modifier keys. Also, OS always receives Ctrl+Alt+Delete and some other hotkeys.
            To receive and block key messages is used a low-level hook. Other hooks may receive blocked messages or not, depending on when they were set. 
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.KeyModUp">
            <summary>
            Run the action when the key and modifier keys are released.
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.LeftMod">
            <summary>
            The trigger works only with left-side modifier keys.
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.RightMod">
            <summary>
            The trigger works only with right-side modifier keys.
            </summary>
        </member>
        <member name="F:Au.Triggers.TKFlags.NoModOff">
            <summary>
            Don't release modifier keys.
            Without this flag, for example if trigger is ["Ctrl+K"], when the user presses Ctrl and K down, the trigger sends Ctrl key-up event, making the key logically released, although it is still physically pressed. Then modifier keys don't interfer with the action. However functions like <see cref="M:Au.AKeys.GetMod(Au.Types.KMod)"/> and <see cref="M:Au.AKeys.WaitForKey(System.Double,Au.Types.KKey,System.Boolean,System.Boolean)"/> (and any such functions in any app) will not know that the key is physically pressed; there is no API to get physical key state.
            <note>Unreleased modifier keys will interfere with mouse functions like <see cref="M:Au.AMouse.Click(Au.AWnd,Au.Types.Coord,Au.Types.Coord,System.Boolean)"/>. Will not interfere with keyboard and clipboard functions of this library, because they release modifier keys, unless <b>AOpt.Key.NoModOff</b> is true. Will not interfere with functions that send text, unless <b>AOpt.Key.NoModOff</b> is true and <b>AOpt.Key.TextOption</b> is <b>KTextOption.Keys</b>.</note>.
            Other flags that prevent releasing modifier keys: <b>KeyUp</b>, <b>ShareEvent</b>. Then don't need this flag.
            </summary>
        </member>
        <member name="T:Au.Triggers.HotkeyTrigger">
            <summary>
            Represents a hotkey trigger.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTrigger.TypeString">
            <summary>
            Returns "Hotkey".
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTrigger.Flags">
            
        </member>
        <member name="T:Au.Triggers.HotkeyTriggers">
            <summary>
            Hotkey triggers.
            </summary>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggers.Item(System.String,Au.Triggers.TKFlags)">
            <summary>
            Adds a hotkey trigger.
            </summary>
            <param name="hotkey">
            A hotkey, like with the <see cref="M:Au.AKeys.Key(System.Object[])"/> function.
            Can contain 0 to 4 modifier keys (Ctrl, Shift, Alt, Win) and 1 non-modifier key.
            Examples: "F11", "Ctrl+K", "Ctrl+Shift+Alt+Win+A".
            To ignore modifiers: "?+K". Then the trigger works with any combination of modifiers.
            To ignore a modifier: "Ctrl?+K". Then the trigger works with or without the modifier. More examples: "Ctrl?+Shift?+K", "Ctrl+Shift?+K".
            </param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Invalid hotkey string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
            <example>See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggers.Item(Au.Types.KKey,System.String,Au.Triggers.TKFlags)">
            <summary>
            Adds a hotkey trigger.
            </summary>
            <param name="key"></param>
            <param name="modKeys">
            Modifier keys, like with the <see cref="M:Au.AKeys.Key(System.Object[])"/> function.
            Examples: "Ctrl", "Ctrl+Shift+Alt+Win".
            To ignore modifiers: "?". Then the trigger works with any combination of modifiers.
            To ignore a modifier: "Ctrl?". Then the trigger works with or without the modifier. More examples: "Ctrl?+Shift?", "Ctrl+Shift?".
            </param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggers.Last">
            <summary>
            The last added trigger.
            </summary>
        </member>
        <member name="M:Au.Triggers.HotkeyTriggers.GetEnumerator">
            <summary>
            Used by foreach to enumerate added triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.HotkeyTriggerArgs">
            <summary>
            Arguments for actions of hotkey triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.Trigger">
            
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.Window">
            <summary>
            The active window.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.Key">
            <summary>
            The pressed key.
            </summary>
        </member>
        <member name="P:Au.Triggers.HotkeyTriggerArgs.Mod">
            <summary>
            The pressed modifier keys.
            </summary>
            <remarks>
            Can be useful when the trigger ignores modifiers. For example "?+F11" or "Shift?+A".
            </remarks>
        </member>
        <member name="M:Au.Triggers.HotkeyTriggerArgs.#ctor(Au.Triggers.HotkeyTrigger,Au.AWnd,Au.Types.KKey,Au.Types.KMod)">
            
        </member>
        <member name="T:Au.Triggers.TMFlags">
            <summary>
            Flags of mouse triggers.
            </summary>
        </member>
        <member name="F:Au.Triggers.TMFlags.ShareEvent">
            <summary>
            Allow other apps to receive the mouse button or wheel message too.
            Used only with the click and wheel triggers.
            To receive and block mouse messages is used a low-level hook. Other hooks may receive blocked messages or not, depending on when they were set. 
            </summary>
        </member>
        <member name="F:Au.Triggers.TMFlags.ButtonModUp">
            <summary>
            Run the action when the mouse button and modifier keys are released.
            </summary>
        </member>
        <member name="F:Au.Triggers.TMFlags.LeftMod">
            <summary>
            The trigger works only with left-side modifier keys.
            </summary>
        </member>
        <member name="F:Au.Triggers.TMFlags.RightMod">
            <summary>
            The trigger works only with right-side modifier keys.
            </summary>
        </member>
        <member name="T:Au.Triggers.MouseTrigger">
            <summary>
            Represents a mouse trigger.
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTrigger.TypeString">
            <summary>
            Returns "Mouse".
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTrigger.Flags">
            
        </member>
        <member name="T:Au.Triggers.MouseTriggers">
            <summary>
            Mouse triggers.
            </summary>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMClick,System.String,Au.Triggers.TMFlags)">
            <summary>
            Adds a mouse click trigger.
            </summary>
            <param name="button"></param>
            <param name="modKeys">
            Modifier keys, like with the <see cref="M:Au.AKeys.Key(System.Object[])"/> function.
            Examples: "Ctrl", "Ctrl+Shift+Alt+Win".
            To ignore modifiers: "?". Then the trigger works with any combination of modifiers.
            To ignore a modifier: "Ctrl?". Then the trigger works with or without the modifier. More examples: "Ctrl?+Shift?", "Ctrl+Shift?".
            </param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMWheel,System.String,Au.Triggers.TMFlags)">
            <summary>
            Adds a mouse wheel trigger.
            </summary>
            <param name="direction"></param>
            <param name="modKeys">See <see cref="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMClick,System.String,Au.Triggers.TMFlags)"/>.</param>
            <param name="flags"></param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMEdge,System.String,Au.Triggers.TMFlags,Au.Triggers.TMScreen)">
            <summary>
            Adds a mouse screen edge trigger.
            </summary>
            <param name="edge"></param>
            <param name="modKeys">See <see cref="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMClick,System.String,Au.Triggers.TMFlags)"/>.</param>
            <param name="flags"></param>
            <param name="screen">
            Let the trigger work only in this screen (display monitor). Also you can specify <b>All</b>.
            Default: <b>Primary</b>.
            Uses <see cref="P:System.Windows.Forms.Screen.AllScreens"/> to get screen indices. They may not match the indices that you can see in Windows Settings.
            </param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMMove,System.String,Au.Triggers.TMFlags,Au.Triggers.TMScreen)">
            <summary>
            Adds a mouse move trigger.
            </summary>
            <param name="move"></param>
            <param name="modKeys">See <see cref="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMClick,System.String,Au.Triggers.TMFlags)"/>.</param>
            <param name="flags"></param>
            <param name="screen">See <see cref="P:Au.Triggers.MouseTriggers.Item(Au.Triggers.TMEdge,System.String,Au.Triggers.TMFlags,Au.Triggers.TMScreen)"/>.</param>
            <exception cref="T:System.ArgumentException">Invalid modKeys string or flags.</exception>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
            <example> See <see cref="T:Au.Triggers.ActionTriggers"/>.</example>
        </member>
        <member name="P:Au.Triggers.MouseTriggers.Last">
            <summary>
            The last added trigger.
            </summary>
        </member>
        <member name="T:Au.Triggers.MouseTriggers.LibEdgeMoveDetector">
            <summary>
            Detects trigger events of types Edge and Move.
            </summary>
            <remarks>
            Used in the hook server, to avoid sending all mouse move events to clients, which would use 2 or more times more CPU, eg 0.9% instead of 0.45%. Tested: raw input uses slightly less CPU.
            </remarks>
        </member>
        <member name="T:Au.Triggers.MouseTriggers.LibEdgeMoveDetector._State">
            <summary>
            State data set by previous events.
            </summary>
        </member>
        <member name="M:Au.Triggers.MouseTriggers.GetEnumerator">
            <summary>
            Used by foreach to enumerate added triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.MouseTriggerArgs">
            <summary>
            Arguments for actions of mouse triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTriggerArgs.Trigger">
            
        </member>
        <member name="P:Au.Triggers.MouseTriggerArgs.Window">
            <summary>
            The active window (Edge and Move triggers) or the mouse window (Click and Wheel triggers).
            </summary>
        </member>
        <member name="P:Au.Triggers.MouseTriggerArgs.Mod">
            <summary>
            The pressed modifier keys.
            </summary>
            <remarks>
            Can be useful when the trigger ignores modifiers. For example <i>modKeys</i> is "?" or "Shift?".
            </remarks>
        </member>
        <member name="M:Au.Triggers.MouseTriggerArgs.#ctor(Au.Triggers.MouseTrigger,Au.AWnd,Au.Types.KMod)">
            
        </member>
        <member name="T:Au.Triggers.TMClick">
            <summary>
            Button for mouse click triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TMWheel">
            <summary>
            Mouse wheel direction for mouse wheel triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TMEdge">
            <summary>
            Screen edge for mouse edge triggers.
            </summary>
            <remarks>
            To activate a screen edge trigger, the user touches a screen edge with the mouse pointer.
            Each screen edge is divided into 3 parts: 1 - center 50%; 2 - left or top 25%; 3 - right or bottom 25%. Constants like <b>TopInCenter50</b> specify an edge and part; the trigger works only in that part of that edge. Constants like <b>Top</b> specify just an edge; the trigger works in all parts of that edge.
            </remarks>
        </member>
        <member name="T:Au.Triggers.TMMove">
            <summary>
            Mouse movement directions for mouse move triggers.
            </summary>
            <remarks>
            To activate a mouse move trigger, the user quickly moves the mouse pointer to the specified direction and back.
            The screen is divided into 3 parts: 1 - center 50%; 2 - left or top 25%; 3 - right or bottom 25%. Constants like <b>UpDownInCenter50</b> specify a direction and screen part; the trigger works only in that screen part. Constants like <b>UpDown</b> specify just a direction; the trigger works in whole screen.
            </remarks>
        </member>
        <member name="T:Au.Triggers.TMScreen">
            <summary>
            Screen index for mouse triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.TWFlags">
            <summary>
            Flags of window triggers.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWFlags.RunAtStartup">
            <summary>
            Run the action when <see cref="M:Au.Triggers.ActionTriggers.Run"/> called, if the window then is active (for <b>ActiveOnce</b> etc triggers) or visible (for <b>VisibleOnce</b> etc triggers).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWFlags.LaterCallFunc">
            <summary>
            When using the <i>later</i> parameter, call the currently active <b>Triggers.FuncOf</b> functions on "later" events too.
            If the function returns false, the action will not run.
            The function runs synchronously in the same thread that called <c>Triggers.Run</c>. The action runs asynchronously in another thread, which is slower to start.
            As always, <b>Triggers.FuncOf</b> functions must not contain slow code; should take less than 10 ms.
            </summary>
        </member>
        <member name="T:Au.Triggers.TWEvent">
            <summary>
            Events for window triggers.
            </summary>
            <remarks>
            Cloaked windows are considered invisible. See <see cref="P:Au.AWnd.IsCloaked"/>.
            </remarks>
        </member>
        <member name="F:Au.Triggers.TWEvent.Active">
            <summary>
            When the specified window becomes active (each time).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.ActiveOnce">
            <summary>
            When the specified window becomes active the first time in the trigger's life.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.ActiveNew">
            <summary>
            When the specified window is created and then becomes active.
            The same as <see cref="F:Au.Triggers.TWEvent.ActiveOnce"/>, but windows created before calling <see cref="M:Au.Triggers.ActionTriggers.Run"/> are ignored.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.Visible">
            <summary>
            When the specified window becomes visible (each time).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.VisibleOnce">
            <summary>
            When the specified window becomes visible the first time in the trigger's life.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWEvent.VisibleNew">
            <summary>
            When the specified window is created and then becomes visible.
            The same as <see cref="F:Au.Triggers.TWEvent.VisibleOnce"/>, but windows created before calling <see cref="M:Au.Triggers.ActionTriggers.Run"/> are ignored.
            </summary>
        </member>
        <member name="T:Au.Triggers.TWLater">
            <summary>
            Window events for the <i>later</i> parameter of window triggers.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Name">
            <summary>
            Name changed.
            This event occurs only when the window is active. If name changed while inactive - when activated.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Destroyed">
            <summary>
            Destroyed (closed).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Active">
            <summary>
            Activated (became the foreground window).
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Inactive">
            <summary>
            Deactivated (lose the foreground window status).
            This event also occurs when closing the window, if it was active; then the window possibly is already destroyed, and the handle is invalid.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Visible">
            <summary>
            Became visible.
            The window can be new or was temporarily hidden.
            This event occurs when changed the <see cref="P:Au.AWnd.IsVisible"/> property, and not when changed the <see cref="P:Au.AWnd.IsCloaked"/> property, therefore the window is not actually visible if cloaked.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Invisible">
            <summary>
            Became invisible.
            This event also occurs when closing the window, if it was visible; then the window possibly is already destroyed, and the handle is invalid.
            This event occurs when changed the <see cref="P:Au.AWnd.IsVisible"/> property, and not when changed the <see cref="P:Au.AWnd.IsCloaked"/> property.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Cloaked">
            <summary>
            The window has been cloaked. See <see cref="P:Au.AWnd.IsCloaked"/>.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Uncloaked">
            <summary>
            The window has been uncloaked. See <see cref="P:Au.AWnd.IsCloaked"/>.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Minimized">
            <summary>
            The window has been minimized.
            </summary>
        </member>
        <member name="F:Au.Triggers.TWLater.Unminimized">
            <summary>
            The window has been restored from the minimized state.
            </summary>
        </member>
        <member name="T:Au.Triggers.WindowTrigger">
            <summary>
            Represents a window trigger.
            </summary>
            <example>
            <code><![CDATA[
            Triggers.Window[TWEvent.ActiveNew, "Window name"] = o => Print(o.Window);
            var v = Triggers.Window.Last; //v is the new WindowTrigger. Rarely used.
            ]]></code>
            </example>
        </member>
        <member name="P:Au.Triggers.WindowTrigger.TypeString">
            <summary>
            Returns a trigger type string, like "Window.ActiveNew".
            </summary>
        </member>
        <member name="P:Au.Triggers.WindowTrigger.ParamsString">
            <summary>
            Returns a string containing trigger parameters.
            </summary>
        </member>
        <member name="T:Au.Triggers.WindowTriggers">
            <summary>
            Window triggers.
            </summary>
            <example>
            <code><![CDATA[
            var wt = Triggers.Window; //wt is a WindowTriggers instance
            wt[TWEvent.ActiveNew, "Window name"] = o => Print(o.Window);
            wt[TWEvent.Visible, "Window2 name"] = o => Print(o.Window);
            Triggers.Run();
            ]]></code>
            More examples: <see cref="T:Au.Triggers.ActionTriggers"/>.
            </example>
        </member>
        <member name="P:Au.Triggers.WindowTriggers.Item(Au.Triggers.TWEvent,System.String,System.String,Au.Types.WF3,System.Func{Au.AWnd,System.Boolean},System.Object,Au.Triggers.TWFlags,Au.Triggers.TWLater)">
            <summary>
            Adds a window trigger and its action.
            </summary>
            <param name="winEvent">Trigger event.</param>
            <param name="name">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="cn">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="program">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="also">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="contains">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="flags">Trigger flags.</param>
            <param name="later">
            Can optionally specify one or more additional events.
            This starts to work when the primary trigger is activated, and works only for that window.
            For example, to be notified when the window is closed or renamed, specify <c>later: TWLater.Destroyed | TWLater.Name</c>.
            When a "later" event occurs, the trigger action is executed. The <see cref="P:Au.Triggers.WindowTriggerArgs.Later"/> property then is that event; it is 0 when it is the primary trigger.
            The "later" trigers are not disabled when primary triggers are disabled.
            </param>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</exception>
            <seealso cref="P:Au.Triggers.WindowTriggers.Last"/>
        </member>
        <member name="P:Au.Triggers.WindowTriggers.Item(Au.Triggers.TWEvent,Au.AWnd.Finder,Au.Triggers.TWFlags,Au.Triggers.TWLater)">
            <summary>
            Adds a window trigger and its action.
            </summary>
            <exception cref="T:System.InvalidOperationException">Cannot add triggers after <c>Triggers.Run</c> was called, until it returns.</exception>
        </member>
        <member name="P:Au.Triggers.WindowTriggers.Last">
            <summary>
            The last added trigger.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.LibTimer">
            <summary>
            Called from the message loop every 250 or less ms.
            </summary>
        </member>
        <member name="F:Au.Triggers.WindowTriggers._enumWinProc">
            <summary>
            Callback of EnumWindows used by LibTimer to get visible windows.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._VisibleAddedRemoved">
            <summary>
            Called by LibTimer when it swaps _aVisible with _aVisibleOld and calls EnumWindows to populate _aVisible with visible windows.
            Finds what windows became visible or invisible and runs Visible/Invisible triggers for them.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._HookProc(Au.Types.HookData.AccHookData)">
            <summary>
            AHookAcc hook procedure.
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._Proc(Au.Triggers.TWLater,Au.AWnd,Au.Triggers.WindowTriggers._ProcCaller,System.String)">
            <summary>
            Processes events for main triggers (active, visible) and most "later" triggers.
            Called from hook (_HookProc), timer (LibTimer), at startup (StartStop) and SimulateActiveNew/SimulateVisibleNew.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._ProcLater(Au.Triggers.TWLater,Au.AWnd,System.Int32,System.String)">
            <summary>
            Called to process "later" events from _Proc and timer.
            iTriggered is w index in _aTriggered, or -1 if not found, or -2 (default) to let this func find.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.SimulateActiveNew(Au.AWnd)">
            <summary>
            Simulates event "activated new window" as if the the specified window is that window.
            </summary>
            <exception cref="T:System.InvalidOperationException">Cannot be before or after <c>Triggers.Run</c>.</exception>
            <remarks>
            This function usually is used to run <b>ActiveNew</b> triggers for a window created before calling <see cref="M:Au.Triggers.ActionTriggers.Run"/>. Here "run triggers" means "compare window properties etc with those specified in triggers and run actions of triggers that match". Normally such triggers don't run because the window is considered old. This function runs triggers as it was a new window. Triggers like <b>ActiveNew</b> and <b>ActiveOnce</b> will run once, as usually.
            This function must be called while the main triggers thread is in <c>Triggers.Run</c>, for example from another trigger action. It is asynchronous (does not wait).
            If you call this function from another trigger action (hotkey etc), make sure the window trigger action runs in another thread or can be queed. Else both actions cannot run simultaneously. See example.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Options.RunActionInNewThread(true);
            Triggers.Window[TWEvent.ActiveNew, "* Notepad"] = o => o.Window.Resize(500, 200);
            Triggers.Hotkey["Ctrl+T"] = o => Triggers.Window.SimulateActiveNew(AWnd.Active);
            Triggers.Hotkey["Ctrl+Alt+T"] = o => Triggers.Stop();
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.SimulateVisibleNew(Au.AWnd)">
            <summary>
            Simulates event "visible new window" as if the specified window is that window.
            Similar to <see cref="M:Au.Triggers.WindowTriggers.SimulateActiveNew(Au.AWnd)"/>.
            </summary>
            <param name="w"></param>
            <exception cref="T:System.InvalidOperationException">Cannot be before or after <c>Triggers.Run</c>.</exception>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.LogEvents(System.Boolean,System.Func{Au.AWnd,System.Boolean})">
            <summary>
            Starts or stops to print window events that can help to create or debug window triggers.
            </summary>
            <param name="on">Start (true) or stop.</param>
            <param name="skip">An optional callback function that can be used to reduce noise, eg skip tooltip windows. Return true to skip that window.</param>
            <remarks>
            For primary trigger events is logged this info:
            <ol>
            <li>Time milliseconds. Shows only the remainder of dividing by 10 seconds, therefore it starts from 0 again when reached 9999 (9 seconds and 999 milliseconds).</li>
            <li>Event (see <see cref="T:Au.Triggers.TWLater"/>).</li>
            <li>Letters for window state etc:
            <ul>
            <li>A - the window is active.</li>
            <li>H - the window is invisible (!<see cref="P:Au.AWnd.IsVisible"/>).</li>
            <li>C - the window is cloaked (<see cref="P:Au.AWnd.IsCloaked"/>).</li>
            <li>O - the window is considered old, ie created before calling <c>Triggers.Run</c>.</li>
            <li>T - the even has been detected using a timer, which means slower response time. Else detected using a hook.</li>
            </ul>
            </li>
            <li>Window (handle, class, name, program, rectangle).</li>
            </ol>
            
            Colors are used for window event types used for primary triggers: blue if activated; green if became visible; yellow if name changed.
            For "later" events is logged time, event and window. Black, tab-indented. Prints only events that are specified in triggers.
            When a trigger is activated, prints the event type in red.
            </remarks>
            <example>
            <code><![CDATA[
            Triggers.Window.LogEvents(true, o => 0 != o.ClassNameIs("*tooltip*", "SysShadow", "#32774", "TaskList*"));
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.WindowTriggers._LogEvent(Au.Triggers.TWLater,Au.AWnd,Au.Triggers.WindowTriggers._ProcCaller,System.Boolean)">
            <summary>
            Called by _Proc.
            </summary>
        </member>
        <member name="T:Au.Triggers.WindowTriggers._WndArray">
            <summary>
            For _aTriggered, _aVisible and _aVisibleOld we use resizable array, not List.
            We access elements by index in time-critical code. With List it is much slower.
            </summary>
        </member>
        <member name="M:Au.Triggers.WindowTriggers.GetEnumerator">
            <summary>
            Used by foreach to enumerate added triggers.
            </summary>
        </member>
        <member name="T:Au.Triggers.WindowTriggerArgs">
            <summary>
            Arguments for actions of window triggers.
            </summary>
        </member>
        <member name="P:Au.Triggers.WindowTriggerArgs.Trigger">
            <summary>
            The trigger.
            </summary>
        </member>
        <member name="P:Au.Triggers.WindowTriggerArgs.Window">
            <summary>
            The window.
            </summary>
        </member>
        <member name="P:Au.Triggers.WindowTriggerArgs.Later">
            <summary>
            The "later" event, or 0 if it is the primary trigger (ActiveNew etc). See example.
            </summary>
            <example>
            <code><![CDATA[
            Triggers.Window[TWEvent.ActiveOnce, "*- Notepad", later: TWLater.Active | TWLater.Inactive] = o => Print(o.Later, o.Window);
            Triggers.Run();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.Triggers.WindowTriggerArgs.#ctor(Au.Triggers.WindowTrigger,Au.AWnd,Au.Triggers.TWLater)">
            
        </member>
        <member name="T:Au.Triggers.NamespaceDoc">
            <summary>
            Triggers: hotkeys, autotext, mouse, window.
            </summary>
        </member>
        <member name="T:Au.NamespaceDoc">
            <summary>
            Main classes of the automation library, except triggers.
            </summary>
        </member>
        <member name="T:Au.AWnd">
            <summary>
            A variable of AWnd type represents a window or control. It is a window handle, also known as HWND.
            </summary>
            <remarks>
            AWnd functions can be used with windows and controls of any process/thread. Also can be used with .NET form/control and WPF window class variables, like <c>AWnd w=(AWnd)form; w.Method(...);</c> or <c>((AWnd)form).Method(...);</c>.
            
            There are two main types of windows - top-level windows and controls. Controls are child windows of top-level windows.
            
            More functions are in the nested classes - <see cref="T:Au.AWnd.More"/>, <see cref="T:Au.AWnd.More.Desktop"/> etc. They are used mostly in programming, rarely in automation scripts.
            
            What happens when an AWnd function fails:
            - Functions that get window properties don't throw exceptions. They return false/0/null/empty. Most of them support <see cref="T:Au.ALastError"/>, and it is mentioned in function documentation.
            - Many functions that change window properties throw exception. Exceptions are listed in function documentation. Almost all these functions throw only <see cref="T:Au.Types.AuWndException"/>.
            - Other functions that change window properties return false. They are more often used in programming than in automation scripts.
            - When a 'find' function does not find the window or control, it returns default(AWnd) (window handle 0). Then <see cref="P:Au.AWnd.Is0"/> will return true.
            - If a function does not follow these rules, it is mentioned in function documentation.
            
            Many functions fail if the window's process has a higher [](xref:uac) integrity level (aministrator, uiAccess) than this process, unless this process has uiAccess level. Especially the functions that change window properties. Some functions that still work: <b>Activate</b>, <b>ActivateLL</b>, <b>ShowMinimized</b>, <b>ShowNotMinimized</b>, <b>ShowNotMinMax</b>, <b>Close</b>.
            
            The AWnd type can be used with native Windows API functions without casting. Use AWnd for the parameter type in the declaration, like <c>[DllImport(...)] static extern bool NativeFunction(AWnd hWnd, ...)</c>.
            
            See also: MSDN article <msdn>Window Features</msdn>.
            </remarks>
            <example>
            <code><![CDATA[
            AWnd w = AWnd.Find("* - Notepad");
            if(w.Is0) { Print("window not found"); return; }
            w.Activate();
            AWnd c = w.Child(cn: "Button");
            Print(c.Name);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.op_Implicit(Au.Types.Native.HWND)~Au.AWnd">
            <summary>
            Converts from a special handle value.
            </summary>
            <param name="hwnd">See API <msdn>SetWindowPos</msdn>.</param>
        </member>
        <member name="M:Au.AWnd.op_Explicit(System.Windows.Forms.Control)~Au.AWnd">
            <summary>
            Gets the window handle as AWnd from a System.Windows.Forms.Control (or Form etc) variable.
            Returns default(AWnd) if w is null or the handle is still not created.
            Should be called in c thread. Calls <see cref="P:System.Windows.Forms.Control.IsHandleCreated"/> and <see cref="P:System.Windows.Forms.Control.Handle"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.op_Explicit(System.Windows.Window)~Au.AWnd">
            <summary>
            Gets the window handle as AWnd from a System.Windows.Window variable (WPF window).
            Returns default(AWnd) if w is null or the handle is still not created.
            </summary>
        </member>
        <member name="M:Au.AWnd.op_Equality(Au.AWnd,Au.AWnd)">
            <summary>Compares window handles.</summary>
        </member>
        <member name="M:Au.AWnd.op_Inequality(Au.AWnd,Au.AWnd)">
            <summary>Compares window handles.</summary>
        </member>
        <member name="M:Au.AWnd.Equals(System.Nullable{Au.AWnd})">
            <summary>
            Returns true if w != null and w.Value == this.
            </summary>
        </member>
        <member name="M:Au.AWnd.Equals(System.Object)">
            <summary>
            Returns true if obj is AWnd and contains the same window handle.
            </summary>
        </member>
        <member name="M:Au.AWnd.Equals(Au.AWnd)">
            <summary>
            Returns true if other == this.
            Implements IEquatable. It prevents boxing when used as a key of a collection.
            </summary>
        </member>
        <member name="M:Au.AWnd.CompareTo(Au.AWnd)">
            <summary>
            Implements IComparable. It allows to sort a collection.
            </summary>
        </member>
        <member name="M:Au.AWnd.GetHashCode">
            
        </member>
        <member name="P:Au.AWnd.Handle">
            <summary>
            Gets window handle as IntPtr.
            Code <c>w.Handle</c> is the same as <c>(IntPtr)w</c> .
            </summary>
        </member>
        <member name="M:Au.AWnd.ToString">
            <summary>
            Formats string <c>$"{handle}  {ClassName}  \"{Name}\"  {ProgramName}  {Rect}"</c>.
            </summary>
        </member>
        <member name="M:Au.AWnd.Send(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SendMessage</msdn>.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.SendS(System.Int32,Au.Types.LPARAM,System.String)">
            <summary>
            Calls API <msdn>SendMessage</msdn> where lParam is string.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.SendS(System.Int32,Au.Types.LPARAM,System.Char[])">
            <summary>
            Calls API <msdn>SendMessage</msdn> where lParam is char[].
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.SendTimeout(System.Int32,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM,Au.Types.Native.SMTO)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn>.
            Returns its return value (false if failed). Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.SendTimeout(System.Int32,Au.Types.LPARAM@,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM,Au.Types.Native.SMTO)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> and gets the result of the message processing.
            Returns its return value (false if failed). Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.SendTimeoutS(System.Int32,Au.Types.LPARAM@,System.Int32,Au.Types.LPARAM,System.String,Au.Types.Native.SMTO)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> where lParam is string.
            Returns its return value (false if failed). Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.SendTimeoutS(System.Int32,Au.Types.LPARAM@,System.Int32,Au.Types.LPARAM,System.Char[],Au.Types.Native.SMTO)">
            <summary>
            Calls API <msdn>SendMessageTimeout</msdn> where lParam is char[].
            Returns its return value (false if failed). Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.SendNotify(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SendNotifyMessage</msdn>.
            Returns its return value (false if failed). Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.Post(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>PostMessage</msdn>.
            Returns its return value (false if failed). Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <seealso cref="M:Au.AWnd.More.PostThreadMessage(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)"/>
        </member>
        <member name="T:Au.AWnd.More">
            <summary>
            Miscellaneous window-related functions and classes. Rarely used, or useful only for programmers.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.PostThreadMessage(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Posts a message to the message queue of this thread.
            Calls API <msdn>PostMessage</msdn> with default(AWnd). 
            Returns its return value (false if failed). Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.PostThreadMessage(System.Int32,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>
            Posts a message to the message queue of the specified thread.
            Calls API <msdn>PostThreadMessage</msdn>. 
            Returns its return value (false if failed). Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.WaitForAnActiveWindow">
            <summary>
            Waits while there is no active window.
            It sometimes happens after closing, minimizing or switching the active window, briefly until another window becomes active.
            Waits max 500 ms, then returns false if there is no active window.
            Processes Windows messages that are in the message queue of this thread.
            Don't need to call this after calling functions of this library.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.EnableActivate">
            <summary>
            Temporarily enables this process to activate windows with API <msdn>SetForegroundWindow</msdn>.
            Returns false if fails (unlikely).
            In some cases you may need this function because Windows often disables SetForegroundWindow to not allow applications to activate their windows while the user is working (using keyboard/mouse) with the currently active window. Then SetForegroundWindow just makes the window's taskbar button flash which indicates that the windows wants attention. More info: <msdn>SetForegroundWindow</msdn>.
            Usually you don't call SetForegroundWindow directly. It is called by some other functions, for example Form.Show.
            Don't need to call this function before calling <see cref="M:Au.AWnd.Activate"/> and other functions of this library that activate windows.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.FindMessageOnlyWindow(System.String,System.String,Au.AWnd)">
            <summary>
            Finds a message-only window and returns its handle as <b>AWnd</b>.
            Returns <c>default(AWnd)</c> if not found.
            </summary>
            <param name="name">
            Name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. "" means 'no name'.
            </param>
            <param name="cn">
            Class name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. Cannot be "".
            </param>
            <param name="wAfter">If used, starts searching from the next window in the Z order.</param>
            <remarks>
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>, which does not find message-only windows.
            Finds hidden windows too.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.WindowRectFromClientRect(Au.Types.RECT@,Au.Types.WS,Au.Types.WS_EX,System.Boolean)">
            <summary>
            Calculates window rectangle from client area rectangle and style.
            Calls API <msdn>AdjustWindowRectEx</msdn>.
            </summary>
            <param name="r">Input - client area rectangle in screen. Output - window rectangle in screen.</param>
            <param name="style"></param>
            <param name="exStyle"></param>
            <param name="hasMenu"></param>
            <remarks>
            Ignores styles WS_VSCROLL, WS_HSCROLL and wrapped menu bar.
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.BorderWidth(Au.Types.WS,Au.Types.WS_EX)">
            <summary>
            Calculates window border width from style.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.BorderWidth(Au.AWnd)">
            <summary>
            Gets window border width.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.GetGUIThreadInfo(Au.Types.Native.GUITHREADINFO@,System.Int32)">
            <summary>
            Calls API <msdn>GetGUIThreadInfo</msdn>, which can get some GUI info, eg mouse capturing, menu mode, move/size mode, focus, caret.
            </summary>
            <param name="g">API <msdn>GUITHREADINFO</msdn>.</param>
            <param name="idThread">Thread id. If 0 - the foreground (active window) thread. See <see cref="P:Au.AWnd.ThreadId"/>.</param>
        </member>
        <member name="M:Au.AWnd.More.RegisterWindowClass(System.String,Au.Types.Native.WNDPROC,Au.Types.WndClassEx)">
            <summary>
            Registers new window class in this process.
            </summary>
            <param name="className">Class name.</param>
            <param name="wndProc">
            Window procedure. See <msdn>Window Procedures</msdn>.
            I null, sets API <msdn>DefWindowProc</msdn> as window procedure; then you can create windows with <see cref="M:Au.AWnd.More.CreateWindow(Au.Types.Native.WNDPROC,System.String,System.String,Au.Types.WS,Au.Types.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM)"/> or <see cref="M:Au.AWnd.More.CreateMessageOnlyWindow(Au.Types.Native.WNDPROC,System.String)"/>.
            If not null, it must be a static method; then you can create windows with any other function, including API <msdn>CreateWindowEx</msdn>.
            </param>
            <param name="ex">
            Can be used to specify more fields of <msdn>WNDCLASSEX</msdn> that is passed to API <msdn>RegisterClassEx</msdn>.
            Defaults: hCursor = arrow; hbrBackground = COLOR_BTNFACE+1; style = CS_GLOBALCLASS; others = 0/null/default.
            This function also adds CS_GLOBALCLASS style.
            </param>
            <exception cref="T:System.ArgumentException"><i>wndProc</i> is an instance method. Must be static method or null.</exception>
            <exception cref="T:System.InvalidOperationException">The class already registered with this function and different <i>wndProc</i> method.</exception>
            <exception cref="T:System.ComponentModel.Win32Exception">Failed, for example if the class already exists and was registered not with this function.</exception>
            <remarks>
            Calls API <msdn>RegisterClassEx</msdn>.
            The window class is registered until this process ends. Don't need to unregister.
            If called next time for the same class, does nothing if <i>wndProc</i> is the same method (or both null); then ignores <i>ex</i>. Throws exception if another method.
            Thread-safe.
            Protects the <i>wndProc</i> delegate from GC.
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.CreateWindow(Au.Types.Native.WNDPROC,System.String,System.String,Au.Types.WS,Au.Types.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM)">
            <summary>
            Creates native/unmanaged window of a class registered with <see cref="M:Au.AWnd.More.RegisterWindowClass(System.String,Au.Types.Native.WNDPROC,Au.Types.WndClassEx)"/> with null <i>wndProc</i>, and sets its window procedure.
            </summary>
            <exception cref="T:System.ArgumentException">The class is not registered with <see cref="M:Au.AWnd.More.RegisterWindowClass(System.String,Au.Types.Native.WNDPROC,Au.Types.WndClassEx)"/>, or registered with non-null <i>wndProc</i>.</exception>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            Calls API <msdn>CreateWindowEx</msdn>.
            Protects the <i>wndProc</i> delegate from GC.
            Later call <see cref="M:Au.AWnd.More.DestroyWindow(Au.AWnd)"/> or <see cref="M:Au.AWnd.Close(System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.CreateWindow(System.String,System.String,Au.Types.WS,Au.Types.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM)">
            <summary>
            Creates native/unmanaged window.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            Calls API <msdn>CreateWindowEx</msdn>.
            Later call <see cref="M:Au.AWnd.More.DestroyWindow(Au.AWnd)"/> or <see cref="M:Au.AWnd.Close(System.Boolean,System.Boolean)"/>.
            </remarks>
            <seealso cref="M:Au.AWnd.More.RegisterWindowClass(System.String,Au.Types.Native.WNDPROC,Au.Types.WndClassEx)"/>
        </member>
        <member name="M:Au.AWnd.More.CreateWindowAndSetFont(System.String,System.String,Au.Types.WS,Au.Types.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM,System.IntPtr)">
            <summary>
            Creates native/unmanaged window like <see cref="M:Au.AWnd.More.CreateWindow(Au.Types.Native.WNDPROC,System.String,System.String,Au.Types.WS,Au.Types.WS_EX,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd,Au.Types.LPARAM,System.IntPtr,Au.Types.LPARAM)"/> and sets font.
            </summary>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            If <i>customFontHandle</i> not specified, sets the system UI font, usually it is Segoe UI, 9.
            Later call <see cref="M:Au.AWnd.More.DestroyWindow(Au.AWnd)"/> or <see cref="M:Au.AWnd.Close(System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.CreateMessageOnlyWindow(System.String)">
            <summary>
            Creates native/unmanaged <msdn>message-only window</msdn>.
            </summary>
            <param name="className">Window class name. Can be any existing class.</param>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            Styles: WS_POPUP, WS_EX_NOACTIVATE.
            Later call <see cref="M:Au.AWnd.More.DestroyWindow(Au.AWnd)"/> or <see cref="M:Au.AWnd.Close(System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.CreateMessageOnlyWindow(Au.Types.Native.WNDPROC,System.String)">
            <summary>
            Creates native/unmanaged <msdn>message-only window</msdn> of a class registered with <see cref="M:Au.AWnd.More.RegisterWindowClass(System.String,Au.Types.Native.WNDPROC,Au.Types.WndClassEx)"/> with null <i>wndProc</i>, and sets its window procedure.
            </summary>
            <param name="className">Window class name.</param>
            <param name="wndProc"></param>
            <exception cref="T:System.ArgumentException">The class is not registered with <see cref="M:Au.AWnd.More.RegisterWindowClass(System.String,Au.Types.Native.WNDPROC,Au.Types.WndClassEx)"/>, or registered with non-null <i>wndProc</i>.</exception>
            <exception cref="T:Au.Types.AuException">Failed to create window. Unlikely.</exception>
            <remarks>
            Styles: WS_POPUP, WS_EX_NOACTIVATE.
            Protects the <i>wndProc</i> delegate from GC.
            Later call <see cref="M:Au.AWnd.More.DestroyWindow(Au.AWnd)"/> or <see cref="M:Au.AWnd.Close(System.Boolean,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.DestroyWindow(Au.AWnd)">
            <summary>
            Destroys a native window of this thread.
            Calls API <msdn>DestroyWindow</msdn>.
            Returns false if failed. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <seealso cref="M:Au.AWnd.Close(System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AWnd.More.IsMessageOnlyWindow(Au.AWnd)">
            <summary>
            Returns true if the window is a <msdn>message-only window</msdn>.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.GetWindowsStoreAppId(Au.AWnd,System.Boolean,System.Boolean)">
            <summary>
            Gets window Windows Store app user model id, like "Microsoft.WindowsCalculator_8wekyb3d8bbwe!App".
            Returns null if fails or if called on Windows 7.
            </summary>
            <param name="w"></param>
            <param name="prependShellAppsFolder">Prepend <c>@"shell:AppsFolder\"</c> (to run or get icon).</param>
            <param name="getExePathIfNotWinStoreApp">Get program path if it is not a Windows Store app.</param>
            <remarks>
            Windows Store app window class name can be "Windows.UI.Core.CoreWindow" or "ApplicationFrameWindow".
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.GetClassLong(Au.AWnd,System.Int32)">
            <summary>
            Calls API <msdn>GetClassLongPtr</msdn>.
            </summary>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            For index can be used constants from <see cref="T:Au.Types.Native.GCL"/>. All values are the same in 32-bit and 64-bit process.
            In 32-bit process actually calls <b>GetClassLong</b>, because <b>GetClassLongPtr</b> is unavailable.
            </remarks>
        </member>
        <member name="M:Au.AWnd.More.RegisterMessage(System.String,System.Boolean)">
            <summary>
            Calls API <msdn>RegisterWindowMessage</msdn>.
            </summary>
            <param name="name">Message name. Can be any unique string.</param>
            <param name="uacEnable">Also call API <msdn>ChangeWindowMessageFilter</msdn> for the message. More info: <see cref="M:Au.AWnd.More.UacEnableMessages(System.Int32[])"/>.</param>
        </member>
        <member name="M:Au.AWnd.More.UacEnableMessages(System.Int32[])">
            <summary>
            Calls API <msdn>ChangeWindowMessageFilter</msdn> for each message in the list of messages.
            It allows processes of lower [](xref:uac) integrity level to send these messages to this process.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.PrintMsg(System.String@,System.Windows.Forms.Message@,System.Int32[])">
            <summary>
            Writes a Windows message to a string.
            If the message is one of specified in <i>ignore</i> (which can be null), sets <c>s=null</c> and returns false.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.PrintMsg(System.String@,Au.AWnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM,System.Int32[])">
            <summary>
            Writes a Windows message to a string.
            If the message is one of specified in <i>ignore</i> (which can be null), sets <c>s=null</c> and returns false.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.PrintMsg(System.String@,Au.Types.Native.MSG@,System.Int32[])">
            <summary>
            Writes a Windows message to a string.
            If the message is one of specified in <i>ignore</i> (which can be null), sets <c>s=null</c> and returns false.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.PrintMsg(System.Windows.Forms.Message@,System.Int32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="m"></param>
            <param name="ignore">Messages to skip. Can be null.</param>
        </member>
        <member name="M:Au.AWnd.More.PrintMsg(Au.AWnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM,System.Int32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="w"></param>
            <param name="msg"></param>
            <param name="wParam"></param>
            <param name="lParam"></param>
            <param name="ignore">Messages to skip. Can be null.</param>
        </member>
        <member name="M:Au.AWnd.More.PrintMsg(Au.Types.Native.MSG@,System.Int32[])">
            <summary>
            Writes a Windows message to the output.
            </summary>
            <param name="m">API <msdn>MSG</msdn>.</param>
            <param name="ignore">Messages to skip. Can be null.</param>
        </member>
        <member name="M:Au.AWnd.More.SetWindowSubclass(Au.AWnd,Au.Types.Native.SUBCLASSPROC,Au.Types.LPARAM,System.IntPtr)">
            <summary>API <msdn>SetWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.AWnd.More.GetWindowSubclass(Au.AWnd,Au.Types.Native.SUBCLASSPROC,Au.Types.LPARAM,System.IntPtr@)">
            <summary>API <msdn>GetWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.AWnd.More.RemoveWindowSubclass(Au.AWnd,Au.Types.Native.SUBCLASSPROC,Au.Types.LPARAM)">
            <summary>API <msdn>RemoveWindowSubclass</msdn></summary>
        </member>
        <member name="M:Au.AWnd.More.DefSubclassProc(Au.AWnd,System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)">
            <summary>API <msdn>DefSubclassProc</msdn></summary>
        </member>
        <member name="T:Au.AWnd.More.TaskbarButton">
            <summary>
            Taskbar button flash, progress, add/delete.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.TaskbarButton.Flash(Au.AWnd,System.Int32)">
            <summary>
            Starts or stops flashing the taskbar button.
            </summary>
            <param name="w">Window.</param>
            <param name="count">The number of times to flash. If 0, stops flashing.</param>
        </member>
        <member name="M:Au.AWnd.More.TaskbarButton.SetProgressState(Au.AWnd,Au.Types.TBProgressState)">
            <summary>
            Sets the state of the progress indicator displayed on the taskbar button.
            Calls <msdn>ITaskbarList3.SetProgressState</msdn>.
            </summary>
            <param name="w">Button's window.</param>
            <param name="state">Progress indicator state and color.</param>
        </member>
        <member name="M:Au.AWnd.More.TaskbarButton.SetProgressValue(Au.AWnd,System.Int32,System.Int32)">
            <summary>
            Sets the value of the progress indicator displayed on the taskbar button.
            Calls <msdn>ITaskbarList3.SetProgressValue</msdn>.
            </summary>
            <param name="w">Button's window.</param>
            <param name="progressValue">Progress indicator value, 0 to progressTotal.</param>
            <param name="progressTotal">Max progress indicator value.</param>
        </member>
        <member name="M:Au.AWnd.More.TaskbarButton.Add(Au.AWnd)">
            <summary>
            Adds taskbar button.
            Calls <msdn>ITaskbarList.AddTab</msdn>.
            </summary>
            <param name="w">Button's window.</param>
        </member>
        <member name="M:Au.AWnd.More.TaskbarButton.Delete(Au.AWnd)">
            <summary>
            Deletes taskbar button.
            Calls <msdn>ITaskbarList.DeleteTab</msdn>.
            </summary>
            <param name="w">Button's window.</param>
        </member>
        <member name="T:Au.AWnd.More.Desktop">
            <summary>
            Arranges windows, shows/hides desktop. The same as the taskbar right-click menu commands.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.Desktop.ToggleShowDesktop">
            <summary>
            Shows or hides desktop.
            If there are non-minimized main windows, minimizes them. Else restores windows recently minimized by this function.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.Desktop.MinimizeWindows">
            <summary>
            Minimizes main windows.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.Desktop.CascadeWindows">
            <summary>
            Cascades non-minimized main windows.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.Desktop.TileWindows(System.Boolean)">
            <summary>
            Arranges non-minimized main windows horizontally or vertically.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.Desktop.UndoMinimizeEtc">
            <summary>
            Restores windows recently minimized, cascaded or tiled with other functions of this class.
            </summary>
        </member>
        <member name="T:Au.AWnd.More.CopyDataStruct">
            <summary>
            Makes easier to send and receive data to/from other processes using message <msdn>WM_COPYDATA</msdn>.
            </summary>
            <remarks>
            This struct is <msdn>COPYDATASTRUCT</msdn>.
            <note>By default [](xref:uac) blocks messages sent from processes of lower integrity level. Call <see cref="M:Au.AWnd.More.CopyDataStruct.EnableReceivingWM_COPYDATA"/> if need.</note>
            </remarks>
            <seealso cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile"/>
            <seealso cref="T:System.IO.Pipes.NamedPipeServerStream"/>
        </member>
        <member name="M:Au.AWnd.More.CopyDataStruct.SendString(Au.AWnd,System.Int32,System.String,Au.Types.LPARAM)">
            <summary>
            Sends string to a window of another process using API <msdn>SendMessage</msdn>(<msdn>WM_COPYDATA</msdn>).
            </summary>
            <returns><b>SendMessage</b>'s return value.</returns>
            <param name="w">The window.</param>
            <param name="dataId">Data id. It is <msdn>COPYDATASTRUCT.dwData</msdn>.</param>
            <param name="s">Data. Can contain '\0' characters.</param>
            <param name="wParam">wParam of WM_COPYDATA. Optional.</param>
        </member>
        <member name="M:Au.AWnd.More.CopyDataStruct.SendBytes(Au.AWnd,System.Int32,System.Byte[],Au.Types.LPARAM)">
            <summary>
            Sends byte[] to a window of another process using API <msdn>SendMessage</msdn>(<msdn>WM_COPYDATA</msdn>).
            More info: <see cref="M:Au.AWnd.More.CopyDataStruct.SendString(Au.AWnd,System.Int32,System.String,Au.Types.LPARAM)"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.CopyDataStruct.#ctor(Au.Types.LPARAM)">
            <summary>
            Initializes this variable from <i>lParam</i> of a received <msdn>WM_COPYDATA</msdn> message.
            Then you can call methods and properties of this variable to get data in managed format.
            </summary>
            <param name="lParam"><i>lParam</i> of a <msdn>WM_COPYDATA</msdn> message received in a window procedure. It is <msdn>COPYDATASTRUCT</msdn> pointer.</param>
        </member>
        <member name="P:Au.AWnd.More.CopyDataStruct.DataId">
            <summary>
            Data id. It is <msdn>COPYDATASTRUCT.dwData</msdn>.
            </summary>
        </member>
        <member name="P:Au.AWnd.More.CopyDataStruct.RawData">
            <summary>
            Unmanaged data pointer. It is <msdn>COPYDATASTRUCT.lpData</msdn>.
            </summary>
        </member>
        <member name="P:Au.AWnd.More.CopyDataStruct.RawDataSize">
            <summary>
            Unmanaged data size. It is <msdn>COPYDATASTRUCT.cbData</msdn>.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.CopyDataStruct.GetString">
            <summary>
            Gets received data as string.
            </summary>
        </member>
        <member name="M:Au.AWnd.More.CopyDataStruct.GetBytes">
            <summary>
            Gets received data as byte[].
            </summary>
        </member>
        <member name="M:Au.AWnd.More.CopyDataStruct.EnableReceivingWM_COPYDATA">
            <summary>
            Calls API <msdn>ChangeWindowMessageFilter</msdn>(<b>WM_COPYDATA</b>). Then windows of this process can receive this message from lower [](xref:uac) integrity level processes.
            </summary>
        </member>
        <member name="M:Au.AWnd.ThrowIf0">
            <summary>
            If <see cref="P:Au.AWnd.Is0"/>, throws <see cref="T:Au.Types.AuWndException"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.AWnd.ThrowIfInvalid">
            <summary>
            If <see cref="P:Au.AWnd.Is0"/> or !<see cref="P:Au.AWnd.IsAlive"/>, throws <see cref="T:Au.Types.AuWndException"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.AWnd.ThrowUseNative">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses the last Windows API error (code and message).
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.AWnd.ThrowUseNative(System.String)">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses mainMessage and the last Windows API error (code and message).
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.AWnd.ThrowUseNative(System.Int32,System.String)">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses mainMessage and the specified Windows API error code.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="M:Au.AWnd.ThrowNoNative(System.String)">
            <summary>
            Throws <see cref="T:Au.Types.AuWndException"/> that uses mainMessage and does not use the last Windows API error.
            Also the message depends on whether the window handle is 0/invalid.
            </summary>
            <exception cref="T:Au.Types.AuWndException"></exception>
        </member>
        <member name="P:Au.AWnd.Is0">
            <summary>
            Returns true if the window handle is 0 (this variable == default(AWnd)).
            </summary>
            <example>
            <code><![CDATA[
            AWnd w = AWnd.Find("Window*");
            if(w.Is0) { Print("window not found"); return; }
            ]]></code>
            </example>
            <seealso cref="P:Au.AWnd.IsAlive"/>
        </member>
        <member name="P:Au.AWnd.IsAlive">
            <summary>
            Returns true if the window exists (the window handle is valid).
            Returns false if the handle is 0 or invalid.
            Invalid non-0 handle usually means that the window is closed/destroyed.
            </summary>
            <remarks>
            Calls <see cref="P:Au.AWnd.Is0"/> and API <msdn>IsWindow</msdn>.
            Although an AWnd variable holds a window handle, which is like a reference to a window, it does not prevent closing that window and making the handle invalid. After closing the window, the OS can even assign the same handle value to a new window, although normally it can happen only after long time.
            <note>Use this carefully with windows of other applications or threads. The window can be closed at any moment, even when your thread is still in this function.</note>
            </remarks>
        </member>
        <member name="P:Au.AWnd.IsVisible">
            <summary>
            Returns true if the window is visible.
            Returns false if is invisible or is a child of invisible parent.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <remarks>
            Calls API <msdn>IsWindowVisible</msdn>. Does not call <see cref="P:Au.AWnd.IsCloaked"/>.
            
            Even when this function returns true, the window may be actually invisible. It can be cloaked, on an inactive Windows 10 virtual desktop (cloaked), inactive Windows Store app (cloaked), transparent, zero-size, minimized, off-screen, covered by other windows or can have zero-size window region.
            </remarks>
            <seealso cref="P:Au.AWnd.IsCloaked"/>
            <seealso cref="P:Au.AWnd.IsVisibleAndNotCloaked"/>
            <seealso cref="M:Au.AWnd.Show(System.Boolean)"/>
            <seealso cref="M:Au.AWnd.Activate"/>
        </member>
        <member name="P:Au.AWnd.IsVisibleAndNotCloaked">
            <summary>
            Returns true if <see cref="P:Au.AWnd.IsVisible"/> returns true and <see cref="P:Au.AWnd.IsCloaked"/> returns false.
            </summary>
        </member>
        <member name="M:Au.AWnd.LibIsVisibleIn(Au.AWnd)">
            <summary>
            Returns true if this window is visible in the specified parent or ancestor window.
            Like <see cref="P:Au.AWnd.IsVisible"/>, but does not check the visibility of the specified parent/ancestor window.
            </summary>
            <param name="wParent">Parent or ancestor window.</param>
        </member>
        <member name="M:Au.AWnd.Show(System.Boolean)">
            <summary>
            Shows (if hidden) or hides this window.
            Does not activate/deactivate/zorder.
            With windows of current thread usually it's better to use <see cref="M:Au.AWnd.ShowLL(System.Boolean)"/>.
            </summary>
            <remarks>
            Calls API <msdn>ShowWindow</msdn> with SW_SHOWNA or SW_HIDE.
            </remarks>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.AWnd.ShowLL(System.Boolean)">
            <summary>
            Shows (if hidden) or hides this window.
            Does not activate/deactivate/zorder.
            </summary>
            <remarks>
            This library has two similar functions - <see cref="M:Au.AWnd.Show(System.Boolean)"/> and <b>ShowLL</b>. <b>Show</b> is better to use in automation scripts, with windows of any process/thread. <b>ShowLL</b> usually is better to use in programming, with windows of current thread.
            <b>ShowLL</b> is more low-level. Does not throw exception when fails, and does not add a delay; <b>Show</b> adds a small delay when the window is of other thread.
            
            Calls API <msdn>ShowWindow</msdn> with SW_SHOWNA or SW_HIDE.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.IsEnabled(System.Boolean)">
            <summary>
            Returns true if the window is enabled for mouse and keyboard input.
            Returns false if disabled. Also false if failed (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="ancestorsToo">Check whether all ancestors of this control are enabled too. If false (default), this function simply calls API <msdn>IsWindowEnabled</msdn>, which usualy returns true for controls in disabled windows.</param>
        </member>
        <member name="M:Au.AWnd.Enable(System.Boolean)">
            <summary>
            Enables or disables.
            Calls API <msdn>EnableWindow</msdn>.
            </summary>
            <param name="enable">Enable or disable.</param>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="P:Au.AWnd.IsCloakedGetState">
            <summary>
            Gets the cloaked state.
            Returns 0 if not cloaked or if failed.
            Else returns flags: 1 cloaked by its application, 2 cloaked by Windows, 4 cloaked because its owner window is cloaked.
            On Windows 7 returns 0 because there is no "cloaked window" feature.
            </summary>
            <seealso cref="P:Au.AWnd.IsCloaked"/>
        </member>
        <member name="P:Au.AWnd.IsCloaked">
            <summary>
            Returns true if the window is cloaked.
            Returns false if not cloaked or if failed.
            On Windows 7 returns false because there is no "cloaked window" feature.
            Windows 10 uses window cloaking mostly to hide windows on inactive desktops. Windows 8 - mostly to hide Windows Store app windows.
            </summary>
            <seealso cref="P:Au.AWnd.IsCloakedGetState"/>
        </member>
        <member name="P:Au.AWnd.IsMinimized">
            <summary>
            Returns true if minimized, false if not.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            Calls API <msdn>IsIconic</msdn>.
            </summary>
        </member>
        <member name="P:Au.AWnd.IsMaximized">
            <summary>
            Returns true if maximized, false if not.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            Calls API <msdn>IsZoomed</msdn>.
            </summary>
        </member>
        <member name="M:Au.AWnd.ShowMinimized(System.Boolean)">
            <summary>
            If not minimized, minimizes.
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.AuWndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.AWnd.ShowMaximized(System.Boolean)">
            <summary>
            If not minimized, minimizes.
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.AuWndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.AWnd.ShowNotMinMax(System.Boolean)">
            <summary>
            If maximized or minimized, makes normal (not min/max).
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.AuWndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.AWnd.ShowNotMinimized(System.Boolean)">
            <summary>
            If minimized, restores previous non-minimized state (maximized or normal).
            Also unhides.
            </summary>
            <param name="noAnimation">Visually fast, without animation.</param>
            <exception cref="T:Au.Types.AuWndException">The API call failed. No exception if the window did not obey.</exception>
        </member>
        <member name="M:Au.AWnd._MinMaxRes(System.Int32,System.Boolean)">
            <summary>
            Sets window min/max/normal/restore state.
            Also unhides.
            </summary>
            <param name="state">Must be SW_MINIMIZE, SW_RESTORE (restores to normal/max if minimized), SW_SHOWNORMAL or SW_SHOWMAXIMIZED.</param>
            <param name="noAnimation">Use SetWindowPlacement (no animation).</param>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.AWnd.LibGetWindowPlacement(Au.Types.Api.WINDOWPLACEMENT@,System.String)">
            <summary>
            Initializes a WINDOWPLACEMENT struct and calls API <msdn>GetWindowPlacement</msdn>.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
            <exception cref="T:Au.Types.AuWndException">Failed. Throws, only if errStr!=null, else returns false.</exception>
        </member>
        <member name="M:Au.AWnd.LibSetWindowPlacement(Au.Types.Api.WINDOWPLACEMENT@,System.String)">
            <summary>
            Sets WINDOWPLACEMENT <b>length</b> field and calls API <msdn>SetWindowPlacement</msdn>.
            </summary>
            <exception cref="T:Au.Types.AuWndException">Failed. Throws, only if errStr!=null, else returns false.</exception>
        </member>
        <member name="T:Au.AWnd.Lib">
            <summary>
            Internal static functions.
            </summary>
        </member>
        <member name="M:Au.AWnd.Lib.EnableActivate(System.Boolean)">
            <summary>
            No exceptions.
            </summary>
        </member>
        <member name="M:Au.AWnd.Lib._EnableActivate_SendKey(System.Boolean)">
            <summary>
            Sends a key (VK_0 up). It allows to activate now.
            Later this process can always activate easily (without key etc). It works even with higher IL windows.
            Don't know why is this behavior. Tested on all OS from XP to 10.
            Does not work if the foreground process has higher UAC IL.
            </summary>
        </member>
        <member name="M:Au.AWnd.Lib._EnableActivate_MinRes">
            <summary>
            Creates a temporary minimized window and restores it. It activates the window and allows us to activate.
            Then sets 'no active window' to prevent auto-activating another window when destroying the temporary window.
            </summary>
        </member>
        <member name="M:Au.AWnd.Lib._EnableActivate_AllowSetFore">
            <summary>
            Calls Api.AllowSetForegroundWindow(Api.GetCurrentProcessId()).
            </summary>
        </member>
        <member name="F:Au.AWnd.Lib.ActivateFlags.NoThrowIfInvalid">
            <summary>
            Don't call ThrowIfInvalid at the very start (ie called ensures it is valid).
            </summary>
        </member>
        <member name="F:Au.AWnd.Lib.ActivateFlags.NoGetWindow">
            <summary>
            Don't call Get.Window (ie caller ensures it's a top-level window, not control).
            </summary>
        </member>
        <member name="F:Au.AWnd.Lib.ActivateFlags.IgnoreIfNoActivateStyleEtc">
            <summary>
            Don't activate if has WS_EX_NOACTIVATE style or is toolwindow without caption, unless cloaked.
            Then just calls ZorderTop(), which in most cases does not work (inactive window).
            </summary>
        </member>
        <member name="F:Au.AWnd.Lib.ActivateFlags.ForScreenCapture">
            <summary>
            Wait for window animations to end. Eg when switching Win10 desktops.
            </summary>
        </member>
        <member name="M:Au.AWnd.Lib.MoveInScreen(System.Boolean,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AWnd,Au.Types.RECT@,Au.AScreen,System.Boolean,System.Boolean,System.Nullable{Au.Types.RECT})">
            <summary>
            Used directly by MoveInScreen, EnsureInScreen, RECT.MoveInScreen, RECT.EnsureInScreen. With inRect used by RECT.MoveInRect.
            </summary>
        </member>
        <member name="M:Au.AWnd.Lib.EnumWindows2(Au.AWnd.Lib.EnumAPI,System.Boolean,System.Boolean,Au.AWnd,System.Boolean,System.Int32,System.Func{Au.AWnd,System.Object,System.Boolean},System.Object,System.Collections.Generic.List{Au.AWnd})">
            <summary>
            This version creates much less garbage.
            The caller must dispose the returned LibArrayBuilder, unless list is not null.
            If list is not null, adds windows there (clears at first) and returns default(LibArrayBuilder).
            </summary>
        </member>
        <member name="M:Au.AWnd.Lib.GetWindowsStoreAppId(Au.AWnd,System.String@,System.Boolean,System.Boolean)">
            <summary>
            Gets window Windows Store app user model id, like "Microsoft.WindowsCalculator_8wekyb3d8bbwe!App".
            Returns 1 if gets user model id, 2 if gets path, 0 if fails.
            </summary>
            <param name="w">Window.</param>
            <param name="appId">Receives app ID.</param>
            <param name="prependShellAppsFolder">Prepend <c>@"shell:AppsFolder\"</c> (to run or get icon).</param>
            <param name="getExePathIfNotWinStoreApp">Get program path if it is not a Windows Store app.</param>
        </member>
        <member name="T:Au.AWnd.Lib.WinFlags">
            <summary>
            Calls API SetProp/GetProp to set/get window flags <see cref="T:Au.AWnd.Lib.WFlags"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.Lib.IsSpecHwnd(Au.AWnd)">
            <summary>
            Returns true if w contains a non-zero special handle value (<see cref="T:Au.Types.Native.HWND"/>).
            Note: <b>Native.HWND.TOP</b> is 0.
            </summary>
        </member>
        <member name="M:Au.AWnd.LibActivate(Au.AWnd.Lib.ActivateFlags)">
            <summary>
            Activates this window (brings to the foreground).
            The same as <see cref="M:Au.AWnd.Activate"/>, but has some options.
            Returns false if does not activate because of flag IgnoreIfNoActivateStyleEtc.
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.AWnd.Activate">
            <summary>
            Activates this window. Also makes it visible and not minimized.
            The active window is in the foreground and receives keyboard and mouse input.
            </summary>
            <remarks>
            Activating a window usually also uncloaks it, for example switches to its virtual desktop on Windows 10.
            Fails (throws exception) if cannot activate this window, except:
            - If this is a control. Then activates its top-level parent window.
            - If this is <see cref="P:Au.AWnd.GetWnd.Root"/>. Then just deactivates the currently active window.
            - When the target application instead activates another window of the same thread.
            </remarks>
            <exception cref="T:Au.Types.AuWndException"/>
            <seealso cref="M:Au.AWnd.ActivateLL"/>
            <seealso cref="P:Au.AWnd.IsActive"/>
            <seealso cref="P:Au.AWnd.Active"/>
            <seealso cref="M:Au.AWnd.SwitchActiveWindow"/>
        </member>
        <member name="M:Au.AWnd.ActivateLL">
            <summary>
            Low-level version of <see cref="M:Au.AWnd.Activate"/>.
            Just calls <see cref="M:Au.AWnd.More.EnableActivate"/>, API <msdn>SetForegroundWindow</msdn> and makes sure that it actually worked, but does not check whether it activated exactly this window.
            No exceptions, does not unhide, does not restore minimized, does not check is it a top-level window or control, etc.
            Returns false if fails.
            </summary>
        </member>
        <member name="M:Au.AWnd.Focus">
            <summary>
            Sets the keyboard input focus to this control.
            Also activetes its top-level parent window (see <see cref="M:Au.AWnd.Activate"/>).
            </summary>
            <remarks>
            The control can belong to any process/thread. With controls of this thread you can use the more lightweight function <see cref="M:Au.AWnd.ThisThread.Focus(Au.AWnd)"/>.
            Works not with all windows. For example, does not work with Windows Store apps. Then use <see cref="M:Au.AAcc.Focus(System.Boolean)"/>.
            Can instead focus a child control. For example, if this is a ComboBox, it will focus its child Edit control. Then does not throw exception.
            This can be control or top-level window. Top-level windows also can have focus.
            </remarks>
            <exception cref="T:Au.Types.AuWndException">
            - Invalid handle.
            - Disabled.
            - Failed to set focus.
            - Failed to activate parent window.
            Fails to set focus when the target process is admin or uiAccess and this process isn't. See [](xref:uac).
            </exception>
            <seealso cref="P:Au.AWnd.Focused"/>
            <seealso cref="P:Au.AWnd.IsFocused"/>
            <seealso cref="M:Au.AAcc.Focus(System.Boolean)"/>
        </member>
        <member name="P:Au.AWnd.Focused">
            <summary>
            Gets the control or window that has the keyboard input focus.
            </summary>
            <remarks>
            The control/window can belong to any process/thread. With controls/windows of this thread you can use the more lightweight function <see cref="P:Au.AWnd.ThisThread.Focused"/>.
            Calls API <msdn>GetGUIThreadInfo</msdn>.
            </remarks>
            <seealso cref="M:Au.AWnd.Focus"/>
            <seealso cref="P:Au.AWnd.IsFocused"/>
        </member>
        <member name="P:Au.AWnd.IsFocused">
            <summary>
            Returns true if this is the control or window that has the keyboard input focus.
            </summary>
            <remarks>
            This control/window can belong to any process/thread. With controls/windows of this thread you can use the more lightweight function <see cref="M:Au.AWnd.ThisThread.IsFocused(Au.AWnd)"/>.
            Calls <see cref="P:Au.AWnd.Focused"/>.
            </remarks>
            <seealso cref="M:Au.AWnd.Focus"/>
        </member>
        <member name="T:Au.AWnd.ThisThread">
            <summary>
            Functions that can be used only with windows/controls of this thread.
            </summary>
        </member>
        <member name="M:Au.AWnd.ThisThread.Focus(Au.AWnd)">
            <summary>
            Calls API <msdn>SetFocus</msdn>. It sets the keyboard input focus to the specified control or window, which must be of this thread.
            Returns false if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <remarks>
            Fails if the control/window belongs to another thread or is invalid or disabled.
            Can instead focus a child control. For example, if ComboBox, will focus its child Edit control. Then returns true.
            </remarks>
        </member>
        <member name="P:Au.AWnd.ThisThread.Focused">
            <summary>
            Gets the focused control or window of this thread.
            </summary>
            <remarks>
            Calls API <msdn>GetFocus</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.ThisThread.FocusedControl">
            <summary>
            Gets the focused control or form of this thread.
            </summary>
            <remarks>
            Calls API <msdn>GetFocus</msdn> and <see cref="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.ThisThread.IsFocused(Au.AWnd)">
            <summary>
            Returns true if w is the focused control or window of this thread.
            </summary>
            <remarks>
            Calls API <msdn>GetFocus</msdn>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.ThisThread.Active">
            <summary>
            Gets the active window of this thread.
            Calls API <msdn>GetActiveWindow</msdn>.
            </summary>
        </member>
        <member name="M:Au.AWnd.GetRect(Au.Types.RECT@,System.Boolean)">
            <summary>
            Gets rectangle (position and size) in screen coordinates.
            </summary>
            <param name="r">Receives the rectangle. Will be default(RECT) if failed.</param>
            <param name="withoutExtendedFrame">Don't include the transparent part of window border. For it is used API <msdn>DwmGetWindowAttribute</msdn>(DWMWA_EXTENDED_FRAME_BOUNDS); it is less reliable.</param>
            <remarks>
            The same as the <see cref="P:Au.AWnd.Rect"/> property.
            Calls API <msdn>GetWindowRect</msdn> and returns its return value.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetSize(Au.Types.SIZE@)">
            <summary>
            Gets width and height.
            </summary>
            <param name="z">Receives width and height. Will be default(SIZE) if failed.</param>
            <remarks>
            The same as the <see cref="P:Au.AWnd.Size"/> property.
            Calls API <msdn>GetWindowRect</msdn> and returns its return value.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.Rect">
            <summary>
            Gets rectangle (position and size) in screen coordinates.
            </summary>
            <remarks>
            Calls <see cref="M:Au.AWnd.GetRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.AWnd.Size">
            <summary>
            Gets width and height.
            </summary>
            <remarks>
            Calls <see cref="M:Au.AWnd.GetSize(Au.Types.SIZE@)"/>. Returns default(SIZE) if fails (eg window closed).
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.X">
            <summary>
            Gets horizontal position in screen coordinates.
            </summary>
            <remarks>Calls <see cref="M:Au.AWnd.GetRect(Au.Types.RECT@,System.Boolean)"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.Y">
            <summary>
            Gets vertical position in screen coordinates.
            </summary>
            <remarks>Calls <see cref="M:Au.AWnd.GetRect(Au.Types.RECT@,System.Boolean)"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.Width">
            <summary>
            Gets width.
            </summary>
            <remarks>Calls <see cref="M:Au.AWnd.GetRect(Au.Types.RECT@,System.Boolean)"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.Height">
            <summary>
            Gets height.
            </summary>
            <remarks>Calls <see cref="M:Au.AWnd.GetRect(Au.Types.RECT@,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.GetClientRect(Au.Types.RECT@,System.Boolean)">
            <summary>
            Gets client area rectangle.
            </summary>
            <param name="r">Receives the rectangle. Will be default(RECT) if failed.</param>
            <param name="inScreen">
            Get rectangle in screen coordinates; the same as <see cref="M:Au.AWnd.GetWindowAndClientRectInScreen(Au.Types.RECT@,Au.Types.RECT@)"/>.
            If false (default), calls API <msdn>GetClientRect</msdn>; the same as <see cref="P:Au.AWnd.ClientRect"/> or <see cref="M:Au.AWnd.GetClientSize(Au.Types.SIZE@)"/>.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetClientSize(Au.Types.SIZE@)">
            <summary>
            Gets client area width and height.
            </summary>
            <param name="z">Receives width and height. Will be default(RECT) if failed.</param>
            <remarks>
            The same as the <see cref="P:Au.AWnd.ClientSize"/> property.
            The same as <see cref="M:Au.AWnd.GetClientRect(Au.Types.RECT@,System.Boolean)"/>, just the parameter type is different.
            Calls API <msdn>GetClientRect</msdn> and returns its return value.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.ClientRect">
            <summary>
            Gets client area rectangle (width and height).
            </summary>
            <remarks>
            The same as <see cref="P:Au.AWnd.ClientSize"/>, just the return type is different.
            The left and top fields are always 0. The right and bottom fields are the width and height of the client area.
            Calls <see cref="M:Au.AWnd.GetClientRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.AWnd.ClientRectInScreen">
            <summary>
            Gets client area rectangle (width and height) in screen.
            </summary>
            <remarks>
            Calls <see cref="M:Au.AWnd.GetClientRect(Au.Types.RECT@,System.Boolean)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.AWnd.ClientSize">
            <summary>
            Gets client area width and height.
            </summary>
            <remarks>
            The same as <see cref="P:Au.AWnd.ClientRect"/>, just the return type is different.
            Calls <see cref="M:Au.AWnd.GetClientSize(Au.Types.SIZE@)"/>. Returns default(SIZE) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.AWnd.ClientWidth">
            <summary>
            Gets client area width.
            </summary>
            <remarks>Calls <see cref="M:Au.AWnd.GetClientSize(Au.Types.SIZE@)"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.ClientHeight">
            <summary>
            Gets client area height.
            </summary>
            <remarks>Calls <see cref="M:Au.AWnd.GetClientSize(Au.Types.SIZE@)"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.SetClientSize(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Calculates and sets window rectangle from the specified client area rectangle.
            Calls <see cref="M:Au.AWnd.ResizeLL(System.Int32,System.Int32)"/>.
            </summary>
            <param name="width">Width. Use null to not change.</param>
            <param name="height">Height. Use null to not change.</param>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.AWnd.LibGetWindowInfo(Au.Types.Api.WINDOWINFO@)">
            <summary>
            Calls API <msdn>GetWindowInfo</msdn>.
            </summary>
            <param name="wi">Receives window/client rectangles, styles etc.</param>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.GetWindowAndClientRectInScreen(Au.Types.RECT@,Au.Types.RECT@)">
            <summary>
            Gets window rectangle and client area rectangle, both in screen coordinates.
            </summary>
            <param name="rWindow">Receives window rectangle.</param>
            <param name="rClient">Receives client area rectangle.</param>
            <remarks>Calls API <msdn>GetWindowInfo</msdn>. Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapClientToClientOf(Au.AWnd,Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the client area of window w.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapClientToClientOf(Au.AWnd,Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the client area of window w.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapClientToScreen(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the screen.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapClientToScreen(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the screen.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapScreenToClient(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the screen to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapScreenToClient(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the screen to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapClientToWindow(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the top-left corner of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapClientToWindow(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the client area of this window to coordinates relative to the top-left corner of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapWindowToClient(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapWindowToClient(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to coordinates relative to the client area of this window.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapWindowToScreen(Au.Types.POINT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to screen coordinates.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.MapWindowToScreen(Au.Types.RECT@)">
            <summary>
            Converts coordinates relative to the top-left corner of this window to screen coordinates.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.GetRectIn(Au.AWnd,Au.Types.RECT@)">
            <summary>
            Gets rectangle of this window (usually control) relative to the client area of another window (usually parent).
            </summary>
            <param name="w">Parent, ancestor or any other window or control. If <c>default(AWnd)</c>, gets rectangle in screen.</param>
            <param name="r">Receives the rectangle.</param>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
            <seealso cref="P:Au.AWnd.RectInDirectParent"/>
            <seealso cref="P:Au.AWnd.RectInWindow"/>
        </member>
        <member name="P:Au.AWnd.RectInDirectParent">
            <summary>
            Gets child window rectangle in the client area of the direct parent window.
            </summary>
            <remarks>
            Calls <see cref="P:Au.AWnd.GetWnd.DirectParent"/> and <see cref="M:Au.AWnd.GetRectIn(Au.AWnd,Au.Types.RECT@)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="P:Au.AWnd.RectInWindow">
            <summary>
            Gets child window rectangle in the client area of the top-level parent window.
            </summary>
            <remarks>
            Calls <see cref="P:Au.AWnd.Window"/> and <see cref="M:Au.AWnd.GetRectIn(Au.AWnd,Au.Types.RECT@)"/>. Returns default(RECT) if fails (eg window closed).
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetRectNotMinMax(Au.Types.RECT@)">
            <summary>
            Gets rectangle of normal (restored) window even if currently it is minimized or maximized.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.MouseClientXY">
            <summary>
            Returns mouse pointer position relative to the client area of this window.
            </summary>
        </member>
        <member name="M:Au.AWnd.ContainsScreenXY(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Returns true if this window (its rectangle) contains the specified point.
            </summary>
            <param name="x">X coordinate in screen. Not used if default(Coord).</param>
            <param name="y">Y coordinate in screen. Not used if default(Coord).</param>
        </member>
        <member name="M:Au.AWnd.ContainsWindowXY(Au.AWnd,Au.Types.Coord,Au.Types.Coord)">
            <summary>
            Returns true if this control (its rectangle) contains the specified point in parent window.
            </summary>
            <param name="parent">
            Direct or indirect parent window. The coordinates are relative to its client area.
            Actually this and parent can be any windows or controls, the function does not check whether this is a child of parent.
            </param>
            <param name="x">X coordinate. Not used if default(Coord).</param>
            <param name="y">Y coordinate. Not used if default(Coord).</param>
        </member>
        <member name="M:Au.AWnd.ContainsWindowXY(Au.Types.Coord,Au.Types.Coord)">
            <summary>
            This overload calls <see cref="M:Au.AWnd.ContainsWindowXY(Au.AWnd,Au.Types.Coord,Au.Types.Coord)"/>(Window, x, y).
            </summary>
        </member>
        <member name="M:Au.AWnd.SetWindowPos(Au.Types.Native.SWP,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd)">
            <summary>
            Calls API <msdn>SetWindowPos</msdn>.
            </summary>
            <param name="swpFlags"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="cx"></param>
            <param name="cy"></param>
            <param name="wndInsertAfter">A window or <see cref="T:Au.Types.Native.HWND"/>.<b>TOP</b>, <b>BOTTOM</b>, <b>TOPMOST</b>, <b>NOTOPMOST</b>.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.MoveLL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.Native.SWP)">
            <summary>
            Moves and resizes.
            </summary>
            <remarks>
            See also <see cref="M:Au.AWnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max, does not support SWP flags.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags NOZORDER|NOOWNERZORDER|NOACTIVATE|swpFlagsToAdd. It is better to use in programming, with windows of current thread.
            Supports <see cref="T:Au.ALastError"/>.
            
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <seealso cref="M:Au.AWnd.SetWindowPos(Au.Types.Native.SWP,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd)"/>
        </member>
        <member name="M:Au.AWnd.MoveLL(System.Int32,System.Int32)">
            <summary>
            Moves.
            </summary>
            <remarks>
            See also <see cref="M:Au.AWnd.Move(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags NOSIZE|NOZORDER|NOOWNERZORDER|NOACTIVATE. It is better to use in programming, with windows of current thread.
            Supports <see cref="T:Au.ALastError"/>.
            
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            </remarks>
            <seealso cref="M:Au.AWnd.SetWindowPos(Au.Types.Native.SWP,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd)"/>
        </member>
        <member name="M:Au.AWnd.ResizeLL(System.Int32,System.Int32)">
            <summary>
            Resizes.
            </summary>
            <remarks>
            See also <see cref="M:Au.AWnd.Resize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen)"/>. It is better to use in automation scripts, with windows of any process/thread. It throws exceptions, supports optional/reverse/fractional/workarea coordinates, restores if min/max.
            This function is low-level, it just calls API <msdn>SetWindowPos</msdn> with flags NOMOVE|NOZORDER|NOOWNERZORDER|NOACTIVATE. It is better to use in programming, with windows of current thread.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
            <seealso cref="M:Au.AWnd.SetWindowPos(Au.Types.Native.SWP,System.Int32,System.Int32,System.Int32,System.Int32,Au.AWnd)"/>
        </member>
        <member name="M:Au.AWnd.Move(Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen)">
            <summary>
            Moves and/or resizes.
            </summary>
            <param name="x">Left. If default(Coord), does not move in X axis.</param>
            <param name="y">Top. If default(Coord), does not move in Y axis.</param>
            <param name="width">Width. If default(Coord), does not change width.</param>
            <param name="height">Height. If default(Coord), does not change height.</param>
            <param name="workArea"><i>x y width height</i> are relative to the work area. Not used when this is a child window.</param>
            <param name="screen"><i>x y width height</i> are relative to this screen or its work area. Default - primary. Not used when this is a child window.</param>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            For top-level windows use screen coordinates. For controls - direct parent client area coordinates.
            With windows of current thread usually it's better to use <see cref="M:Au.AWnd.MoveLL(System.Int32,System.Int32,System.Int32,System.Int32,Au.Types.Native.SWP)"/>.
            </remarks>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.AWnd.Move(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen)">
            <summary>
            Moves.
            </summary>
            <param name="x">Left. If default(Coord), does not move in X axis.</param>
            <param name="y">Top. If default(Coord), does not move in Y axis.</param>
            <param name="workArea"><i>x y</i> are relative to the work area. Not used when this is a child window.</param>
            <param name="screen"><i>x y</i> are relative to this screen or its work area. Default - primary. Not used when this is a child window.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            For top-level windows use screen coordinates. For controls - direct parent client coordinates.
            With windows of current thread usually it's better to use <see cref="M:Au.AWnd.MoveLL(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.Resize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen)">
            <summary>
            Resizes.
            </summary>
            <param name="width">Width. If default(Coord), does not change width.</param>
            <param name="height">Height. If default(Coord), does not change height.</param>
            <param name="workArea">For <see cref="M:Au.Types.Coord.Fraction(System.Double)"/> etc use width/height of the work area. Not used when this is a child window.</param>
            <param name="screen">For <b>Coord.Fraction</b> etc use width/height of this screen. Default - primary. Not used when this is a child window.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            Also restores the visible top-level window if it is minimized or maximized.
            With windows of current thread usually it's better to use <see cref="M:Au.AWnd.ResizeLL(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.AScreen,System.Boolean,System.Boolean)">
            <summary>
            Moves this window to coordinates x y in specified screen, and ensures that entire window is in screen.
            </summary>
            <param name="x">X coordinate in the specified screen. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y coordinate in the specified screen. If default(Coord) - screen center. You also can use <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="screen">Move to this screen (see <see cref="T:Au.AScreen"/>). If default, uses screen of this window.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <param name="ensureInScreen">If part of window is not in screen, move and/or resize it so that entire window would be in screen. Default true.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            If the window is maximized, minimized or hidden, it will have the new position and size when restored, not immediately, except when moving maximized to another screen.
            </remarks>
            <seealso cref="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.AScreen,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AWnd.EnsureInScreen(Au.AScreen,System.Boolean)">
            <summary>
            Moves this window if need, to ensure that entire window is in screen.
            </summary>
            <param name="screen">Move to this screen (see <see cref="T:Au.AScreen"/>). If default, uses screen of this window.</param>
            <param name="workArea">Use the work area, not whole screen. Default true.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>
            If the window is maximized, minimized or hidden, it will have the new position and size when restored, not immediately.
            </remarks>
            <seealso cref="M:Au.Types.RECT.EnsureInScreen(Au.AScreen,System.Boolean)"/>
        </member>
        <member name="M:Au.AWnd.MoveToScreenCenter(Au.AScreen)">
            <summary>
            Moves this window to the center of the screen.
            </summary>
            <param name="screen">Move to this screen (see <see cref="T:Au.AScreen"/>). If default, uses screen of this window.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <remarks>Calls <c>ShowNotMinMax(true)</c> and <c>MoveInScreen(default, default, screen, true)</c>.</remarks>
            <seealso cref="M:Au.Types.RECT.MoveInScreen(Au.Types.Coord,Au.Types.Coord,Au.AScreen,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.AWnd.Screen">
            <summary>
            Gets <see cref="T:System.Windows.Forms.Screen"/> object of the screen that contains this window (the biggest part of it) or is nearest to it.
            If this window handle is default(AWnd) or invalid, gets the primary screen.
            Calls <see cref="M:Au.AScreen.ScreenFromWindow(Au.AWnd)"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.ZorderAbove(Au.AWnd)">
            <summary>
            Places this window before window w in the Z order.
            Also can make this window topmost or non-topmost, depending on where w is in the Z order.
            This window and w can be both top-level windows or both controls of same parent.
            May not work with top-level windows when it would move an inactive window above the active window.
            If w is default(AWnd), calls <see cref="M:Au.AWnd.ZorderBottom"/>.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.ZorderBelow(Au.AWnd)">
            <summary>
            Places this window after window w in the Z order.
            Also can make this window topmost or non-topmost, depending on where w is in the Z order.
            This window and w can be both top-level windows or both controls of same parent.
            May not work with top-level windows when it would move an inactive window above the active window.
            If w is default(AWnd), calls <see cref="M:Au.AWnd.ZorderTop"/>.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.ZorderTop">
            <summary>
            Places this window or control at the top of the Z order.
            If the window was topmost, it will be at the top of topmost windows, else at the top of non-topmost windows (after topmost windows).
            Does not activate.
            In most cases does not work with top-level inactive windows, although returns true; instead use <see cref="M:Au.AWnd.ActivateLL"/>.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.ZorderBottom">
            <summary>
            Places this window or control at the bottom of the Z order.
            If the window was topmost, makes it and its owner window non-topmost.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.ZorderTopmost">
            <summary>
            Makes this window topmost (always on top of non-topmost windows in the Z order).
            Does not activate.
            If this window has an owner window, the owner does not become topmost.
            This cannot be a control.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.ZorderNoTopmost(System.Boolean)">
            <summary>
            Makes this window non-topmost.
            If this window has an owner window, makes the owner window non-topmost too.
            This cannot be a control.
            </summary>
            <param name="afterActiveWindow">Also place this window after the active nontopmost window in the Z order, unless the active window is its owner.</param>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.IsTopmost">
            <summary>
            Returns true if this is a topmost (always-on-top) window.
            </summary>
        </member>
        <member name="M:Au.AWnd.ZorderIsBefore(Au.AWnd)">
            <summary>
            Returns true if this window is above window w in the Z order.
            </summary>
        </member>
        <member name="P:Au.AWnd.Style">
            <summary>
            Gets window style.
            </summary>
            <value>One or more <see cref="T:Au.Types.WS"/> flags and/or class-specific style flags. Reference: <msdn>window styles</msdn>.</value>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
            <seealso cref="M:Au.AWnd.HasStyle(Au.Types.WS,System.Boolean)"/>
            <seealso cref="M:Au.AWnd.SetStyle(Au.Types.WS,Au.Types.SetAddRemove,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.AWnd.ExStyle">
            <summary>
            Gets window extended style.
            </summary>
            <value>One or more <see cref="T:Au.Types.WS_EX"/> flags. Reference: <msdn>extended window styles</msdn>.</value>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
            <seealso cref="M:Au.AWnd.HasExStyle(Au.Types.WS_EX,System.Boolean)"/>
            <seealso cref="M:Au.AWnd.SetExStyle(Au.Types.WS_EX,Au.Types.SetAddRemove,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AWnd.HasStyle(Au.Types.WS,System.Boolean)">
            <summary>
            Returns true if the window has all specified style flags (see <see cref="P:Au.AWnd.Style"/>).
            </summary>
            <param name="style">One or more styles.</param>
            <param name="any">
            Return true if has any (not necessary all) of the specified styles.
            Note: don't use <see cref="F:Au.Types.WS.CAPTION"/>, because it consists of two other styles - BORDER and DLGFRAME.
            </param>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.HasExStyle(Au.Types.WS_EX,System.Boolean)">
            <summary>
            Returns true if the window has all specified extended style flags (see <see cref="P:Au.AWnd.ExStyle"/>).
            </summary>
            <param name="exStyle">One or more extended styles.</param>
            <param name="any">Return true if has any (not necessary all) of the specified styles.</param>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.SetStyle(Au.Types.WS,Au.Types.SetAddRemove,System.Boolean,System.Boolean)">
            <summary>
            Changes window style.
            </summary>
            <param name="style">One or more <see cref="T:Au.Types.WS"/> flags and/or class-specific style flags. Reference: <msdn>window styles</msdn>.</param>
            <param name="how"></param>
            <param name="updateNC">Update non-client area (frame, title bar).</param>
            <param name="updateClient">Update client area.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <seealso cref="P:Au.AWnd.Style"/>
        </member>
        <member name="M:Au.AWnd.SetExStyle(Au.Types.WS_EX,Au.Types.SetAddRemove,System.Boolean,System.Boolean)">
            <summary>
            Changes window extended style.
            </summary>
            <param name="style">One or more <see cref="T:Au.Types.WS_EX"/> flags. Reference: <msdn>extended window styles</msdn>.</param>
            <param name="how"></param>
            <param name="updateNC">Update non-client area (frame, title bar).</param>
            <param name="updateClient">Update client area.</param>
            <exception cref="T:Au.Types.AuWndException"/>
            <seealso cref="P:Au.AWnd.ExStyle"/>
        </member>
        <member name="P:Au.AWnd.IsPopupWindow">
            <summary>
            Returns true if has WS.POPUP style.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.IsToolWindow">
            <summary>
            Returns true if has WS_EX.TOOLWINDOW style.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.IsResizable">
            <summary>
            Returns true if has WS.THICKFRAME style.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.GetWindowLong(System.Int32)">
            <summary>
            Calls API <msdn>GetWindowLongPtr</msdn>.
            </summary>
            <remarks>
            For index can be used constants from <see cref="T:Au.Types.Native.GWL"/>.
            Supports <see cref="T:Au.ALastError"/>.
            In 32-bit process actually calls <b>GetWindowLong</b>, because <b>GetWindowLongPtr</b> is unavailable.
            </remarks>
        </member>
        <member name="M:Au.AWnd.SetWindowLong(System.Int32,Au.Types.LPARAM)">
            <summary>
            Calls API <msdn>SetWindowLongPtr</msdn>.
            </summary>
            <remarks>
            For index can be used constants from <see cref="T:Au.Types.Native.GWL"/>.
            In 32-bit process actually calls <b>SetWindowLong</b>, because <b>SetWindowLongPtr</b> is unavailable.
            </remarks>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="P:Au.AWnd.ControlId">
            <summary>
            Gets or sets id of this control.
            The 'get' function supports <see cref="T:Au.ALastError"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException">Failed (only 'set' function).</exception>
        </member>
        <member name="P:Au.AWnd.Prop">
            <summary>
            Returns an object that manages window properties using API <msdn>SetProp</msdn> and co.
            </summary>
            <example>
            <code><![CDATA[
            var w = AWnd.Find("* Explorer");
            w.Prop.Set("example", 5);
            Print(w.Prop["example"]);
            Print(w.Prop); //shows all w properties
            w.Prop.Remove("example"); //you should always remove window properties if don't want to see unrelated applications crashing after some time. And don't use many unique property names.
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.GetThreadProcessId(System.Int32@)">
            <summary>
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns thread id and also gets process id.
            Returns 0 if fails. Supports <see cref="T:Au.ALastError"/>.
            <note>It is native thread id, not Thread.ManagedThreadId.</note>
            </summary>
        </member>
        <member name="P:Au.AWnd.ThreadId">
            <summary>
            Gets native thread id of this window. Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns 0 if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <remarks>
            It is not the same as <see cref="P:System.Threading.Thread.ManagedThreadId"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.ProcessId">
            <summary>
            Gets native process id of this window. Calls API <msdn>GetWindowThreadProcessId</msdn>.
            Returns 0 if fails. Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="P:Au.AWnd.IsOfThisThread">
            <summary>
            Returns true if this window belongs to the current thread, false if to another thread.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.AWnd.IsOfThisProcess">
            <summary>
            Returns true if this window belongs to the current process, false if to another process.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            Calls API <msdn>GetWindowThreadProcessId</msdn>.
            </summary>
        </member>
        <member name="P:Au.AWnd.IsUnicode">
            <summary>
            Returns true if the window is a Unicode window, false if ANSI.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            Calls API <msdn>IsWindowUnicode</msdn>.
            </summary>
        </member>
        <member name="P:Au.AWnd.Is64Bit">
            <summary>
            Returns true if the window is of a 64-bit process, false if of a 32-bit process.
            Also returns false if fails. Supports <see cref="T:Au.ALastError"/>.
            If <see cref="P:Au.AVersion.Is64BitOS"/> is true, calls API <msdn>GetWindowThreadProcessId</msdn>, <msdn>OpenProcess</msdn> and <msdn>IsWow64Process</msdn>.
            <note>If you know that the window belongs to current process, instead use <see cref="P:System.Environment.Is64BitProcess"/> or <c>IntPtr.Size==8</c>. This function is much slower.</note>
            </summary>
        </member>
        <member name="P:Au.AWnd.IsHung">
            <summary>
            Returns true if thread of this window is considered hung (not responding).
            Calls API <msdn>IsHungAppWindow</msdn>.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.IsHungGhost">
            <summary>
            Returns true if the window is a ghost window that the system creates over a hung (not responding) window to allow the user to minimally interact with it.
            </summary>
        </member>
        <member name="P:Au.AWnd.IsConsole">
            <summary>
            Returns true if this is a console window (class name "ConsoleWindowClass").
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.IsUacAccessDenied">
            <summary>
            Returns true if [](xref:uac) would not allow to automate the window.
            It happens when current process has lower UAC integrity level and is not uiAccess, unless UAC is turned off.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.ClassName">
            <summary>
            Gets window class name.
            Returns null if fails, eg if the window is closed. Supports <see cref="T:Au.ALastError"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.ClassNameIs(System.String)">
            <summary>
            Returns true if the class name of this window matches cn. Else returns false.
            Also returns false when fails (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="cn">Class name. Case-insensitive wildcard. See <see cref="M:Au.AExtString.Like(System.String,System.String,System.Boolean)"/>. Cannot be null.</param>
        </member>
        <member name="M:Au.AWnd.ClassNameIs(System.String[])">
            <summary>
            If the class name of this window matches one of strings in <i>classNames</i>, returns 1-based index of the string. Else returns 0.
            Also returns 0 if fails to get class name (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="classNames">Class names. Case-insensitive wildcard. See <see cref="M:Au.AExtString.Like(System.String,System.String,System.Boolean)"/>. The array and strings cannot be null.</param>
        </member>
        <member name="P:Au.AWnd.Name">
            <summary>
            Gets name.
            Returns "" if no name. Returns null if fails, eg if the window is closed. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <remarks>
            <note>It is not the .NET Control.Name property. To get it you can use <see cref="P:Au.AWnd.NameWinForms"/>.</note>
            Top-level window name usually its title bar text.
            Control name usually is its text that does not change, for example button or static (label) control text.
            Unlike <see cref="P:Au.AWnd.ControlText"/>, this function usually does not get variable text, for example Edit control editable text, ComboBox control selected item text, status bar text.
            Calls <see cref="M:Au.AWnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>(false, true).
            </remarks>
            <seealso cref="M:Au.AWnd.SetText(System.String)"/>
            <seealso cref="P:Au.AWnd.ControlText"/>
            <seealso cref="P:Au.AWnd.NameAcc"/>
            <seealso cref="P:Au.AWnd.NameWinForms"/>
        </member>
        <member name="P:Au.AWnd.LibNameTL">
            <summary>
            Gets window name using API InternalGetWindowText. The same as GetText(false, false).
            This should be a top-level window, because does not process ampersands.
            </summary>
        </member>
        <member name="P:Au.AWnd.ControlText">
            <summary>
            Gets control text.
            Returns "" if no text. Returns null if fails, eg if the window is closed. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <remarks>
            Unlike <see cref="P:Au.AWnd.Name"/>, this function prefers variable text, for example Edit control editable text, ComboBox control selected item text, status bar text.
            For controls that cannot have such text (eg button, static), it usually gets the same text as <b>Name</b>. For example button and static (label) controls.
            Much slower than <b>Name</b>. Fails if the window is hung.
            Calls <see cref="M:Au.AWnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>(true, false).
            </remarks>
            <seealso cref="M:Au.AWnd.SetText(System.String)"/>
            <seealso cref="P:Au.AWnd.Name"/>
        </member>
        <member name="M:Au.AWnd.GetText(System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets window/control name or control text.
            Returns "" if it is empty.
            Returns null if fails, eg if the window is closed. Supports <see cref="T:Au.ALastError"/>.
            This is a low-level function. You can instead use <see cref="P:Au.AWnd.Name"/> and <see cref="P:Au.AWnd.ControlText"/>.
            </summary>
            <param name="getText">
            false - use API function <msdn>InternalGetWindowText</msdn>. It is fast and usually does not get variable text. This is used by <see cref="P:Au.AWnd.Name"/>.
            true - use API message <msdn>WM_GETTEXT</msdn>. It is slow and prefers variable text. This is used by <see cref="P:Au.AWnd.ControlText"/>. Fails if the window is hung.
            null - try InternalGetWindowText. If it gets "", and this is a control, then try WM_GETTEXT.
            </param>
            <param name="removeUnderlineAmpersand">
            Remove the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            Removes only if this is a control (has style WS.CHILD).
            Calls <see cref="M:Au.Util.AStringUtil.RemoveUnderlineAmpersand(System.String)"/>.
            </param>
            <seealso cref="M:Au.AWnd.SetText(System.String)"/>
            <seealso cref="P:Au.AWnd.NameAcc"/>
            <seealso cref="P:Au.AWnd.NameWinForms"/>
        </member>
        <member name="M:Au.AWnd._GetTextFast(System.Boolean)">
            <summary>
            Gets text.
            Returns "" if it is empty.
            Returns null if fails, eg if the control is destroyed or its thread is hung. Supports <see cref="T:Au.ALastError"/>.
            Calls API InternalGetWindowText. If it fails, and getControlTextIfEmpty==true, and this is a control, calls _GetTextSlow, which uses WM_GETTEXT.
            </summary>
        </member>
        <member name="M:Au.AWnd._GetTextSlow">
            <summary>
            Gets text.
            Returns "" if it is empty.
            Returns null if fails, eg if the control is destroyed or its thread is hung. Supports <see cref="T:Au.ALastError"/>.
            Uses WM_GETTEXT.
            </summary>
        </member>
        <member name="M:Au.AWnd.SetText(System.String)">
            <summary>
            Sets window/control name or control text.
            </summary>
            <param name="text">Text. Can be null, it is the same as "".</param>
            <remarks>
            Uses API <msdn>WM_SETTEXT</msdn>.
            Top-level window name usually its title bar text.
            For variable-text controls (edit, combo box, status bar, ...) this usually is the text that <see cref="P:Au.AWnd.ControlText"/> would get.
            For other controls (button, static, ...) and top-level windows this usually is the text that <see cref="P:Au.AWnd.Name"/> would get.
            </remarks>
            <exception cref="T:Au.Types.AuWndException">Failed, for example the window is closed.</exception>
            <seealso cref="M:Au.AWnd.GetText(System.Nullable{System.Boolean},System.Boolean)"/>
            <seealso cref="P:Au.AWnd.Name"/>
            <seealso cref="P:Au.AWnd.ControlText"/>
        </member>
        <member name="P:Au.AWnd.NameAcc">
            <summary>
            Gets <see cref="P:Au.AAcc.Name"/> of the accessible object (role WINDOW) of this window or control.
            Returns "" if the object has no name or failed to get it. Returns null if invalid window handle.
            </summary>
        </member>
        <member name="P:Au.AWnd.NameWinForms">
            <summary>
            Gets Control.Name property of a .NET Windows Forms control.
            Returns null if it is not a Windows Forms control or if fails.
            </summary>
            <remarks>
            <note>Use this with controls of other processes. Don't use with your controls, when you have a Control object.</note>
            
            <note>Slow when getting names of multiple controls in a window. Instead create a <see cref="T:Au.Util.AWinFormsControlNames"/> instance and call its <see cref="M:Au.Util.AWinFormsControlNames.GetControlName(Au.AWnd)"/> method for each control.</note>
            </remarks>
            <seealso cref="M:Au.Util.AWinFormsControlNames.IsWinFormsControl(Au.AWnd)"/>
        </member>
        <member name="P:Au.AWnd.ProgramName">
            <summary>
            Gets filename of process executable file, like "notepad.exe".
            Return null if fails.
            </summary>
            <remarks>
            Calls <see cref="P:Au.AWnd.ProcessId"/> and <see cref="M:Au.AProcess.GetName(System.Int32,System.Boolean,System.Boolean)"/>.
            This function is much slower than getting window name or class name. Don't use code like <c>if(w.ProgramName=="A" || w.ProgramName=="B")</c>. Instead use <c>var s=w.ProgramName; if(s=="A" || s=="B")</c>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.ProgramNameIs(System.String[])">
            <summary>
            If the program name of this window matches one of strings in <i>programNames</i>, returns 1-based index of the string. Else returns 0.
            Also returns 0 if fails to get program name (probably window closed or 0 handle). Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="programNames">Program names, like "notepad.exe". Case-insensitive wildcard. See <see cref="M:Au.AExtString.Like(System.String,System.String,System.Boolean)"/>. The array and strings cannot be null.</param>
        </member>
        <member name="P:Au.AWnd.ProgramPath">
            <summary>
            Gets full path of process executable file.
            Return null if fails.
            </summary>
            <remarks>
            Calls <see cref="P:Au.AWnd.ProcessId"/> and <see cref="M:Au.AProcess.GetName(System.Int32,System.Boolean,System.Boolean)"/>.
            This function is much slower than getting window name or class name. Don't use code like <c>if(w.ProgramPath=="A" || w.ProgramPath=="B")</c>. Instead use <c>var s=w.ProgramPath; if(s=="A" || s=="B")</c>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.ProgramDescription">
            <summary>
            Gets description of process executable file.
            Return null if fails.
            </summary>
            <remarks>
            Calls <see cref="P:Au.AWnd.ProcessId"/> and <see cref="M:Au.AProcess.GetDescription(System.Int32)"/>.
            This function is slow. Much slower than <see cref="P:Au.AWnd.ProgramName"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.Close(System.Boolean,System.Boolean)">
            <summary>
            Closes the window.
            Returns true if successfuly closed or if it was already closed (the handle is 0 or invalid) or if <i>noWait</i>==true.
            </summary>
            <param name="noWait">
            If true, does not wait until the window is closed.
            If false, waits about 1 s (depends on window type etc) until the window is destroyed or disabled.
            </param>
            <param name="useXButton">
            If false (default), uses API message <msdn>WM_CLOSE</msdn>.
            If true, uses API message <msdn>WM_SYSCOMMAND SC_CLOSE</msdn>, like when the user clicks the X button in the title bar.
            Most windows can be closed with any of these messages, but some respond properly only to one of them. For example, some applications on WM_CLOSE don't exit, although the main window is closed. Some applications don't respond to WM_SYSCOMMAND if it is posted soon after opening the window, for example Internet Explorer.
            </param>
            <remarks>
            The window may refuse to be closed. For example, it may be hung, or hide itself instead, or display a "Save?" message box, or is a dialog without X button, or just need more time to close it.
            If the window is of this thread, just calls <see cref="M:Au.AWnd.Send(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)"/> or <see cref="M:Au.AWnd.Post(System.Int32,Au.Types.LPARAM,Au.Types.LPARAM)"/> (if <i>noWait</i>==true) and returns true.
            </remarks>
            <seealso cref="M:Au.AWnd.WaitForClosed(System.Double,System.Boolean)"/>
            <example>
            <code><![CDATA[
            //close all Notepad windows
            AWnd.FindAll("* Notepad", "Notepad").ForEach(t => t.Close());
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AWnd.ChildFinder">
            <summary>
            Contains control (child window) properties and is used to find the control.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/> or <see cref="M:Au.AWnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean})"/>.
            Also can be used to find window that contains certain control, like in the example.
            </remarks>
            <example>
            Find window that contains certain control, and get the control too.
            <code><![CDATA[
            var f = new AWnd.ChildFinder("Password*", "Static"); //control properties
            AWnd w = AWnd.Find(cn: "#32770", also: t => f.Find(t));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.ChildFinder.#ctor(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)">
            <summary>
            See <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.</exception>
        </member>
        <member name="P:Au.AWnd.ChildFinder.Result">
            <summary>
            The found control.
            </summary>
        </member>
        <member name="M:Au.AWnd.ChildFinder.Find(Au.AWnd)">
            <summary>
            Finds the specified child control, like <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.
            Returns true if found.
            The <see cref="P:Au.AWnd.ChildFinder.Result"/> property will be the control.
            </summary>
            <param name="wParent">Direct or indirect parent window. Can be top-level window or control.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid wParent.</exception>
        </member>
        <member name="M:Au.AWnd.ChildFinder.FindInList(System.Collections.Generic.IEnumerable{Au.AWnd},Au.AWnd)">
            <summary>
            Finds the specified control in a list of controls.
            Returns 0-based index, or -1 if not found.
            The <see cref="P:Au.AWnd.ChildFinder.Result"/> property will be the control.
            </summary>
            <param name="a">List of controls, for example returned by <see cref="M:Au.AWnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>.</param>
            <param name="wParent">Direct or indirect parent window. Used only for flag DirectChild.</param>
        </member>
        <member name="M:Au.AWnd.ChildFinder.FindAll(Au.AWnd)">
            <summary>
            Finds all matching child controls, like <see cref="M:Au.AWnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean})"/>.
            Returns array containing 0 or more control handles as AWnd.
            </summary>
            <param name="wParent">Direct or indirect parent window. Can be top-level window or control.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid wParent.</exception>
        </member>
        <member name="M:Au.AWnd.ChildFinder.FindAllInList(System.Collections.Generic.IEnumerable{Au.AWnd},Au.AWnd)">
            <summary>
            Finds all matching controls in a list of controls.
            Returns array containing 0 or more control handles as AWnd.
            </summary>
            <param name="a">List of controls, for example returned by <see cref="M:Au.AWnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>.</param>
            <param name="wParent">Direct or indirect parent window. Used only for flag DirectChild.</param>
        </member>
        <member name="M:Au.AWnd.ChildFinder._FindInList(Au.AWnd,Au.AWnd._WndList,System.Action{Au.AWnd})">
            <summary>
            Returns index of matching element or -1.
            Returns -1 if using getAll.
            </summary>
            <param name="wParent">Parent window. Can be default(AWnd) if inList is true and no DirectChild flag and not using winforms name.</param>
            <param name="a">List of AWnd. Does not dispose it.</param>
            <param name="getAll">If not null, calls it for all matching and returns -1.</param>
        </member>
        <member name="M:Au.AWnd.ChildFinder.IsMatch(Au.AWnd,Au.AWnd)">
            <summary>
            Returns true if control c properties match the specified properties.
            </summary>
            <param name="c">A control. Can be 0/invalid, then returns false.</param>
            <param name="wParent">Direct or indirect parent window. If used, returns false if it isn't parent (also depends on flag DirectChild).</param>
        </member>
        <member name="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)">
            <summary>
            Finds a child control and returns its handle as AWnd.
            Returns default(AWnd) if not found. See also: <see cref="P:Au.AWnd.Is0"/>, <see cref="M:Au.AExtAu.OrThrow(Au.AWnd)"/>.
            </summary>
            <param name="name">
            Control name.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. "" means 'no name'.
            
            By default to get control names this function uses <see cref="P:Au.AWnd.Name"/>.
            Can start with these prefix strings:
            - <c>"***text "</c> - use <see cref="P:Au.AWnd.ControlText"/>.
            <br/>Slower and can be less reliable (because can get editable text), especially if not used cn (class name). Does not remove the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            - <c>"***accName "</c> - use <see cref="P:Au.AWnd.NameAcc"/>.
            <br/>Useful when the control itself does not have a name but an adjacent Static text control is used as its name. Examples - Edit controls in dialogs. Slower.
            - <c>"***wfName "</c> - use .NET Windows Forms Control Name property.
            <br/>To get it this function uses <see cref="T:Au.Util.AWinFormsControlNames"/>. Slower and can fail because of [](xref:uac).
            - <c>"***id "</c> like <c>"***id 15"</c> - use control id.
            <br/>To get it this function uses <see cref="P:Au.AWnd.ControlId"/>.
            <br/>The id value cannot be wildcard expression.
            <br/>See also <see cref="M:Au.AWnd.ChildById(System.Int32,Au.Types.WCFlags)"/>.
            </param>
            <param name="cn">
            Control class name.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. Cannot be "".
            You can see control class name etc in editor's status bar and dialog "Find window or control".
            </param>
            <param name="flags"></param>
            <param name="also">
            Callback function. Called for each matching control.
            It can evaluate more properties of the control and return true when they match.
            Example: <c>also: t =&gt; t.IsEnabled</c>
            </param>
            <param name="skip">
            0-based index of matching control.
            For example, if 1, the function skips the first matching control and returns the second.
            </param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <exception cref="T:System.ArgumentException">
            - <i>name</i> starts with <c>"***"</c>, but the prefix is invalid.
            - <i>cn</i> is "". To match any, use null.
            - Invalid wildcard expression (<c>"**options "</c> or regular expression).
            </exception>
            <remarks>
            To create code for this function, use dialog "Find window or control". It is form <b>Au.Tools.FormAWnd</b> in Au.Tools.dll.
            </remarks>
        </member>
        <member name="M:Au.AWnd.HasChild(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)">
            <summary>
            Returns true if this window contains the specified control.
            Calls <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.
            <note>
            Using this function many times with same parameters is inefficient. Instead create new <see cref="T:Au.AWnd.ChildFinder"/> and call <see cref="M:Au.AWnd.ChildFinder.Find(Au.AWnd)"/> or <see cref="M:Au.AWnd.HasChild(Au.AWnd.ChildFinder)"/>. See example.
            </note>
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
            <exception cref="T:System.ArgumentException"/>
            <example>
            <code><![CDATA[
            //find window that contains certain control, and get the control too
            var f = new AWnd.ChildFinder("Password*", "Static"); //control properties
            AWnd w = AWnd.Find(cn: "#32770", also: t => t.HasChild(f));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.HasChild(Au.AWnd.ChildFinder)">
            <summary>
            Returns true if this window contains the specified control.
            Calls <see cref="M:Au.AWnd.ChildFinder.Find(Au.AWnd)"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
            <example>
            Find window that contains certain control, and get the control too.
            <code><![CDATA[
            var cf = new AWnd.ChildFinder("Password*", "Static"); //control properties
            AWnd w = AWnd.Find(cn: "#32770", also: t => t.HasChild(cf));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.HasAcc(Au.AAcc.Finder)">
            <summary>
            Returns true if this window contains the specified accessible object.
            Calls <see cref="M:Au.AAcc.Finder.Find(Au.AWnd,Au.AWnd.ChildFinder)"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
            <example>
            Find window that contains certain accessible object (AO), and get the AO too.
            <code><![CDATA[
            var af = new AAcc.Finder("BUTTON", "OK"); //AO properties
            AWnd w = AWnd.Find(cn: "#32770", also: t => t.HasAcc(af));
            Print(w);
            Print(f.Result);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.ChildById(System.Int32,Au.Types.WCFlags)">
            <summary>
            Finds a child control by its id and returns its handle as AWnd.
            Returns default(AWnd) if not found. See also: <see cref="P:Au.AWnd.Is0"/>, <see cref="M:Au.AExtAu.OrThrow(Au.AWnd)"/>.
            </summary>
            <param name="id">Control id.</param>
            <param name="flags">This function supports flags DirectChild and HiddenToo. If both are set, it is much faster because uses API <msdn>GetDlgItem</msdn>. Else uses API <msdn>EnumChildWindows</msdn>, like <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.</param>
            <remarks>
            To create code for this function, use dialog "Find window or control". It is form <b>Au.Tools.FormAWnd</b> in Au.Tools.dll.
            
            Not all controls have a useful id. If control id is not unique or is different in each window instance, this function is not useful.
            </remarks>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.AWnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean})">
            <summary>
            Finds all matching child controls.
            Returns List containing 0 or more control handles as AWnd.
            Everything except the return type is the same as with <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.
            </summary>
            <exception cref="T:Au.Types.AuWndException"/>
            <exception cref="T:System.ArgumentException"/>
            <remarks>
            In the returned list, hidden controls (when using WCFlags.HiddenToo) are always after visible controls.
            </remarks>
            <seealso cref="M:Au.AWnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AWnd.ChildFast(System.String,System.String,Au.AWnd)">
            <summary>
            Finds a direct child control and returns its handle as AWnd.
            Returns default(AWnd) if not found. See also: <see cref="P:Au.AWnd.Is0"/>, <see cref="M:Au.AExtAu.OrThrow(Au.AWnd)"/>.
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>, which uses API <msdn>EnumChildWindows</msdn>.
            Can be used only when you know full name and/or class name.
            Finds hidden controls too.
            </summary>
            <param name="name">
            Name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. "" means 'no name'.
            Must include the invisible '&amp;' characters that are used to underline keyboard shortcuts with the Alt key.
            </param>
            <param name="cn">
            Class name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. Cannot be "".
            </param>
            <param name="wAfter">If used, starts searching from the next control in the Z order.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="T:Au.AWnd.GetWnd">
            <summary>
            Static functions of this class are used to get special windows (used like <c>AWnd w = AWnd.GetWnd.Top;</c>) and all windows.
            Instances of this class are used to get related windows and controls, like <c>AWnd w2 = w1.Get.FirstChild;</c> (here w1 is an AWnd variable).
            </summary>
        </member>
        <member name="M:Au.AWnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets child controls, including all descendants.
            Returns array containing 0 or more control handles as AWnd.
            </summary>
            <param name="onlyVisible">Need only visible controls.</param>
            <param name="sortFirstVisible">Place all array elements of hidden controls at the end of the array.</param>
            <param name="directChild">Need only direct children, not all descendants.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            Calls API <msdn>EnumChildWindows</msdn>.
            </remarks>
            <seealso cref="M:Au.AWnd.ChildAll(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean})"/>
        </member>
        <member name="M:Au.AWnd.GetWnd.Children(System.Collections.Generic.List{Au.AWnd}@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets child controls, including all descendants.
            </summary>
            <param name="a">Receives window handles as AWnd. If null, this function creates new List, else clears before adding items.</param>
            <param name="onlyVisible">Need only visible controls.</param>
            <param name="sortFirstVisible">Place all array elements of hidden controls at the end of the array.</param>
            <param name="directChild">Need only direct children, not all descendants.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            Use this overload to avoid much garbage when calling frequently with the same List variable. Other overload always allocates new array. This overload in most cases reuses memory allocated for the list variable.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.AllWindows(System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows.
            Returns array containing window handles as <b>AWnd</b>.
            </summary>
            <param name="onlyVisible">
            Need only visible windows.
            Note: this function does not check whether windows are cloaked, as it is rather slow. Use <see cref="P:Au.AWnd.IsCloaked"/> if need.
            </param>
            <param name="sortFirstVisible">
            Place hidden windows at the end of the array. If false, the order of array elements matches the Z order.
            Not used when <i>onlyVisible</i> is true.</param>
            <remarks>
            Calls API <msdn>EnumWindows</msdn>.
            <note>The array can be bigger than you expect, because there are many invisible windows, tooltips, etc. See also <see cref="M:Au.AWnd.GetWnd.MainWindows(System.Boolean)"/>.</note>
            Does not get message-only windows. Use <see cref="M:Au.AWnd.More.FindMessageOnlyWindow(System.String,System.String,Au.AWnd)"/> if need.
            On Windows 8 and later does not get Windows Store app Metro-style windows (on Windows 10 few such windows exist), unless this process has [](xref:uac) integrity level uiAccess or High+uiAccess or its manifest contains disableWindowFiltering; to get such windows you can use <see cref="M:Au.AWnd.FindFast(System.String,System.String,Au.AWnd)"/>.
            Tip: To get top-level and child windows in single array: <c>var a = AWnd.GetWnd.Root.Get.Children();</c>.
            </remarks>
            <seealso cref="M:Au.AWnd.GetWnd.Children(System.Boolean,System.Boolean,System.Boolean)"/>
            <seealso cref="M:Au.AWnd.FindAll(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>
        </member>
        <member name="M:Au.AWnd.GetWnd.AllWindows(System.Collections.Generic.List{Au.AWnd}@,System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows.
            </summary>
            <param name="a">Receives window handles as <b>AWnd</b>. If null, this function creates new List, else clears before adding items.</param>
            <param name="onlyVisible"></param>
            <param name="sortFirstVisible"></param>
            <remarks>
            Use this overload to avoid much garbage when calling frequently with the same List variable. Other overload always allocates new array. This overload in most cases reuses memory allocated for the list variable.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.ThreadWindows(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows of a thread.
            Returns array containing 0 or more window handles as <b>AWnd</b>.
            </summary>
            <param name="threadId">
            Unmanaged thread id.
            See <see cref="P:Au.AThread.NativeId"/>, <see cref="P:Au.AWnd.ThreadId"/>.
            If 0, throws exception. If other invalid value (ended thread?), returns empty list. Supports <see cref="T:Au.ALastError"/>.
            </param>
            <param name="onlyVisible">Need only visible windows.</param>
            <param name="sortFirstVisible">Place all array elements of hidden windows at the end of the array, even if the hidden windows are before some visible windows in the Z order.</param>
            <exception cref="T:System.ArgumentException">0 threadId.</exception>
            <remarks>
            Calls API <msdn>EnumThreadWindows</msdn>.
            </remarks>
            <seealso cref="M:Au.AThread.HasMessageLoop(System.Boolean@)"/>
        </member>
        <member name="M:Au.AWnd.GetWnd.ThreadWindows(System.Collections.Generic.List{Au.AWnd}@,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Gets top-level windows of a thread.
            </summary>
            <remarks>This overload can be used to avoid much garbage when caling frequently.</remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.#ctor(Au.AWnd)">
            
        </member>
        <member name="M:Au.AWnd.GetWnd.Left(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a sibling control to the left from this.
            Returns default(AWnd) if there is no sibling.
            </summary>
            <param name="distance">Horizontal distance from the left of this control. Default 10.</param>
            <param name="yOffset">Vertical offset from the top of this control. If negative - up. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.Right(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a sibling control to the right from this.
            Returns default(AWnd) if there is no sibling.
            </summary>
            <param name="distance">Horizontal distance from the right of this control. Default 10.</param>
            <param name="yOffset">Vertical offset from the top of this control. If negative - up. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.Above(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a sibling control above this.
            Returns default(AWnd) if there is no sibling.
            </summary>
            <param name="distance">Vertical distance from the top of this control. Default 10.</param>
            <param name="xOffset">Horizontal offset from the left of this control. If negative - to the left. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.Below(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a sibling control below this.
            Returns default(AWnd) if there is no sibling.
            </summary>
            <param name="distance">Vertical distance from the bottom of this control. Default 10.</param>
            <param name="xOffset">Horizontal offset from the left of this control. If negative - to the left. Default 5.</param>
            <param name="topChild">If at that point is a visible child of the sibling, get that child. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.Next(System.Int32)">
            <summary>
            Gets next sibling window or control in the Z order.
            Returns default(AWnd) if this is the last or if fails.
            </summary>
            <param name="skip">How many next windows to skip.</param>
            <remarks>
            If this is a top-level window, gets next top-level window, else gets next control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(GW_HWNDNEXT).
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.Previous(System.Int32)">
            <summary>
            Gets previous sibling window or control in the Z order.
            Returns default(AWnd) if this is the first or if fails.
            </summary>
            <param name="skip">How many previous windows to skip.</param>
            <remarks>
            If this is a top-level window, gets previous top-level window, else gets previous control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(GW_HWNDPREV).
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.FirstSibling">
            <summary>
            Gets the first sibling window or control in the Z order.
            If this is the first, returns this.
            </summary>
            <remarks>
            If this is a top-level window, gets the first top-level window, else gets the first control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDFIRST).
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.LastSibling">
            <summary>
            Gets the last sibling window or control in the Z order.
            If this is the last, returns this, not default(AWnd).
            </summary>
            <remarks>
            If this is a top-level window, gets the last top-level window, else gets the last control of the same direct parent.
            Calls API <msdn>GetWindow</msdn>(this, GW_HWNDLAST).
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.FirstChild">
            <summary>
            Gets the first direct child control in the Z order.
            Returns default(AWnd) if no children or if fails.
            </summary>
            <remarks>
            Calls API <msdn>GetWindow</msdn>(GW_CHILD).
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.LastChild">
            <summary>
            Gets the last direct child control in the Z order.
            Returns default(AWnd) if no children or if fails.
            </summary>
            <remarks>
            Calls API <msdn>GetWindow</msdn>.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.Child(System.Int32)">
            <summary>
            Gets a direct child control by index.
            Returns default(AWnd) if no children or if index is invalid or if fails.
            </summary>
            <param name="index">0-based index of the child control in the Z order.</param>
            <remarks>
            Calls API <msdn>GetWindow</msdn>.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.Owner">
            <summary>
            Gets the owner window of this top-level window.
            Returns default(AWnd) if this window isn't owned or if fails.
            </summary>
            <remarks>
            A window that has an owner window is always on top of it.
            Controls don't have an owner window.
            Supports <see cref="T:Au.ALastError"/>.
            This function is the same as <see cref="P:Au.AWnd.Owner"/>, which also allows to change owner.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.Window">
            <summary>
            Gets the top-level parent window of this control.
            If this is a top-level window, returns this.
            Returns default(AWnd) if fails.
            </summary>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            This function is the same as <see cref="P:Au.AWnd.Window"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.DirectParent">
            <summary>
            Gets the direct parent window of this control. It can be the top-level window or another control.
            Returns default(AWnd) if this is a top-level window or if fails.
            </summary>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            Unlike API <msdn>GetParent</msdn>, this function never returns the owner window.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.EnabledOwned(System.Boolean)">
            <summary>
            Gets the first (in Z order) enabled window owned by this window.
            </summary>
            <param name="orThis">Return this window if there are no enabled owned windows. If false, then returns default(AWnd).</param>
            <remarks>
            Calls API <msdn>GetWindow</msdn>(GW_ENABLEDPOPUP).
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.LastActiveOwnedOrThis(System.Boolean)">
            <summary>
            Gets the most recently active window in the chain of windows owned by this window, or this window itself if there are no such windows.
            Returns default(AWnd) if fails.
            </summary>
            <param name="includeOwners">Can return an owner (or owner's owner and so on) of this window too.</param>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.RootOwnerOrThis(System.Boolean)">
            <summary>
            Gets the bottom-most owner window in the chain of owner windows of this window.
            If this window is not owned, returns this window.
            Returns default(AWnd) if fails.
            </summary>
            <param name="supportControls">If this is a child window, use its top-level parent window instead.</param>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.OwnersAndThis(System.Boolean)">
            <summary>
            Gets all owner windows of this window, including this window or its top-level parent.
            Returns array that starts with this window or its top-level parent (if control).
            </summary>
            <param name="onlyVisible">Skip invisible windows.</param>
            <remarks>
            This window can be top-level window or control. If control, its top-level parent window will be the first in the array.
            This function for example can be used to temporarily hide a tool window and its owners when capturing something from the screen.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.Top">
            <summary>
            Gets the very first top-level window in the Z order.
            </summary>
            <remarks>
            Probably it is a topmost window.
            Calls API <msdn>GetTopWindow</msdn>(default(AWnd)).
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.Root">
            <summary>
            Calls API <msdn>GetDesktopWindow</msdn>. It gets the virtual parent window of all top-level windows.
            </summary>
            <remarks>
            <note>It is not the desktop window (see <see cref="P:Au.AWnd.GetWnd.Desktop"/>) that displays icons and wallpaper.</note>
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.Shell">
            <summary>
            Calls API <msdn>GetShellWindow</msdn>. It gets a window of the shell process (usually process "explorer", class name "Progman").
            Returns default(AWnd) if there is no shell process, for example Explorer process killed/crashed and still not restarted, or if using a custom shell that does not register a shell window.
            </summary>
            <remarks>
            It can be the window that contains desktop icons (see <see cref="P:Au.AWnd.GetWnd.Desktop"/>) or other window of the same thread.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.Desktop">
            <summary>
            Gets the desktop window that displays desktop icons and wallpaper in its child control <see cref="P:Au.AWnd.GetWnd.DesktopControl"/>.
            </summary>
            <remarks>
            <note>It is not API <msdn>GetDesktopWindow</msdn> (<see cref="P:Au.AWnd.GetWnd.Root"/>)</note>
            <note>This function is not very reliable. May stop working on a new Windows version or don't work with a custom shell.</note>
            Returns default(AWnd) if there is no shell process, for example Explorer process killed/crashed and still not restarted, or if using a custom shell that does not register a shell window.
            </remarks>
        </member>
        <member name="P:Au.AWnd.GetWnd.DesktopControl">
            <summary>
            Gets the control of "SysListView32" class that contains desktop icons and wallpaper. It is a child of <see cref="P:Au.AWnd.GetWnd.Desktop"/>.
            </summary>
            <remarks>
            <note>This function is not very reliable. May stop working on a new Windows version or don't work with a custom shell.</note>
            Returns default(AWnd) if there is no shell process, for example Explorer process killed/crashed and still not restarted, or if using a custom shell that does not register a shell window.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.IsMainWindow(Au.AWnd,System.Boolean,System.Boolean)">
            <summary>
            Returns true if window w is considered a main window, ie probably is in the Windows taskbar.
            Returns false if it is invisible, cloaked, owned, toolwindow, menu, etc.
            </summary>
            <param name="w"></param>
            <param name="allDesktops">On Windows 10 include (return true for) windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has [](xref:uac) integrity level uiAccess).</param>
            <param name="skipMinimized">Return false if w is minimized.</param>
        </member>
        <member name="M:Au.AWnd.GetWnd.MainWindows(System.Boolean)">
            <summary>
            Gets main windows, ie those that probably are in the Windows taskbar.
            Returns array containing 0 or more AWnd.
            </summary>
            <param name="allDesktops">On Windows 10 include windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has [](xref:uac) integrity level uiAccess).</param>
            <remarks>
            Uses <see cref="M:Au.AWnd.GetWnd.IsMainWindow(Au.AWnd,System.Boolean,System.Boolean)"/>.
            Does not match the order of buttons in the Windows taskbar.
            </remarks>
        </member>
        <member name="M:Au.AWnd.GetWnd.NextMain(Au.AWnd,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets next window in the Z order, skipping invisible and other windows that probably are not in the Windows taskbar.
            Returns default(AWnd) if there are no such windows.
            </summary>
            <param name="w">Start from this window. If default(AWnd), starts from the top of the Z order.</param>
            <param name="allDesktops">On Windows 10 include windows on all virtual desktops. On Windows 8 include Windows Store apps (only if this process has [](xref:uac) integrity level uiAccess).</param>
            <param name="skipMinimized">Skip minimized windows.</param>
            <param name="retryFromTop">If w is not default(AWnd) and there are no matching windows after it, retry from the top of the Z order. Then can return w.</param>
            <remarks>
            Uses <see cref="M:Au.AWnd.GetWnd.IsMainWindow(Au.AWnd,System.Boolean,System.Boolean)"/>.
            This function is quite slow. Does not match the order of buttons in the Windows taskbar.
            </remarks>
        </member>
        <member name="T:Au.AWnd.WButton">
            <summary>
            Like <see cref="T:Au.AWnd"/>, but has only button, check box and radio button functions - Click, Check etc.
            </summary>
        </member>
        <member name="P:Au.AWnd.WButton.W">
            <summary>
            Button handle as AWnd.
            </summary>
        </member>
        <member name="M:Au.AWnd.WButton.op_Implicit(Au.AWnd.WButton)~Au.AWnd">
            <summary>
            Implicit cast AWnd=WButton.
            </summary>
        </member>
        <member name="M:Au.AWnd.WButton.op_Explicit(Au.AWnd)~Au.AWnd.WButton">
            <summary>
            Explicit cast WButton=(WButton)AWnd.
            </summary>
        </member>
        <member name="M:Au.AWnd.WButton.ToString">
            
        </member>
        <member name="M:Au.AWnd.WButton.Click(System.Boolean)">
            <summary>
            Sends a "click" message to this button control. Does not use the mouse.
            </summary>
            <param name="useAcc">Use <see cref="M:Au.AAcc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.AuWndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Works not with all button controls. Sometimes does not work if the window is inactive.
            Check boxes and radio buttons also are buttons. This function can click them.
            </remarks>
            <example>
            <code><![CDATA[
            AWnd.Find("Options").Child("Cancel").AsButton.Click();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.WButton.Check(System.Boolean,System.Boolean)">
            <summary>
            Checks or unchecks this check box. Does not use the mouse.
            Calls <see cref="M:Au.AWnd.WButton.SetCheckState(System.Int32,System.Boolean)"/> with state 0 or 1.
            </summary>
            <param name="on">Checks if true, unchecks if false.</param>
            <param name="useAcc"></param>
            <exception cref="T:Au.Types.AuWndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Works not with all button controls. Sometimes does not work if the window is inactive.
            If this is a radio button, does not uncheck other radio buttons in its group.
            </remarks>
        </member>
        <member name="M:Au.AWnd.WButton.SetCheckState(System.Int32,System.Boolean)">
            <summary>
            Sets checkbox state. Does not use the mouse.
            </summary>
            <param name="state">0 unchecked, 1 checked, 2 indeterminate.</param>
            <param name="useAcc">Use <see cref="M:Au.AAcc.DoAction"/>. If false (default), posts <msdn>BM_SETCHECK</msdn> message and also BN_CLICKED notification to the parent window; if that is not possible, instead uses <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid state.</exception>
            <exception cref="T:Au.Types.AuWndException">This window is invalid.</exception>
            <exception cref="T:Au.Types.AuException">Failed.</exception>
            <remarks>
            Does nothing if the check box already has the specified check state (if can get it).
            Works not with all button controls. Sometimes does not work if the window is inactive.
            If this is a radio button, does not uncheck other radio buttons in its group.
            </remarks>
        </member>
        <member name="M:Au.AWnd.WButton.IsChecked(System.Boolean)">
            <summary>
            Gets check state of this check box or radio button.
            Calls <see cref="M:Au.AWnd.WButton.GetCheckState(System.Boolean)"/> and returns true if it returns 1.
            </summary>
        </member>
        <member name="M:Au.AWnd.WButton.GetCheckState(System.Boolean)">
            <summary>
            Gets check state of this check box or radio button.
            Returns 0 if unchecked, 1 if checked, 2 if indeterminate. Also returns 0 if this is not a button or if failed to get state.
            </summary>
            <param name="useAcc">Use <see cref="P:Au.AAcc.State"/>. If false (default) and this button has a standard checkbox style, uses API <msdn>BM_GETCHECK</msdn>.</param>
        </member>
        <member name="P:Au.AWnd.AsButton">
            <summary>
            Casts this to <see cref="T:Au.AWnd.WButton"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.ButtonClick(System.Int32,System.Boolean)">
            <summary>
            Finds a child button by id and sends a "click" message. Does not use the mouse.
            Calls <see cref="M:Au.AWnd.WButton.Click(System.Boolean)"/>.
            </summary>
            <param name="buttonId">Control id of the button. This function calls <see cref="M:Au.AWnd.ChildById(System.Int32,Au.Types.WCFlags)"/> to find the button.</param>
            <param name="useAcc">Use <see cref="M:Au.AAcc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.NotFoundException">Button not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWnd.ChildById(System.Int32,Au.Types.WCFlags)"/> and <see cref="M:Au.AWnd.WButton.Click(System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            AWnd.Find("Options").ButtonClick(2);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.ButtonClick(System.String,System.String,System.Boolean)">
            <summary>
            Finds a child button by name and sends a "click" message. Does not use the mouse.
            Calls <see cref="M:Au.AWnd.WButton.Click(System.Boolean)"/>.
            </summary>
            <param name="buttonName">Button name. This function calls <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/> to find the button.</param>
            <param name="cn">Button class name to pass to <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.</param>
            <param name="useAcc">Use <see cref="M:Au.AAcc.DoAction"/>. If false (default), posts <msdn>BM_CLICK</msdn> message.</param>
            <exception cref="T:Au.Types.NotFoundException">Button not found.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/> and <see cref="M:Au.AWnd.WButton.Click(System.Boolean)"/>.</exception>
            <example>
            <code><![CDATA[
            AWnd.Find("Options").ButtonClick("Cancel");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.MenuClick(System.Int32,System.Boolean)">
            <summary>
            Posts a "menu item clicked" notification (<msdn>WM_COMMAND</msdn>) as if that menu item was clicked. Does not use the mouse.
            </summary>
            <param name="itemId">Menu item id. Must be in range 1 to 0xffff.</param>
            <param name="systemMenu">The menu item is in the title bar's context menu, not in the menu bar. Posts <msdn>WM_SYSCOMMAND</msdn> instead.</param>
            <exception cref="T:Au.Types.AuWndException">Invalid window.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid itemId.</exception>
            <remarks>
            Works only with standard (classic) menus. The drop-down menu window class name must be "#32768". Works with menu items in window menu bar, system menu and some context menus.
            Does not use the menu itself. Just posts WM_COMMAND or WM_SYSCOMMAND message. Even if a menu item with this id does not exist.
            This variable is the window that contains the menu bar or system menu. Or the drop-down menu window (class "#32768") that contains the menu item.
            </remarks>
        </member>
        <member name="T:Au.AWnd.Finder">
            <summary>
            Contains top-level window properties and can be used to find the window.
            </summary>
            <remarks>
            Can be used instead of <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/> or <see cref="M:Au.AWnd.FindAll(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            These codes are equivalent:
            <code>AWnd w = AWnd.Find(a, b, c, d, e); if(!w.Is0) Print(w);</code>
            <code>var p = new AWnd.Finder(a, b, c, d, e); if(p.Find()) Print(p.Result);</code>
            Also can find in a list of windows.
            </remarks>
        </member>
        <member name="P:Au.AWnd.Finder.Props">
            <summary>
            Parsed parameter values. All read-only.
            </summary>
        </member>
        <member name="P:Au.AWnd.Finder.TProps.DoesNotMatch">
            <summary>
            After unsuccesful <see cref="M:Au.AWnd.Finder.IsMatch(Au.AWnd,Au.Types.WFCache)"/> indicates the parameter that does not match.
            </summary>
        </member>
        <member name="M:Au.AWnd.Finder.#ctor(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)">
            <summary>
            See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            </summary>
            <exception cref="T:System.ArgumentException">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</exception>
        </member>
        <member name="M:Au.AWnd.Finder.op_Implicit(System.String)~Au.AWnd.Finder">
            <summary>
            Implicit conversion from string that can contain window name, class name, program and/or an object.
            Examples: <c>"name,cn,program"</c>, <c>"name"</c>, <c>",cn"</c>, <c>",,program"</c>, <c>"name,cn"</c>, <c>"name,,program"</c>, <c>",cn,program"</c>, <c>"name,,,object"</c>.
            </summary>
            <param name="s">
            One or more comma-separated window properties: name, class, program and/or an object. Empty parts are considered null.
            The same as parameters of <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>. The first 3 parts are <i>name</i>, <i>cn</i> and <i>program</i>. The last part is <i>contains</i> as string; can specify an accessible object, control or image.
            The first 3 comma-separated parts cannot contain commas. Alternatively, parts can be separated by '\0' characters, like <c>"name\0"+"cn\0"+"program\0"+"object"</c>. Then parts can contain commas. Example: <c>"*one, two, three*\0"</c> (name with commas).
            </param>
            <exception cref="T:System.Exception">Exceptions of the constructor.</exception>
        </member>
        <member name="P:Au.AWnd.Finder.Result">
            <summary>
            The found window.
            </summary>
        </member>
        <member name="M:Au.AWnd.Finder.Find">
            <summary>
            Finds the specified window, like <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            Returns true if found.
            The <see cref="P:Au.AWnd.Finder.Result"/> property will be the window.
            </summary>
        </member>
        <member name="M:Au.AWnd.Finder.FindInList(System.Collections.Generic.IEnumerable{Au.AWnd})">
            <summary>
            Finds the specified window in a list of windows.
            Returns 0-based index, or -1 if not found.
            The <see cref="P:Au.AWnd.Finder.Result"/> property will be the window.
            </summary>
            <param name="a">Array or list of windows, for example returned by <see cref="M:Au.AWnd.GetWnd.AllWindows(System.Boolean,System.Boolean)"/>.</param>
        </member>
        <member name="M:Au.AWnd.Finder.FindAll">
            <summary>
            Finds all matching windows, like <see cref="M:Au.AWnd.FindAll(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            Returns array containing 0 or more window handles as <b>AWnd</b>.
            </summary>
        </member>
        <member name="M:Au.AWnd.Finder.FindAllInList(System.Collections.Generic.IEnumerable{Au.AWnd})">
            <summary>
            Finds all matching windows in a list of windows.
            Returns array containing 0 or more window handles as <b>AWnd</b>.
            </summary>
            <param name="a">Array or list of windows, for example returned by <see cref="M:Au.AWnd.GetWnd.AllWindows(System.Boolean,System.Boolean)"/>.</param>
        </member>
        <member name="M:Au.AWnd.Finder._FindOrMatch(Au.AWnd._WndList,System.Action{Au.AWnd},Au.Types.WFCache)">
            <summary>
            Returns index of matching element or -1.
            Returns -1 if using getAll.
            </summary>
            <param name="a">List of AWnd. Does not dispose it.</param>
            <param name="getAll">If not null, calls it for all matching and returns -1.</param>
            <param name="cache"></param>
        </member>
        <member name="M:Au.AWnd.Finder.IsMatch(Au.AWnd,Au.Types.WFCache)">
            <summary>
            Returns true if window w properties match the specified properties.
            </summary>
            <param name="w">A top-level window. If 0 or invalid, returns false.</param>
            <param name="cache">Can be used to make faster when multiple <b>Finder</b> variables are used with same window. The function gets window name/class/program once, and stores in <i>cache</i>; next time it gets these strings from <i>cache</i>.</param>
        </member>
        <member name="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)">
            <summary>
            Finds a top-level window and returns its handle as <b>AWnd</b>.
            </summary>
            <returns>Returns <c>default(AWnd)</c> if not found.</returns>
            <param name="name">
            Window name. Usually it is the title bar text.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. "" means 'no name'.
            </param>
            <param name="cn">
            Window class name.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. Cannot be "".
            You can see window name, class name and program in editor's status bar and dialog "Find window or control".
            </param>
            <param name="program">
            Program file name, like <c>"notepad.exe"</c>.
            String format: [](xref:wildcard_expression).
            null means 'can be any'. Cannot be "". Cannot be path.
            
            Or <see cref="M:Au.Types.WF3.Process(System.Int32)"/>(process id), <see cref="M:Au.Types.WF3.Thread(System.Int32)"/>(thread id), <see cref="M:Au.Types.WF3.Owner(Au.Types.AnyWnd)"/>(owner window).
            See <see cref="P:Au.AWnd.ProcessId"/>, <see cref="P:Au.AProcess.ProcessId"/>, <see cref="P:Au.AWnd.ThreadId"/>, <see cref="P:Au.AThread.NativeId"/>, <see cref="P:Au.AWnd.Owner"/>.
            </param>
            <param name="flags"></param>
            <param name="also">
            Callback function. Called for each matching window.
            It can evaluate more properties of the window and return true when they match.
            Example: <c>also: t =&gt; !t.IsPopupWindow</c>.
            Called after evaluating all other parameters except <i>contains</i>.
            </param>
            <param name="contains">
            Text, image or other object in the client area of the window. Depends on type:
            <ul>
            <li><see cref="T:Au.AAcc.Finder"/> - arguments for <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>. Defines an accessible object that must be in the window.</li>
            <li><see cref="T:Au.AWnd.ChildFinder"/> - arguments for <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>. Defines a child control that must be in the window.</li>
            <li><see cref="T:System.Drawing.Bitmap"/> or other, except string - image(s) or color(s) that must be visible in the window. This function calls <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/> with flag <see cref="F:Au.Types.WIFlags.WindowDC"/>, and uses this value for the <i>image</i> parameter. See also <see cref="M:Au.AWinImage.LoadImage(System.String)"/>.</li>
            <li>string - an object that must be in the window. Depends on string format:
            <ul>
            <li><c>"a 'role' name"</c> or <c>"name"</c> or <c>"a 'role'"</c> - accessible object. See <see cref="M:Au.AAcc.Find(Au.AWnd,System.String,System.String,System.String,Au.Types.AFFlags,System.Func{Au.AAcc,System.Boolean},System.Int32,System.String,Au.AWnd.ChildFinder)"/>.</li>
            <li><c>"c 'cn' name"</c> or <c>"c '' name"</c> or <c>"c 'cn'"</c> - child control. See <see cref="M:Au.AWnd.Child(System.String,System.String,Au.Types.WCFlags,System.Func{Au.AWnd,System.Boolean},System.Int32)"/>.</li>
            <li><c>"image:..."</c> - image. See <see cref="M:Au.AWinImage.Find(Au.Types.WIArea,System.Object,Au.Types.WIFlags,System.Int32,System.Func{Au.AWinImage,Au.Types.WIAlso})"/>, <see cref="M:Au.AWinImage.LoadImage(System.String)"/>.</li>
            </ul>
            </li>
            </ul>
            </param>
            <remarks>
            To create code for this function, use dialog "Find window or control". It is form <b>Au.Tools.FormAWnd</b> in Au.Tools.dll.
            
            If there are multiple matching windows, gets the first in the Z order matching window, preferring visible windows.
            
            On Windows 8 and later finds only desktop windows, not Windows Store app Metro-style windows (on Windows 10 few such windows exist), unless this process has uiAccess or High+uiAccess or has disableWindowFiltering in manifest; to find such windows you can use <see cref="M:Au.AWnd.FindFast(System.String,System.String,Au.AWnd)"/>.
            
            To find message-only windows use <see cref="M:Au.AWnd.More.FindMessageOnlyWindow(System.String,System.String,Au.AWnd)"/> instead.
            </remarks>
            <exception cref="T:System.ArgumentException">
            - <i>cn</i> is "". To match any, use null.
            - <i>program</i> is "" or 0 or contains \ or /. To match any, use null.
            - Invalid wildcard expression (<c>"**options "</c> or regular expression).
            - Invalid image string in <i>contains</i>.
            </exception>
            <example>
            Try to find Notepad window. Return if not found.
            <code>
            AWnd w = AWnd.Find("* Notepad");
            if(w.Is0) { Print("not found"); return; }
            </code>
            Try to find Notepad window. Throw NotFoundException if not found.
            <code>
            AWnd w1 = AWnd.Find("* Notepad").OrThrow();
            </code>
            </example>
        </member>
        <member name="M:Au.AWnd.FindAll(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)">
            <summary>
            Finds all matching windows.
            Returns array containing 0 or more window handles as AWnd.
            Parameters etc are the same as <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            </summary>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</exception>
            <remarks>
            The list is sorted to match the Z order, however hidden windows (when using <see cref="F:Au.Types.WFFlags.HiddenToo"/>) are always after visible windows.
            </remarks>
            <seealso cref="M:Au.AWnd.GetWnd.AllWindows(System.Boolean,System.Boolean)"/>
            <seealso cref="M:Au.AWnd.GetWnd.MainWindows(System.Boolean)"/>
            <seealso cref="M:Au.AWnd.GetWnd.ThreadWindows(System.Int32,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AWnd.FindFast(System.String,System.String,Au.AWnd)">
            <summary>
            Finds a top-level window and returns its handle as <b>AWnd</b>.
            Returns <c>default(AWnd)</c> if not found. See also: <see cref="P:Au.AWnd.Is0"/>, <see cref="M:Au.AExtAu.OrThrow(Au.AWnd)"/>.
            </summary>
            <param name="name">
            Name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. "" means 'no name'.
            </param>
            <param name="cn">
            Class name.
            Full, case-insensitive. Wildcard etc not supported.
            null means 'can be any'. Cannot be "".
            </param>
            <param name="wAfter">If used, starts searching from the next window in the Z order.</param>
            <remarks>
            Calls API <msdn>FindWindowEx</msdn>.
            Faster than <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>, which uses API <msdn>EnumWindows</msdn>.
            Finds hidden windows too.
            To find message-only windows use <see cref="M:Au.AWnd.More.FindMessageOnlyWindow(System.String,System.String,Au.AWnd)"/> instead.
            Supports <see cref="T:Au.ALastError"/>.
            It is not recommended to use this function in a loop to enumerate windows. It would be unreliable because window positions in the Z order can be changed while enumerating. Also then it would be slower than <b>Find</b> and <b>FindAll</b>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.FindOrRun(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object,System.Action,System.Double,System.Boolean)">
            <summary>
            Finds a top-level window (calls <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>). If found, activates (optionally), else calls callback function and waits for the window. The callback should open the window, for example call <see cref="M:Au.AExec.Run(System.String,System.String,Au.Types.RFlags,Au.Types.RMore)"/>.
            Returns window handle as <b>AWnd</b>. Returns <c>default(AWnd)</c> if not found (if <i>runWaitS</i> is negative; else exception).
            </summary>
            <param name="name">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="cn">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="program">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="flags">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="also">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="contains">See <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="run">Callback function. See example.</param>
            <param name="runWaitS">How long to wait for the window after calling the callback function. Seconds. Default 60. See <see cref="M:Au.AWnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</param>
            <param name="needActiveWindow">Finally the window must be active. Default: true.</param>
            <exception cref="T:System.TimeoutException"><i>runWaitS</i> time has expired. Not thrown if <i>runWaitS</i> &lt;= 0.</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</exception>
            <remarks>
            The algorithm is:
            <code>
            var w=AWnd.Find(...);
            if(w.Is0) { run(); w=AWnd.Wait(runWaitS, needActiveWindow, ...); }
            else if(needActiveWindow) w.Activate();
            return w;
            </code>
            </remarks>
            <example>
            <code><![CDATA[
            AWnd w = AWnd.FindOrRun("* Notepad", run: () => AExec.Run("notepad.exe"));
            Print(w);
            ]]></code>
            </example>
        </member>
        <member name="T:Au.AWnd._WndList">
            <summary>
            An enumerable list of AWnd for <see cref="M:Au.AWnd.Finder._FindOrMatch(Au.AWnd._WndList,System.Action{Au.AWnd},Au.Types.WFCache)"/> and <see cref="M:Au.AWnd.ChildFinder._FindInList(Au.AWnd,Au.AWnd._WndList,System.Action{Au.AWnd})"/>.
            Holds Util.LibArrayBuilder or IEnumerator or single AWnd or none.
            Must be disposed if it is Util.LibArrayBuilder or IEnumerator, else disposing is optional.
            </summary>
        </member>
        <member name="M:Au.AWnd.FromXY(Au.Types.POINT,Au.Types.WXYFlags)">
            <summary>
            Gets visible top-level window or control from point.
            </summary>
            <param name="p">
            Coordinates relative to the primary screen.
            Tip: When need coordinates relative to another screen or/and the work area, use <see cref="M:Au.Types.Coord.Normalize(Au.Types.Coord,Au.Types.Coord,System.Boolean,Au.AScreen,System.Boolean,System.Boolean)"/> or tuple (x, y, workArea) etc. Example: <c>var a = AWnd.FromXY((x, y, true));</c>. Also when need <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.
            </param>
            <param name="flags"></param>
            <remarks>
            Alternatively can be used API <msdn>WindowFromPoint</msdn>, <msdn>ChildWindowFromPointEx</msdn> or <msdn>RealChildWindowFromPoint</msdn>, but all they have various limitations and are not very useful in automation scripts.
            This function gets non-transparent controls that are behind (in the Z order) transparent controls (group button, tab control etc); supports more control types than <msdn>RealChildWindowFromPoint</msdn>. Also does not skip disabled controls. All this is not true with flag Raw.
            This function is not very fast, probably 0.3 - 1 ms.
            </remarks>
        </member>
        <member name="M:Au.AWnd.FromMouse(Au.Types.WXYFlags)">
            <summary>
            Gets visible top-level window or control from mouse cursor position.
            More info: <see cref="M:Au.AWnd.FromXY(Au.Types.POINT,Au.Types.WXYFlags)"/>.
            </summary>
        </member>
        <member name="M:Au.AWnd.ChildFromXY(Au.Types.Coord,Au.Types.Coord,System.Boolean,System.Boolean)">
            <summary>
            Gets child control from point.
            Returns default(AWnd) if the point is not in a child control or not in the client area of this window.
            </summary>
            <param name="x">X coordinate in the client area of this window. Can be <see cref="M:Au.Types.Coord.Reverse(System.Int32)"/> etc.</param>
            <param name="y">Y coordinate in the client area of this window. Can be <b>Coord.Reverse</b> etc.</param>
            <param name="screenXY">The coordinates are relative to the pimary screen, not to the client area.</param>
            <param name="directChild">Get direct child, not a child of a child and so on.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.AWnd.ChildFromXY(Au.Types.POINT,System.Boolean,System.Boolean)">
            <param name="p">Coordinates in the client area of this window.</param>
            <param name="screenXY"></param>
            <param name="directChild"></param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
        </member>
        <member name="M:Au.AWnd._SiblingXY(Au.AWnd._SibXY,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Get sibling control in space: left, right, above or below.
            Returns default(AWnd) if there is no sibling.
            </summary>
            <param name="direction"></param>
            <param name="distance">Distance from this control (from its edge) in the specified direction. Default 10.</param>
            <param name="edgeOffset">
            Distance in perpendicular direction, along the specified edge. Default 5.
            If <i>direction</i> is <b>Left</b> or <b>Right</b>, 0 is the top edge, 1 is 1 pixel down, -1 is 1 pixel up, and so on.
            If <i>direction</i> is <b>Above</b> or <b>Below</b>, 0 is the left edge, 1 is 1 pixel to the right, -1 is 1 pixel to the left, and so on.
            </param>
            <param name="topChild">If at that point is a visible child or descendant of the sibling, get that child/descendant. Default false.</param>
            <exception cref="T:Au.Types.AuWndException">This variable is invalid (window not found, closed, etc).</exception>
            <remarks>
            This function is used mostly with controls, but supports top-level windows too.
            </remarks>
        </member>
        <member name="P:Au.AWnd.Get">
            <summary>
            Gets related windows and controls.
            Use like <c>AWnd w2 = w1.Get.Owner;</c> (here w1 is an AWnd variable).
            </summary>
        </member>
        <member name="M:Au.AWnd.SwitchActiveWindow">
            <summary>
            Activates next non-minimized main window, like with Alt+Tab.
            Returns true if activated, false if there is no such window or failed to activate.
            </summary>
            <remarks>
            Uses <see cref="M:Au.AWnd.GetWnd.NextMain(Au.AWnd,System.Boolean,System.Boolean,System.Boolean)"/>, <see cref="M:Au.AWnd.GetWnd.LastActiveOwnedOrThis(System.Boolean)"/>, <see cref="M:Au.AWnd.Activate"/>.
            An alternative way - send Alt+Tab keys, but it works not everywhere.
            </remarks>
        </member>
        <member name="P:Au.AWnd.Owner">
            <summary>
            Gets or sets the owner window of this top-level window.
            </summary>
            <exception cref="T:Au.Types.AuWndException">Failed (only the 'set' function).</exception>
            <remarks>
            A window that has an owner window is always on top of it.
            Don't call this for controls, they don't have an owner window.
            The 'get' function returns default(AWnd) if this window isn't owned or is invalid. Supports <see cref="T:Au.ALastError"/>.
            The 'set' function can fail, eg if the owner's process has higher [](xref:uac) integrity level.
            </remarks>
        </member>
        <member name="P:Au.AWnd.Window">
            <summary>
            Gets the top-level parent window of this control.
            If this is a top-level window, returns this. Returns default(AWnd) if this window is invalid.
            </summary>
            <remarks>Supports <see cref="T:Au.ALastError"/>.</remarks>
        </member>
        <member name="P:Au.AWnd.IsChild">
            <summary>
            Returns true if this is a child window (control), false if top-level window.
            </summary>
            <remarks>
            Supports <see cref="T:Au.ALastError"/>.
            Another way is <c>w.HasStyle(WS.CHILD)</c>. It is faster but less reliable, because some top-level windows have WS_CHILD style and some child windows don't.
            </remarks>
            <seealso cref="P:Au.AWnd.GetWnd.DirectParent"/>
        </member>
        <member name="M:Au.AWnd.IsChildOf(Au.AWnd)">
            <summary>
            Returns true if this is a child or descendant of window w.
            </summary>
            <remarks>
            Calls API <msdn>IsChild</msdn>.
            Supports <see cref="T:Au.ALastError"/>.
            </remarks>
        </member>
        <member name="P:Au.AWnd.LibParentGWL">
            <summary>
            Returns <c>(AWnd)GetWindowLong(Native.GWL.HWNDPARENT)</c>.
            </summary>
        </member>
        <member name="P:Au.AWnd.Active">
            <summary>
            Gets the active (foreground) window.
            Calls API <msdn>GetForegroundWindow</msdn>.
            Returns default(AWnd) if there is no active window; more info: <see cref="M:Au.AWnd.More.WaitForAnActiveWindow"/>.
            </summary>
        </member>
        <member name="P:Au.AWnd.IsActive">
            <summary>
            Returns true if this window is the active (foreground) window.
            </summary>
        </member>
        <member name="P:Au.AWnd.LibIsActiveOrNoActiveAndThisIsWndRoot">
            <summary>
            Returns true if this window is the active (foreground) window.
            If this is <see cref="P:Au.AWnd.GetWnd.Root"/>, returns true if there is no active window.
            </summary>
        </member>
        <member name="M:Au.AWnd.SetTransparency(System.Boolean,System.Nullable{System.Double},System.Nullable{Au.Types.ColorInt})">
            <summary>
            Sets transparency.
            On Windows 7 works only with top-level windows, on newer OS also with controls.
            </summary>
            <param name="allowTransparency">Set or remove WS_EX_LAYERED style that is required for transparency. If false, other parameters are not used.</param>
            <param name="opacity">Opacity from 0.0 (completely transparent) to 1.0 (opaque). If null, sets default value (opaque).</param>
            <param name="colorRGB">Make pixels painted with this color completely transparent. If null, sets default value (no transparent color). The alpha byte is not used.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">opacity is less than 0.0 or greater than 1.0.</exception>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="P:Au.AWnd.IsFullScreen">
            <summary>
            Returns true if this is a full-screen window and not desktop.
            </summary>
        </member>
        <member name="P:Au.AWnd.LibIsOfShellThread">
            <summary>
            Returns true if this belongs to GetShellWindow's thread (usually it is the desktop window).
            </summary>
        </member>
        <member name="P:Au.AWnd.LibIsOfShellProcess">
            <summary>
            Returns true if this belongs to GetShellWindow's process (eg a folder window, desktop, taskbar).
            </summary>
        </member>
        <member name="P:Au.AWnd.IsWindows8MetroStyle">
            <summary>
            Returns true if this window has Metro style, ie is not a classic desktop window.
            On Windows 8/8.1 most Windows Store app windows and many shell windows have Metro style.
            On Windows 10 few windows have Metro style.
            On Windows 7 there are no Metro style windows.
            </summary>
            <seealso cref="M:Au.AWnd.More.GetWindowsStoreAppId(Au.AWnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Au.AWnd.IsWindows10StoreApp">
            <summary>
            Returns non-zero if this window is a Windows 10 Store app window: 1 if class name is "ApplicationFrameWindow", 2 if "Windows.UI.Core.CoreWindow".
            </summary>
            <seealso cref="M:Au.AWnd.More.GetWindowsStoreAppId(Au.AWnd,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:Au.AWnd.SavePositionSizeState(System.Boolean)">
            <summary>
            Gets window position, size and state stored in a string that can be used with <see cref="M:Au.AWnd.RestorePositionSizeState(System.String,System.Boolean,System.Boolean)"/>.
            Returns null if failed. Supports <see cref="T:Au.ALastError"/>.
            </summary>
            <param name="canBeMinimized">If now the window is minimized, let RestorePositionSizeState make it minimized. If false, RestorePlacement will restore it to the most recent non-minimized state.</param>
        </member>
        <member name="M:Au.AWnd.RestorePositionSizeState(System.String,System.Boolean,System.Boolean)">
            <summary>
            Restores window position, size and state that is stored in a string created by <see cref="M:Au.AWnd.SavePositionSizeState(System.Boolean)"/>.
            </summary>
            <param name="s">The string. Can be null/"".</param>
            <param name="ensureInScreen">Call <see cref="M:Au.AWnd.EnsureInScreen(Au.AScreen,System.Boolean)"/>. Even when s is null/"".</param>
            <param name="showActivate">Call <see cref="M:Au.AWnd.Show(System.Boolean)"/>(true) and <see cref="M:Au.AWnd.ActivateLL"/>. Even when s is null/"".</param>
            <exception cref="T:Au.Types.AuWndException"/>
        </member>
        <member name="M:Au.AWnd.LibMinimalSleepIfOtherThread">
            <summary>
            if(!IsOfThisThread) { Thread.Sleep(15); SendTimeout(1000, 0); }
            </summary>
        </member>
        <member name="M:Au.AWnd.LibMinimalSleepNoCheckThread">
            <summary>
            Thread.Sleep(15); SendTimeout(1000, 0);
            </summary>
        </member>
        <member name="M:Au.AWnd._WindowsStoreAppFrameChild(Au.AWnd)">
            <summary>
            On Win10+, if w is "ApplicationFrameWindow", returns the real app window "Windows.UI.Core.CoreWindow" hosted by w.
            If w is minimized, cloaked (eg on other desktop) or the app is starting, the "Windows.UI.Core.CoreWindow" is not its child. Then searches for a top-level window named like w. It is unreliable, but MS does not provide API for this.
            Info: "Windows.UI.Core.CoreWindow" windows hosted by "ApplicationFrameWindow" belong to separate processes. All "ApplicationFrameWindow" windows belong to a single process.
            </summary>
        </member>
        <member name="M:Au.AWnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)">
            <summary>
            Waits until window exists, is visible (optionally) and active (optionally).
            Returns window handle. On timeout returns default(AWnd) if <i>secondsTimeout</i> is negative; else exception.
            Parameters etc are the same as <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="active">The window must be the active window (<see cref="P:Au.AWnd.Active"/>), and not minimized.</param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</exception>
            <remarks>
            By default ignores invisible and cloaked windows. Use flags if need.
            If you have a window's AWnd variable, to wait until it is active/visible/etc use <see cref="M:Au.AWnd.WaitForCondition(System.Double,System.Func{Au.AWnd,System.Boolean},System.Boolean)"/> instead.
            </remarks>
            <example>
            <code><![CDATA[
            AWnd w = AWnd.Wait(10, false, "* Notepad");
            Print(w);
            ]]></code>
            Using in a Form/Control event handler.
            <code><![CDATA[
            var f = new Form();
            f.Click += async (unu, sed) =>
              {
            	  Print("waiting for Notepad...");
            	  AWnd w = await Task.Run(() => AWnd.Wait(-10, false, "* Notepad"));
            	  if(w.Is0) Print("timeout"); else Print(w);
              };
            f.ShowDialog();
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.WaitAny(System.Double,System.Boolean,Au.AWnd.Finder[])">
            <summary>
            Waits until any of specified windows exists, is visible (optionally) and active (optionally).
            Returns 1-based index and window handle. On timeout returns <c>(0, default(AWnd))</c> if <i>secondsTimeout</i> is negative; else exception.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="active">The window must be the active window (<see cref="P:Au.AWnd.Active"/>), and not minimized.</param>
            <param name="windows">One or more variables containing window properties. Can be strings, see <see cref="M:Au.AWnd.Finder.op_Implicit(System.String)~Au.AWnd.Finder"/>.</param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <remarks>
            By default ignores invisible and cloaked windows. Use finder flags if need.
            </remarks>
            <example>
            <code><![CDATA[
            var (i, w) = AWnd.WaitAny(10, true, "* Notepad", new AWnd.Finder("* Word"));
            Print(i, w);
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.WaitNot(System.Double,System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)">
            <summary>
            Waits until window does not exist.
            Parameters etc are the same as <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:System.Exception">Exceptions of <see cref="M:Au.AWnd.Find(System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.</exception>
            <remarks>
            By default ignores invisible and cloaked windows. Use flags if need.
            If you have a window's AWnd variable, to wait until it is closed use <see cref="M:Au.AWnd.WaitForClosed(System.Double,System.Boolean)"/> instead.
            Examples: <see cref="M:Au.AWnd.Wait(System.Double,System.Boolean,System.String,System.String,Au.Types.WF3,Au.Types.WFFlags,System.Func{Au.AWnd,System.Boolean},System.Object)"/>.
            </remarks>
        </member>
        <member name="M:Au.AWnd.WaitNot(System.Double,Au.AWnd@,Au.AWnd.Finder)">
            <summary>
            Waits until window does not exist.
            </summary>
            <param name="secondsTimeout"></param>
            <param name="wFound">On timeout receives the first found matching window that exists.</param>
            <param name="f">Window properties etc. Can be string, see <see cref="M:Au.AWnd.Finder.op_Implicit(System.String)~Au.AWnd.Finder"/>.</param>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
        </member>
        <member name="M:Au.AWnd.WaitForCondition(System.Double,System.Func{Au.AWnd,System.Boolean},System.Boolean)">
            <summary>
            Waits for an user-defined state/condition of this window. For example active, visible, enabled, closed, contains control.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="condition">Callback function (eg lambda). It is called repeatedly, until returns true.</param>
            <param name="doNotThrowIfClosed">
            Do not throw exception when the window handle is invalid or the window was closed while waiting.
            In such case the callback function must return false, like in the examples with <see cref="P:Au.AWnd.IsAlive"/>. Else exception is thrown (with a small delay) to prevent infinite waiting.
            </param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">The window handle is invalid or the window was closed while waiting.</exception>
            <example>
            <code><![CDATA[
            AWnd w = AWnd.Find("* Notepad");
            
            //wait max 30 s until window w is active. Exception on timeout or if closed.
            w.WaitForCondition(30, t => t.IsActive);
            Print("active");
            
            //wait max 30 s until window w is enabled. Exception on timeout or if closed.
            w.WaitForCondition(30, t => t.IsEnabled);
            Print("enabled");
            
            //wait until window w is closed
            w.WaitForCondition(0, t => !t.IsAlive, true); //same as w.WaitForClosed()
            Print("closed");
            
            //wait until window w is minimized or closed
            w.WaitForCondition(0, t => t.IsMinimized || !t.IsAlive, true);
            if(!w.IsAlive) { Print("closed"); return; }
            Print("minimized");
            
            //wait until window w contains focused control classnamed "Edit"
            var c = new AWnd.ChildFinder(cn: "Edit");
            w.WaitForCondition(10, t => c.Find(t) && c.Result.IsFocused);
            Print("control focused");
            ]]></code>
            </example>
        </member>
        <member name="M:Au.AWnd.WaitForName(System.Double,System.String)">
            <summary>
            Waits until this window has the specified name.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="name">
            Window name. Usually it is the title bar text.
            String format: [](xref:wildcard_expression).
            </param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuWndException">The window handle is invalid or the window was closed while waiting.</exception>
            <exception cref="T:System.ArgumentException">Invalid wildcard expression.</exception>
        </member>
        <member name="M:Au.AWnd.WaitForClosed(System.Double,System.Boolean)">
            <summary>
            Waits until this window is closed/destroyed or until its process ends.
            </summary>
            <param name="secondsTimeout">Timeout, seconds. Can be 0 (infinite), &gt;0 (exception) or &lt;0 (no exception). More info: [](xref:wait_timeout).</param>
            <param name="waitUntilProcessEnds">Wait until the process of this window ends.</param>
            <returns>Returns true. On timeout returns false if <i>secondsTimeout</i> is negative; else exception.</returns>
            <exception cref="T:System.TimeoutException"><i>secondsTimeout</i> time has expired (if &gt; 0).</exception>
            <exception cref="T:Au.Types.AuException">Failed to open process handle when <i>waitUntilProcessEnds</i> is true.</exception>
            <remarks>
            If the window is already closed, immediately returns true.
            </remarks>
        </member>
    </members>
</doc>
